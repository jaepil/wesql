diff --git a/CMakeLists.txt b/CMakeLists.txt
index 2f26c3b342e..2d02eaa0c94 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -522,6 +522,25 @@ ELSE()
   MARK_AS_ADVANCED(MYSQL_PROJECT_NAME)
 ENDIF()
 
+OPTION(WITH_WESQL "use wesql mode" ON)
+OPTION(WITH_RAFT_REPLICATION "use consensus cluster mode" ON)
+OPTION(WITH_WESQL_TEST "wesql test mode" OFF)
+
+IF(WITH_WESQL)
+  ADD_DEFINITIONS(-DWESQL)
+  IF (DEFINED WITHOUT_RAFT_REPLICATION AND WITHOUT_RAFT_REPLICATION)
+    SET(WITH_RAFT_REPLICATION OFF)
+  ENDIF()
+  IF (WITH_RAFT_REPLICATION)
+    ADD_DEFINITIONS(-DWESQL_CLUSTER)
+  ENDIF()
+  IF(WITH_WESQL_TEST)
+    ADD_DEFINITIONS(-DWESQL_TEST)
+  ENDIF()
+ELSE()
+  SET(WITH_RAFT_REPLICATION OFF)
+ENDIF()
+
 # Handle upgrade of old cmake cache
 IF(DEFINED WITH_PLUGIN_NDBCLUSTER)
   IF(NOT WITH_NDBCLUSTER)
@@ -808,6 +827,8 @@ INCLUDE(CMakePushCheckState)
 
 # Add macros
 INCLUDE(add_custom_target)
+INCLUDE(aws_sdk_cpp)
+INCLUDE(aliyun_oss_sdk)
 INCLUDE(pkg-config)
 INCLUDE(character_sets)
 INCLUDE(cmake_parse_arguments)
@@ -1749,6 +1770,12 @@ IF(WITH_SYSTEM_LIBS)
   UNSET(WITH_SYSTEM_LIBS CACHE)
 ENDIF()
 
+# Add bundled or system objstore lib, here is aws-sdk-cpp.
+MYSQL_CHECK_OBJSTORE_S3()
+
+# Add aliyun-oss-cpp-sdk, see https://github.com/aliyun/aliyun-oss-cpp-sdk
+MYSQL_CHECK_OBJSTORE_ALIYUN_OSS()
+
 # Add bundled or system zlib.
 MYSQL_CHECK_ZLIB()
 
@@ -2057,6 +2084,24 @@ IF(WITH_PROTOBUF STREQUAL "bundled" OR WITH_FIDO STREQUAL "bundled")
   ENDIF()
 ENDIF()
 
+
+#Compile the smartengine storage plugin into mysqld.
+OPTION(WITH_SMARTENGINE "Compile smartengine" ON)
+IF (WITH_SMARTENGINE)
+  ADD_DEFINITIONS(-DWITH_SMARTENGINE)
+ENDIF()
+
+OPTION(WITH_QUERY_TRACE "WITH_QUERY_TRACE" ON)
+if (WITH_QUERY_TRACE)
+  add_definitions(-DWITH_QUERY_TRACE)
+endif()
+
+#Ensure compatibility with the usage patterns of xengine
+OPTION(WITH_XENGINE_COMPATIBLE_MODE "Compatible with xengine" OFF)
+IF (WITH_XENGINE_COMPATIBLE_MODE)
+  ADD_DEFINITIONS(-DWITH_XENGINE_COMPATIBLE_MODE)
+ENDIF()
+
 #
 # Setup maintainer mode options by the end. Platform checks are
 # not run with the warning options as to not perturb fragile checks
@@ -2327,6 +2372,9 @@ IF(LINUX AND NOT WITHOUT_SERVER)
   IF(LINUX_SUSE)
     ADD_SUBDIRECTORY(packaging/rpm-sles)
   ENDIF()
+  IF(WITH_WESQL)
+    ADD_SUBDIRECTORY(packaging/build-wesql)
+  ENDIF()
 ENDIF()
 
 GET_PROPERTY(CWD_DEFINITIONS DIRECTORY PROPERTY COMPILE_DEFINITIONS)
@@ -2468,7 +2516,7 @@ ENDIF()
 #
 IF(NOT INSTALL_LAYOUT MATCHES "RPM")
   INSTALL(FILES
-    README
+    README.md
     LICENSE
     DESTINATION ${INSTALL_DOCREADMEDIR} COMPONENT Readme)
   INSTALL(FILES
diff --git a/MYSQL_VERSION b/MYSQL_VERSION
index 1c01c40cadf..994884d848c 100644
--- a/MYSQL_VERSION
+++ b/MYSQL_VERSION
@@ -3,3 +3,4 @@ MYSQL_VERSION_MINOR=0
 MYSQL_VERSION_PATCH=35
 MYSQL_VERSION_EXTRA=
 MYSQL_VERSION_STABILITY="LTS"
+WESQL_VERSION=0.1.0
diff --git a/client/client_priv.h b/client/client_priv.h
index f88c35271b1..f58cb84e43b 100644
--- a/client/client_priv.h
+++ b/client/client_priv.h
@@ -140,6 +140,11 @@ enum options_client {
   OPT_FIX_DB_NAMES,
   OPT_SSL_VERIFY_SERVER_CERT,
   OPT_AUTO_VERTICAL_OUTPUT,
+#ifdef WESQL_CLUSTER
+#ifndef DBUG_OFF
+  OPT_DEBUG_CONSENSUSLOG_REVISE_CHECK,
+#endif
+#endif
   OPT_DEBUG_INFO,
   OPT_DEBUG_CHECK,
   OPT_COLUMN_TYPES,
@@ -172,6 +177,10 @@ enum options_client {
   OPT_PRINT_TABLE_METADATA,
   OPT_SSL_FIPS_MODE,
   OPT_TLS_CIPHERSUITES,
+#ifdef WESQL_CLUSTER
+  OPT_START_INDEX,
+  OPT_STOP_INDEX,
+#endif
   OPT_MYSQL_BINARY_AS_HEX,
   OPT_LOAD_DATA_LOCAL_DIR,
   OPT_READ_FROM_REMOTE_MASTER_DEPRECATED,
diff --git a/client/mysqlbinlog.cc b/client/mysqlbinlog.cc
index 99b492eeb72..b4de00ad385 100644
--- a/client/mysqlbinlog.cc
+++ b/client/mysqlbinlog.cc
@@ -77,6 +77,12 @@
 
 using std::max;
 using std::min;
+#ifdef WESQL_CLUSTER
+#ifndef DBUG_OFF
+uint32 tt_guard = 0;
+uint32 pos_guard = 0;
+#endif
+#endif
 
 /**
   For storing information of the Format_description_event of the currently
@@ -775,6 +781,16 @@ Sid_map *global_sid_map = nullptr;
 Checkable_rwlock *global_sid_lock = nullptr;
 Gtid_set *gtid_set_included = nullptr;
 Gtid_set *gtid_set_excluded = nullptr;
+
+#ifdef WESQL_CLUSTER
+static ulonglong start_index = 0;
+static ulonglong stop_index = 0;
+static ulonglong current_index = 0;
+#ifndef DBUG_OFF
+static bool debug_consensuslog_revise_check;
+#endif
+#endif
+
 static uint opt_zstd_compress_level = default_zstd_compression_level;
 static char *opt_compress_algorithm = nullptr;
 
@@ -1372,13 +1388,53 @@ static Exit_status process_event(PRINT_EVENT_INFO *print_event_info,
   Exit_status retval = OK_CONTINUE;
   IO_CACHE *const head = &print_event_info->head_cache;
 
+#ifdef WESQL_CLUSTER
+#ifndef DBUG_OFF
+  if (debug_consensuslog_revise_check) {
+    uint32 tt_now = (uint32)ev->common_header->when.tv_sec;
+    if (tt_guard > tt_now + 1)  // only allow 1 sec diff
+    {
+      error("Error check timestamp, current_index %llu", current_index);
+      exit(1);
+    }
+    tt_guard = tt_now;
+    uint32 pos_now = ev->common_header->log_pos;
+    if (pos_guard >= pos_now) {
+      error(
+          "Error check position, current_index %llu, pos_guard %u, pos_now %u",
+          current_index, pos_guard, pos_now);
+      exit(1);
+    }
+    pos_guard = pos_now;
+  }
+#endif
+
+  if (ev_type == binary_log::CONSENSUS_LOG_EVENT)
+  {
+    Consensus_log_event* cev= (Consensus_log_event*)ev;
+    current_index = cev->get_index();
+  }
+  else if (ev_type == binary_log::PREVIOUS_CONSENSUS_INDEX_LOG_EVENT)
+  {
+    Previous_consensus_index_log_event* pcev= (Previous_consensus_index_log_event*)ev;
+    current_index = pcev->get_index();
+  }
+#endif
+
   /*
     Format events are not concerned by --offset and such, we always need to
     read them to be able to process the wanted events.
   */
+#ifdef WESQL_CLUSTER
+  if (((rec_count >= offset) &&
+       ((my_time_t)(ev->common_header->when.tv_sec) >= start_datetime) &&
+       (current_index >= start_index)) ||
+      (ev_type == binary_log::FORMAT_DESCRIPTION_EVENT)) {
+#else
   if (((rec_count >= offset) &&
        ((my_time_t)(ev->common_header->when.tv_sec) >= start_datetime)) ||
       (ev_type == binary_log::FORMAT_DESCRIPTION_EVENT)) {
+#endif
     if (ev_type != binary_log::FORMAT_DESCRIPTION_EVENT) {
       /*
         We have found an event after start_datetime, from now on print
@@ -1409,7 +1465,12 @@ static Exit_status process_event(PRINT_EVENT_INFO *print_event_info,
     }
 
     // reached stop time
+#ifdef WESQL_CLUSTER
+    if (((my_time_t)(ev->common_header->when.tv_sec) >= stop_datetime) ||
+        (pos >= stop_position_mot) || (current_index >= stop_index)) {
+#else
     if (((my_time_t)(ev->common_header->when.tv_sec) >= stop_datetime)) {
+#endif
       /* end the program */
       retval = OK_STOP;
       goto end;
@@ -1846,6 +1907,12 @@ static struct my_option my_long_options[] = {
     {"debug-info", OPT_DEBUG_INFO, "Print some debug info at exit.",
      &debug_info_flag, &debug_info_flag, nullptr, GET_BOOL, NO_ARG, 0, 0, 0,
      nullptr, 0, nullptr},
+#ifdef WESQL_CLUSTER
+    {"debug-consensuslog-revise-check", OPT_DEBUG_CONSENSUSLOG_REVISE_CHECK,
+     "check timestamp and postion after consensuslog revise",
+     &debug_consensuslog_revise_check, &debug_consensuslog_revise_check, 0,
+     GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},
+#endif
 #endif
     {"default_auth", OPT_DEFAULT_AUTH,
      "Default authentication client-side plugin to use.", &opt_default_auth,
@@ -1979,6 +2046,13 @@ static struct my_option my_long_options[] = {
      BIN_LOG_HEADER_SIZE, BIN_LOG_HEADER_SIZE,
      /* COM_BINLOG_DUMP accepts only 4 bytes for the position */
      (ulonglong)(~(uint64)0), nullptr, 0, nullptr},
+#ifdef WESQL_CLUSTER
+    {"start-index", OPT_START_INDEX,
+     "Start reading the binlog at index N. Applies to the first binlog "
+     "passed on the command line.",
+     &start_index, &start_index, 0, GET_ULL, REQUIRED_ARG,
+     0, 0, INT_MAX64, 0, 0, 0},
+#endif
     {"stop-datetime", OPT_STOP_DATETIME,
      "Stop reading the binlog at first event having a datetime equal or "
      "posterior to the argument; the argument must be a date and time "
@@ -2013,6 +2087,13 @@ static struct my_option my_long_options[] = {
      &stop_position, &stop_position, nullptr, GET_ULL, REQUIRED_ARG,
      (longlong)(~(my_off_t)0), BIN_LOG_HEADER_SIZE, (ulonglong)(~(my_off_t)0),
      nullptr, 0, nullptr},
+#ifdef WESQL_CLUSTER
+    {"stop-index", OPT_STOP_INDEX,
+     "Stop reading the binlog at index N. Applies to the last binlog "
+     "passed on the command line.",
+     &stop_index, &stop_index, 0, GET_ULL, REQUIRED_ARG,
+     INT_MAX64, 0, INT_MAX64, 0, 0, 0},
+#endif
     {"to-last-log", 't',
      "Requires -R. Will not stop at the end of the "
      "requested binlog but rather continue printing until the end of the last "
diff --git a/cmake/mysql_version.cmake b/cmake/mysql_version.cmake
index 3f5f85d8092..19641305a01 100644
--- a/cmake/mysql_version.cmake
+++ b/cmake/mysql_version.cmake
@@ -55,6 +55,9 @@ MACRO(GET_MYSQL_VERSION)
   MYSQL_GET_CONFIG_VALUE("MYSQL_VERSION_MINOR" MINOR_VERSION)
   MYSQL_GET_CONFIG_VALUE("MYSQL_VERSION_PATCH" PATCH_VERSION)
   MYSQL_GET_CONFIG_VALUE("MYSQL_VERSION_EXTRA" EXTRA_VERSION)
+  IF(WITH_WESQL)
+    MYSQL_GET_CONFIG_VALUE("WESQL_VERSION" WESQL_VERSION)
+  ENDIF()
 
   IF(NOT DEFINED MAJOR_VERSION OR
      NOT DEFINED MINOR_VERSION OR
diff --git a/include/m_ctype.h b/include/m_ctype.h
index b30174df9dc..ffc732da885 100644
--- a/include/m_ctype.h
+++ b/include/m_ctype.h
@@ -155,6 +155,11 @@ static constexpr uint32_t
 /* Flags for strxfrm */
 #define MY_STRXFRM_PAD_TO_MAXLEN 0x00000080 /* if pad tail(for filesort) */
 
+/* For smartengine packing, do not pad with spaces, follow < 8.0.2 behavior */
+#ifdef WITH_SMARTENGINE
+#define MY_STRXFRM_NOPAD_WITH_SPACE 0x10000000
+#endif
+
 typedef struct MY_UNI_IDX {
   uint16 from;
   uint16 to;
diff --git a/include/m_string.h b/include/m_string.h
index be531c9ae27..240bae857aa 100644
--- a/include/m_string.h
+++ b/include/m_string.h
@@ -287,6 +287,8 @@ static constexpr int FLOATING_POINT_BUFFER{311 + DECIMAL_NOT_SPECIFIED};
 #define MY_GCVT_MAX_FIELD_WIDTH \
   (DBL_DIG + 4 + std::max(5, MAX_DECPT_FOR_F_FORMAT))
 
+extern char *int2str(long val, char *dst, int radix, int upcase);
+
 const char *str2int(const char *src, int radix, long lower, long upper,
                     long *val);
 longlong my_strtoll10(const char *nptr, const char **endptr, int *error);
@@ -312,6 +314,7 @@ static inline char *ullstr(longlong value, char *buff) {
 }
 
 #define STRING_WITH_LEN(X) (X), ((sizeof(X) - 1))
+#define C_STRING_WITH_LEN(X) ((const char *)(X)), ((sizeof(X) - 1))
 
 /**
   Skip trailing space (ASCII spaces only).
diff --git a/include/my_base.h b/include/my_base.h
index cf5a47cb737..196f2cd9206 100644
--- a/include/my_base.h
+++ b/include/my_base.h
@@ -992,8 +992,16 @@ Information in the data-dictionary needs to be updated. */
 #define HA_ERR_SAMPLING_INIT_FAILED 208
 /** Too many sub-expression in search string */
 #define HA_ERR_FTS_TOO_MANY_NESTED_EXP 209
+
+#ifdef WITH_SMARTENGINE
+/** Unexpected nullptr in smartengine handler */
+#define HA_ERR_INVALID_NULL_ERROR 210
+/** Copy of last error number */
+#define HA_ERR_LAST 210
+#else
 /** Copy of last error number */
 #define HA_ERR_LAST 209
+#endif //end of WITH_SMARTENGINE
 
 /* Number of different errors */
 #define HA_ERR_ERRORS (HA_ERR_LAST - HA_ERR_FIRST + 1)
diff --git a/include/my_sqlcommand.h b/include/my_sqlcommand.h
index 3700f99a480..ee3da1411fa 100644
--- a/include/my_sqlcommand.h
+++ b/include/my_sqlcommand.h
@@ -202,6 +202,12 @@ enum enum_sql_command {
   SQLCOM_RESTART_SERVER,
   SQLCOM_CREATE_SRS,
   SQLCOM_DROP_SRS,
+  SQLCOM_ADMIN_PROC,
+  SQLCOM_TRANS_PROC,
+  SQLCOM_SHOW_CONSENSUSLOGS,
+  SQLCOM_SHOW_CONSENSUSLOG_EVENTS,
+  SQLCOM_START_RAFT_REPLICATION,
+  SQLCOM_STOP_RAFT_REPLICATION,
   /* This should be the last !!! */
   SQLCOM_END
 };
diff --git a/include/mysql/plugin_audit.h.pp b/include/mysql/plugin_audit.h.pp
index 8db4d6ee40f..37ae1a387f3 100644
--- a/include/mysql/plugin_audit.h.pp
+++ b/include/mysql/plugin_audit.h.pp
@@ -335,6 +335,12 @@ enum enum_sql_command {
   SQLCOM_RESTART_SERVER,
   SQLCOM_CREATE_SRS,
   SQLCOM_DROP_SRS,
+  SQLCOM_ADMIN_PROC,
+  SQLCOM_TRANS_PROC,
+  SQLCOM_SHOW_CONSENSUSLOGS,
+  SQLCOM_SHOW_CONSENSUSLOG_EVENTS,
+  SQLCOM_START_RAFT_REPLICATION,
+  SQLCOM_STOP_RAFT_REPLICATION,
   SQLCOM_END
 };
 #include "plugin_audit_message_types.h"
diff --git a/include/mysql_version.h.in b/include/mysql_version.h.in
index d666e072d61..c13feed5899 100644
--- a/include/mysql_version.h.in
+++ b/include/mysql_version.h.in
@@ -25,6 +25,8 @@
 #define LIBMYSQL_VERSION           "@VERSION@"
 #define LIBMYSQL_VERSION_ID         @MYSQL_VERSION_ID@
 
+#define WESQL_VERSION              "@WESQL_VERSION@"
+
 #ifndef LICENSE
 #define LICENSE                     GPL
 #endif /* LICENSE */
diff --git a/libbinlogevents/include/binlog_event.h b/libbinlogevents/include/binlog_event.h
index f2714f6291b..4cf4175ab31 100644
--- a/libbinlogevents/include/binlog_event.h
+++ b/libbinlogevents/include/binlog_event.h
@@ -357,10 +357,20 @@ enum Log_event_type {
   TRANSACTION_PAYLOAD_EVENT = 40,
 
   HEARTBEAT_LOG_EVENT_V2 = 41,
-  /**
-    Add new events here - right above this comment!
-    Existing events (except ENUM_END_EVENT) should never change their numbers
-  */
+/**
+  Add new events here - right above this comment!
+  Existing events (except ENUM_END_EVENT) should never change their numbers
+*/
+#ifdef WESQL_CLUSTER
+  CONSENSUS_LOG_EVENT = 101,
+
+  PREVIOUS_CONSENSUS_INDEX_LOG_EVENT = 102,
+
+  CONSENSUS_CLUSTER_INFO_EVENT = 103,
+
+  CONSENSUS_EMPTY_EVENT = 104,
+#endif
+
   ENUM_END_EVENT /* end marker */
 };
 
diff --git a/libbinlogevents/include/control_events.h b/libbinlogevents/include/control_events.h
index d9277e14952..b0f3e7ab8be 100644
--- a/libbinlogevents/include/control_events.h
+++ b/libbinlogevents/include/control_events.h
@@ -47,6 +47,9 @@
 #include "compression/base.h"  // binary_log::transaction::compression::type
 #include "template_utils.h"
 #include "uuid.h"
+#ifdef WESQL_CLUSTER
+#include "control_consensus_events.h"  // consensus events defination
+#endif
 
 namespace binary_log {
 /**
diff --git a/libbinlogevents/src/CMakeLists.txt b/libbinlogevents/src/CMakeLists.txt
index c21d493e40b..a7a4b1a2cfa 100644
--- a/libbinlogevents/src/CMakeLists.txt
+++ b/libbinlogevents/src/CMakeLists.txt
@@ -55,6 +55,12 @@ SET(REPLICATION_SOURCES
   uuid.cpp
   )
 
+IF(WITH_RAFT_REPLICATION)
+  LIST(APPEND REPLICATION_SOURCES
+    control_consensus_events.cc
+  )
+ENDIF()
+
 MY_CHECK_CXX_COMPILER_WARNING("-Wmissing-profile" HAS_MISSING_PROFILE)
 IF(HAS_MISSING_PROFILE)
   ADD_COMPILE_FLAGS(
diff --git a/libbinlogevents/src/control_events.cpp b/libbinlogevents/src/control_events.cpp
index b3525d006f4..fe901b8d81b 100644
--- a/libbinlogevents/src/control_events.cpp
+++ b/libbinlogevents/src/control_events.cpp
@@ -92,7 +92,11 @@ Format_description_event::Format_description_event(uint8_t binlog_ver,
         This will be used to initialize the post_header_len,
         for binlog version 4.
       */
+#ifdef WESQL_CLUSTER
+      static uint8_t server_event_header_length[LOG_EVENT_TYPES + 1] = {
+#else
       static uint8_t server_event_header_length[] = {
+#endif
           0, QUERY_HEADER_LEN, STOP_HEADER_LEN, ROTATE_HEADER_LEN,
           INTVAR_HEADER_LEN, 0,
           /*
diff --git a/libbinlogevents/src/trx_boundary_parser.cpp b/libbinlogevents/src/trx_boundary_parser.cpp
index b4e432ce47b..bd583174d36 100644
--- a/libbinlogevents/src/trx_boundary_parser.cpp
+++ b/libbinlogevents/src/trx_boundary_parser.cpp
@@ -247,6 +247,9 @@ Transaction_boundary_parser::get_event_boundary_type(
     case binary_log::HEARTBEAT_LOG_EVENT:
     case binary_log::HEARTBEAT_LOG_EVENT_V2:
     case binary_log::PREVIOUS_GTIDS_LOG_EVENT:
+#ifdef WESQL_CLUSTER
+    case binary_log::PREVIOUS_CONSENSUS_INDEX_LOG_EVENT:
+#endif
     case binary_log::STOP_EVENT:
     case binary_log::SLAVE_EVENT:
     case binary_log::DELETE_FILE_EVENT:
diff --git a/mysql-test/CMakeLists.txt b/mysql-test/CMakeLists.txt
index 67154713258..615336f2cd9 100644
--- a/mysql-test/CMakeLists.txt
+++ b/mysql-test/CMakeLists.txt
@@ -39,7 +39,44 @@ IF(INSTALL_MYSQLTESTDIR)
     PATTERN "mtr.out*" EXCLUDE
     PATTERN "*.cmake" EXCLUDE
     PATTERN "*.in" EXCLUDE
+    PATTERN "autotest_*" EXCLUDE
+    PATTERN "raft_replication" EXCLUDE
+    PATTERN "wesql" EXCLUDE
     )
+
+  IF (WITH_SMARTENGINE)
+    INSTALL(
+      DIRECTORY suite/
+      DESTINATION ${INSTALL_MYSQLTESTDIR}/suite
+      USE_SOURCE_PERMISSIONS
+      COMPONENT Test
+      PATTERN "suite/smartengine*"
+      )
+
+    FILE(GLOB autotestfiles "autotest_*.sh")
+    INSTALL(
+      FILES ${autotestfiles}
+      DESTINATION ${INSTALL_MYSQLTESTDIR}/
+      COMPONENT Test
+      )
+  ENDIF()
+  IF (WITH_WESQL)
+    INSTALL(
+      DIRECTORY suite/wesql
+      DESTINATION ${INSTALL_MYSQLTESTDIR}/suite/
+      USE_SOURCE_PERMISSIONS
+      COMPONENT Test
+      )
+    IF (WITH_RAFT_REPLICATION)
+      INSTALL(
+        DIRECTORY suite/raft_replication
+        DESTINATION ${INSTALL_MYSQLTESTDIR}/suite/
+        USE_SOURCE_PERMISSIONS
+        COMPONENT Test
+        )
+    ENDIF()
+  ENDIF()
+
   IF(NOT INSTALL_LAYOUT MATCHES "RPM" AND
       NOT INSTALL_LAYOUT MATCHES "DEB")
     INSTALL(FILES ${CMAKE_SOURCE_DIR}/LICENSE
@@ -47,7 +84,7 @@ IF(INSTALL_MYSQLTESTDIR)
       COMPONENT TestReadme
       RENAME LICENSE-test
       )
-    INSTALL(FILES ${CMAKE_SOURCE_DIR}/README
+    INSTALL(FILES ${CMAKE_SOURCE_DIR}/README.md
       DESTINATION ${INSTALL_DOCREADMEDIR}
       COMPONENT TestReadme
       RENAME README-test
diff --git a/mysql-test/extra/rpl_tests/create_recursive_construct.inc b/mysql-test/extra/rpl_tests/create_recursive_construct.inc
index e33fe7c6c3b..9afded4de3b 100644
--- a/mysql-test/extra/rpl_tests/create_recursive_construct.inc
+++ b/mysql-test/extra/rpl_tests/create_recursive_construct.inc
@@ -346,7 +346,14 @@ if ($CRC_RET_stmt_sidef) {
   --source include/assert.inc
 
   --let $assert_text= Only two events should exist in the binary log
-  --let $assert_cond= "[SHOW BINLOG EVENTS, Event_type, 3]" = "No such row"
+  if (!$USE_CONSENSUS_CLUSTER)
+  {
+    --let $assert_cond= "[SHOW BINLOG EVENTS, Event_type, 3]" = "No such row"
+  }
+  if ($USE_CONSENSUS_CLUSTER)
+  {
+    --let $assert_cond= "[SHOW BINLOG EVENTS, Event_type, 4]" = "No such row"
+  }
   --source include/assert.inc
   SET SQL_LOG_BIN = 1;
 
@@ -371,6 +378,17 @@ if ($CRC_RET_stmt_sidef) {
   {
     --let $tbl_map_event_pos = 6
   }
+  if ($USE_CONSENSUS_CLUSTER)
+  {
+    #  1. Format_description_log_event
+    #  2. Previous_consensus_index_log_event
+    #  3. Previous_gtids_log_event
+    #  4. Consensus_log_event
+    #  5. Gtid_log_event
+    #  6. Query_event('BEGIN')
+    #  7. Table_map_log_event for the unsafe statement.
+    --let $tbl_map_event_pos =`SELECT $tbl_map_event_pos + 2`
+  }
   --let $assert_text= Event should be a Table_map_log_event
   --let $assert_cond= "[SHOW BINLOG EVENTS, Event_type, $tbl_map_event_pos]" = "Table_map"
   --source include/assert.inc
diff --git a/mysql-test/include/assert_binlog_events.inc b/mysql-test/include/assert_binlog_events.inc
index 5cbb100c634..5e478d8b76d 100644
--- a/mysql-test/include/assert_binlog_events.inc
+++ b/mysql-test/include/assert_binlog_events.inc
@@ -269,14 +269,14 @@ while ($_abe_verdict != 'ok')
       if (
         # include header events
         ($include_header_events and
-         ($1 eq 'Format_desc' || $1 eq 'Rotate' || $1 eq 'Previous_gtids')) or
+         ($1 eq 'Format_desc' || $1 eq 'Rotate' || $1 eq 'Previous_gtids' || $1 eq 'Consensus_empty' || $1 eq 'Consensus_log')) or
 
         # include trx payload events
         ($include_trx_payload_events and ($1 eq 'Transaction_payload')) or
 
         # include all other events
         ($1 ne 'Format_desc' && $1 ne 'Rotate' &&
-         $1 ne 'Previous_gtids' && $1 ne 'Transaction_payload')
+         $1 ne 'Previous_gtids' && $1 ne 'Transaction_payload' && $1 ne 'Consensus_empty' && $1 ne 'Consensus_log')
       )
       {
         chomp;
diff --git a/mysql-test/include/default_mysqld.cnf b/mysql-test/include/default_mysqld.cnf
index 1cc96ca8723..bff4b458cd0 100644
--- a/mysql-test/include/default_mysqld.cnf
+++ b/mysql-test/include/default_mysqld.cnf
@@ -68,3 +68,6 @@ loose-performance-schema-consumer-thread-instrumentation=ON
 # log file. The note messages will contain important information and
 # will be useful while debugging an issue as well.
 log-error-verbosity=3
+
+[mysqld.1]
+report-port=                @mysqld.1.port
diff --git a/mysql-test/include/initialize_datadir.inc b/mysql-test/include/initialize_datadir.inc
index 74ff56049d4..d6778c81898 100644
--- a/mysql-test/include/initialize_datadir.inc
+++ b/mysql-test/include/initialize_datadir.inc
@@ -2,6 +2,16 @@ let $bootstrap_sql_file = $MYSQLTEST_VARDIR/tmp/bootstrap.sql;
 write_file $bootstrap_sql_file;
 CREATE DATABASE test;
 EOF
-let $MYSQLD_ARGS = --pid-file=$MYSQLD_DATADIR/mysqld-in-test.pid --secure_file_priv=$MYSQLTEST_VARDIR --socket=$MYSQL_TMP_DIR/tmp.sock --skip-log-bin --skip-networking --skip-ssl --loose-skip-mysqlx --console --log-error-verbosity=3 --datadir=$MYSQLD_DATADIR $MYSQLD_EXTRA_ARGS > $MYSQLD_ERROR_LOG 2>&1 ;
---exec $MYSQLD --no-defaults $MYSQLD_ARGS --initialize-insecure --init-file=$bootstrap_sql_file
+if ($USE_CONSENSUS_CLUSTER)
+{
+  let $MYSQLD_ARGS = --pid-file=$MYSQLD_DATADIR/mysqld-in-test.pid --secure_file_priv=$MYSQLTEST_VARDIR --socket=$MYSQLD_DATADIR/test.sock --skip-networking --skip-ssl --loose-skip-mysqlx --console --log-error-verbosity=3 --datadir=$MYSQLD_DATADIR $MYSQLD_EXTRA_ARGS > $MYSQLD_ERROR_LOG 2>&1 ;
+  --exec $MYSQLD --no-defaults $MYSQLD_ARGS --initialize-insecure --init-file=$bootstrap_sql_file --raft-replication-cluster-info=$CLUSTER_INFO --raft-replication-cluster-id=1 --raft-replication-start-index=1
+}
+
+if (!$USE_CONSENSUS_CLUSTER)
+{
+  let $MYSQLD_ARGS = --pid-file=$MYSQLD_DATADIR/mysqld-in-test.pid --secure_file_priv=$MYSQLTEST_VARDIR --socket=$MYSQLD_DATADIR/test.sock --skip-log-bin --skip-networking --skip-ssl --loose-skip-mysqlx --console --log-error-verbosity=3 --datadir=$MYSQLD_DATADIR $MYSQLD_EXTRA_ARGS > $MYSQLD_ERROR_LOG 2>&1 ;
+  --exec $MYSQLD --no-defaults $MYSQLD_ARGS --initialize-insecure --init-file=$bootstrap_sql_file
+}
+
 --remove_file $bootstrap_sql_file
diff --git a/mysql-test/include/log_multiple_files_test_begin.inc b/mysql-test/include/log_multiple_files_test_begin.inc
index 3b8ab743d01..d8dc99ccc81 100644
--- a/mysql-test/include/log_multiple_files_test_begin.inc
+++ b/mysql-test/include/log_multiple_files_test_begin.inc
@@ -11,6 +11,10 @@ let $INNODB_PAGE_SIZE = `select @@innodb_page_size`;
 let MYSQLD_EXTRA_ARGS = --innodb-redo-log-capacity=8388608 --innodb_page_size=$INNODB_PAGE_SIZE;
 
 --echo # Initialize new data directory...
+if ($USE_CONSENSUS_CLUSTER)
+{
+  --let $CLUSTER_INFO = '127.0.0.1:27738@1'
+}
 --source include/initialize_datadir.inc
 
 let $restart_parameters = restart: --datadir=$MYSQLD_DATADIR --log-error=$MYSQLD_ERROR_LOG $MYSQLD_EXTRA_ARGS;
diff --git a/mysql-test/include/mysqlbinlog.inc b/mysql-test/include/mysqlbinlog.inc
index 7bc2cc19ce2..e0e6ddd8275 100644
--- a/mysql-test/include/mysqlbinlog.inc
+++ b/mysql-test/include/mysqlbinlog.inc
@@ -113,6 +113,15 @@ if (!$mysqlbinlog_skip_replace)
     /SET @@session.immediate_server_version=[0-9]*/SET @@session.immediate_server_version= IMMEDIATE_SERVER_VERSION/
     /SET @@SESSION.GTID_NEXT= '.*'/SET @@SESSION.GTID_NEXT= '#'/
     /CRC32 0x[0-9a-f]{8}/CRC32 #/
+    /Previous Consensus index=[0-9]*/Previous Consensus index=#/
+    /Consensus flag=[0-9]*/Consensus flag=#/
+    /term=[0-9]*/term=#/
+    /index=[0-9]*/index=#/
+    /PREV_CONSENSUS_INDEX: [0-9]*/PREV_CONSENSUS_INDEX: #/
+    /CONSENSUS FLAG: [0-9]*/CONSENSUS FLAG: #/
+    /TERM: [0-9]*/TERM: #/
+    /INDEX: [0-9]*/INDEX: #/
+    /LENGTH: [0-9]*/LENGTH: #/
     /# [a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}:/# #:/;
 }
 
diff --git a/mysql-test/include/show_events.inc b/mysql-test/include/show_events.inc
index 8d2399a9bae..4d31622c76d 100644
--- a/mysql-test/include/show_events.inc
+++ b/mysql-test/include/show_events.inc
@@ -108,6 +108,7 @@ let $script=
   s{((?:master|slave|slave-relay)-bin\.[0-9]{6};pos=)[0-9]+DOLLAR}{DOLLAR1POS};
   s{(binlog\.[0-9]{6};pos=)[0-9]+DOLLAR}{DOLLAR1POS};
   s{SONAME ".*"}{SONAME "LIB"};
+  s{##PREV_CONSENSUS_INDEX: [0-9]+}{##PREV_CONSENSUS_INDEX: #};
   s{DOLLARmysqltest_vardir}{MYSQLTEST_VARDIR}g;
 ||
 --let $pre_script= my DOLLARmysqltest_vardir = DOLLARENV{'MYSQLTEST_VARDIR'};
@@ -170,6 +171,8 @@ if (!$keep_ddl_xid)
 {
   --let $script= $script s{ /\* XID # \*/}{};
 }
+--let $script= $script DOLLAR_ = '' if (m{\t(?:Previous_consensus_index)\t});
+--let $script= $script DOLLAR_ = '' if (m{\t(?:Consensus_log)\t});
 --delimiter ;
 
 #--let $select_columns= 1 3 6
diff --git a/mysql-test/include/wait_condition.inc b/mysql-test/include/wait_condition.inc
index 4d505e9fdd4..e5ed7959926 100644
--- a/mysql-test/include/wait_condition.inc
+++ b/mysql-test/include/wait_condition.inc
@@ -26,7 +26,7 @@
 #    events_bugs.test, events_time_zone.test
 #
 
-let $wait_counter= 300;
+let $wait_counter = 300;
 if ($wait_timeout)
 {
   let $wait_counter= `SELECT $wait_timeout * 10`;
diff --git a/mysql-test/include/wait_time_until_connected_again.inc b/mysql-test/include/wait_time_until_connected_again.inc
index f17f72227f7..f7ffe1e1f76 100644
--- a/mysql-test/include/wait_time_until_connected_again.inc
+++ b/mysql-test/include/wait_time_until_connected_again.inc
@@ -23,5 +23,20 @@ while ($mysql_errno)
   }
   --sleep 0.5
 }
+
+if ($USE_CONSENSUS_CLUSTER)
+{
+  # wait leader election
+  --sleep 1
+  let $wait_timeout= 60;
+  let $wait_condition= select count(*)=1 from information_schema.wesql_cluster_local where role='leader';
+  --source include/wait_condition.inc
+
+  # wait leader enable read/write
+  let $wait_timeout= 60;
+  let $wait_condition= select SERVER_READY_FOR_RW='Yes' from information_schema.wesql_cluster_local;
+  --source include/wait_condition.inc
+}
+
 --enable_query_log
 --enable_result_log
diff --git a/mysql-test/include/wait_until_connected_again.inc b/mysql-test/include/wait_until_connected_again.inc
index 0e3441bec2e..c0dd14cb908 100644
--- a/mysql-test/include/wait_until_connected_again.inc
+++ b/mysql-test/include/wait_until_connected_again.inc
@@ -85,6 +85,41 @@ if ($SECONDARY_ENGINE_TEST) {
   }
 }
 
+if ($USE_CONSENSUS_CLUSTER)
+{
+  --let $CONSENSUS_IS_ENABLE_IN_THIS_MYSQLD = `select count(*)!=0 from information_schema.wesql_cluster_local`
+  if($CONSENSUS_IS_ENABLE_IN_THIS_MYSQLD)
+  {
+    # wait leader election
+    if (!$wait_follower)
+    {
+      # wait leader from consensus
+      --let $counter = 6000
+      --let $check_counter = 10
+      while ($counter > 0) {
+        let $success= `select count(*)=1 from information_schema.wesql_cluster_local where role='leader'`;
+        if ($success) {
+          let $counter= 0;
+        }
+        if (!$success) {
+          --dec $check_counter
+          if ($check_counter == 0) {
+            call dbms_consensus.force_promote();
+            let $check_counter= 10;
+          }
+          --sleep 0.1
+          --dec $counter
+        }
+      }
+
+      # wait leader enable read/write
+      let $wait_timeout= 60;
+      let $wait_condition= select SERVER_READY_FOR_RW='Yes' from information_schema.wesql_cluster_local;
+      --source include/wait_condition.inc
+    }
+  }
+}
+
 # Reset $wait_counter so that its value won't be used on subsequent
 # calls, and default will be used instead.
 if (!$explicit_default_wait_counter)
diff --git a/mysql-test/lib/mtr_cases.pm b/mysql-test/lib/mtr_cases.pm
index b9c7bd70e23..835824a02fd 100644
--- a/mysql-test/lib/mtr_cases.pm
+++ b/mysql-test/lib/mtr_cases.pm
@@ -328,8 +328,14 @@ sub create_disabled_test_list($$) {
   my @disabled_collection = $opt_skip_test_list if $opt_skip_test_list;
 
   # Add 'disabled.def' files.
-  unshift(@disabled_collection,
-          "$::glob_mysql_test_dir/collections/disabled.def");
+  if ($::opt_consensus_cluster) {
+    unshift(@disabled_collection,
+      "$::glob_mysql_test_dir/collections/disabled-wesql.def");
+  } else {
+    unshift(@disabled_collection,
+      "$::glob_mysql_test_dir/collections/disabled.def");
+  }
+
 
   # Add internal 'disabled.def' file only if it exists
   my $internal_disabled_def_file =
@@ -512,7 +518,7 @@ sub collect_test_cases ($$$$) {
       foreach my $test (@$cases) {
         last unless $opt_reorder;
         # 'test->{name}' value is always in suite.name format
-        if ($test->{name} =~ /^$sname.*\.$tname$/) {
+        if ($test->{name} =~ /^$sname.*\.$tname$/ or $test->{name} =~ /^$sname.*\.$tname-wesql$/) {
           $found = 1;
           last;
         }
@@ -862,6 +868,17 @@ sub collect_one_suite($$$$) {
         next if (!-f $full_name);
       }
 
+      my $wesql_case = mtr_match_suffix($tname, "-wesql");
+      if (!$::opt_consensus_cluster) {
+        # skip *-wesql.test
+        next if (defined $wesql_case);
+      } elsif (not defined $wesql_case) {
+        my $wesql_full_name = "$testdir/$tname-wesql.$extension";
+        # replace if $tname-wesql.test exists
+        mtr_verbose("Replace tname $tname with $tname-wesql");
+        ($tname = $tname . "-wesql") if (-f $wesql_full_name);
+      }
+
       push(@cases,
            collect_one_test_case($suitedir, $testdir,
                                  $resdir,   $suite,
@@ -879,6 +896,15 @@ sub collect_one_suite($$$$) {
       # Skip tests that does not match the --do-test= filter
       next if ($do_test_reg and not $tname =~ /$do_test_reg/o);
 
+      my $wesql_case = mtr_match_suffix($tname, "-wesql");
+      if (!$::opt_consensus_cluster) {
+        # skip wesql-*.test
+        next if (defined $wesql_case);
+      } elsif (not defined $wesql_case) {
+        # skip if wesql-$tname.test exists
+        next if (-f "$testdir/$tname-wesql.test");
+      }
+
       push(@cases,
            collect_one_test_case($suitedir, $testdir, $resdir,
                                  $suite,    $tname,   $elem,
@@ -1149,6 +1175,8 @@ sub collect_one_test_case {
   my $filename   = shift;
   my $disabled   = shift;
   my $suite_opts = shift;
+  my $wesql_tname = undef;
+  my $wesql_fname = undef;
 
   # Test file name should consist of only alpha-numeric characters, dash (-)
   # or underscore (_), but should not start with dash or underscore.
@@ -1173,18 +1201,28 @@ sub collect_one_test_case {
                             path      => "$testdir/$filename",
                             shortname => $tname,);
 
+  # After this, tname will remove -wesql suffix
+  $wesql_tname = mtr_match_suffix($tname, "-wesql");
+  if ($::opt_consensus_cluster && defined $wesql_tname) {
+    $wesql_fname = $tname;
+    $tname = $wesql_tname;
+  }
+
   my $result_file = "$resdir/$tname.result";
-  if (-f $result_file) {
+  my $wesql_result_file = "$resdir/$tname-wesql.result";
+  if ($::opt_consensus_cluster && -f $wesql_result_file) {
+    $tinfo->{result_file} = $wesql_result_file;
+  } elsif (-f $result_file) {
     $tinfo->{result_file} = $result_file;
   } else {
     # Result file doesn't exist
     if ($::opt_check_testcases and !$::opt_record) {
       # Set 'no_result_file' flag if check-testcases is enabled.
-      $tinfo->{'no_result_file'} = $result_file;
+      $tinfo->{'no_result_file'} = $::opt_consensus_cluster ? $wesql_result_file : $result_file;
     } else {
       # No .result file exist, remember the path where it should
       # be saved in case of --record.
-      $tinfo->{record_file} = $result_file;
+      $tinfo->{record_file} = $::opt_consensus_cluster ? $wesql_result_file : $result_file;
     }
   }
 
@@ -1214,6 +1252,9 @@ sub collect_one_test_case {
   # Check for group replication tests
   $tinfo->{'grp_rpl_test'} = 1 if ($suitename =~ 'group_replication');
 
+  # Check for group replication tests
+  $tinfo->{'consensus_replication_test'} = 1 if ($suitename =~ 'raft_replication');
+
   # Check for disabled tests
   if ($disabled->{"$suitename.$tname"}) {
     # Test was marked as disabled in disabled.def file
@@ -1269,7 +1310,11 @@ sub collect_one_test_case {
   mtr_error("$tname: slave-mi not supported anymore")
     if (-f "$testdir/$tname.slave-mi");
 
-  tags_from_test_file($tinfo, "$testdir/${tname}.test");
+  if (defined $wesql_fname) {
+    tags_from_test_file($tinfo, "$testdir/${wesql_fname}.test");
+  } else {
+    tags_from_test_file($tinfo, "$testdir/${tname}.test");
+  }
 
   # Check that test wth "ndb" in their suite name
   # have been tagged as 'ndb_test', this is normally fixed
@@ -1384,6 +1429,17 @@ sub collect_one_test_case {
       skip_test($tinfo, "No replication tests, --skip-rpl is enabled.");
       return $tinfo;
     }
+    if ($::opt_consensus_cluster && $::opt_consensus_replication) {
+      skip_test($tinfo, "No replication tests, --consensus_replication is enabled.");
+      return $tinfo;
+    }
+  }
+
+  if ($tinfo->{'consensus_replication_test'}) {
+    if (!$::opt_consensus_cluster || !$::opt_consensus_replication) {
+      skip_test($tinfo, "No consensus_replication tests, --consensus_replication is disabled.");
+      return $tinfo;
+    }
   }
 
   # Check for group replication tests
@@ -1428,11 +1484,20 @@ sub collect_one_test_case {
   }
 
   if (!$::start_only or @::opt_cases) {
-    # Add master opts, extra options only for master
-    process_opts_file($tinfo, "$testdir/$tname-master.opt", 'master_opt');
+    if (-f "$testdir/$tname-master-wesql.opt" || -f "$testdir/$tname-slave-wesql.opt") {
+      if (-f "$testdir/$tname-master-wesql.opt") {
+          process_opts_file($tinfo, "$testdir/$tname-master-wesql.opt", 'master_opt');
+      }
 
-    # Add slave opts, list of extra option only for slave
-    process_opts_file($tinfo, "$testdir/$tname-slave.opt", 'slave_opt');
+      if (-f "$testdir/$tname-slave-wesql.opt") {
+          process_opts_file($tinfo, "$testdir/$tname-slave-wesql.opt", 'slave_opt');
+      }
+    } else {
+        # Add master opts, extra options only for master
+        process_opts_file($tinfo, "$testdir/$tname-master.opt", 'master_opt');
+        # Add slave opts, list of extra option only for slave
+        process_opts_file($tinfo, "$testdir/$tname-slave.opt", 'slave_opt');
+    }
   }
 
   if (!$::start_only) {
@@ -1514,6 +1579,10 @@ my @tags = (
   [ "have_group_replication_plugin_base.inc", "grp_rpl_test", 1 ],
   [ "have_group_replication_plugin.inc",      "grp_rpl_test", 1 ],
 
+  # Tests with below .inc file are considered to be consensus_replication_test
+  [ "include/consensus_replication.inc", "consensus_replication_test", 1 ],
+  [ "include/not_log_bin.inc", "not_log_bin", 1 ],
+
   # Tests with below .inc file needs either big-test or only-big-test
   # option along with valgrind option.
   [ "include/no_valgrind_without_big.inc", "no_valgrind_without_big", 1 ]);
diff --git a/mysql-test/lib/mtr_match.pm b/mysql-test/lib/mtr_match.pm
index d03842d66ad..d47fa4de7df 100644
--- a/mysql-test/lib/mtr_match.pm
+++ b/mysql-test/lib/mtr_match.pm
@@ -30,7 +30,7 @@ package mtr_match;
 use strict;
 
 use base qw(Exporter);
-our @EXPORT = qw(mtr_match_prefix mtr_match_extension mtr_match_substring);
+our @EXPORT = qw(mtr_match_prefix mtr_match_suffix mtr_match_extension mtr_match_substring);
 
 # Match a prefix and return what is after the prefix
 sub mtr_match_prefix ($$) {
@@ -45,6 +45,19 @@ sub mtr_match_prefix ($$) {
   }
 }
 
+# Match a suffix and return what is before the suffix
+sub mtr_match_suffix ($$) {
+  my $string = shift;
+  my $suffix = shift;
+
+  if ($string =~ /^(.*)\Q$suffix\E$/) {
+    return $1;
+  } else {
+    return undef;                        # NULL
+  }
+}
+
+
 # Match extension and return the name without extension
 sub mtr_match_extension ($$) {
   my $file = shift;
diff --git a/mysql-test/mysql-test-run.pl b/mysql-test/mysql-test-run.pl
index 26e6c92cf64..97cbe5923f6 100755
--- a/mysql-test/mysql-test-run.pl
+++ b/mysql-test/mysql-test-run.pl
@@ -142,7 +142,7 @@ my $opt_include_ndbcluster = 0;
 my $opt_lock_order         = env_or_val(MTR_LOCK_ORDER => 0);
 my $opt_max_save_core      = env_or_val(MTR_MAX_SAVE_CORE => 5);
 my $opt_max_save_datadir   = env_or_val(MTR_MAX_SAVE_DATADIR => 20);
-my $opt_max_test_fail      = env_or_val(MTR_MAX_TEST_FAIL => 10);
+my $opt_max_test_fail      = env_or_val(MTR_MAX_TEST_FAIL => 1000);
 my $opt_mysqlx_baseport    = $ENV{'MYSQLXPLUGIN_PORT'} || "auto";
 my $opt_port_base          = $ENV{'MTR_PORT_BASE'} || "auto";
 my $opt_port_exclude       = $ENV{'MTR_PORT_EXCLUDE'} || "none";
@@ -225,6 +225,11 @@ our $opt_summary_report;
 our $opt_vardir;
 our $opt_xml_report;
 our $ports_per_thread   = 30;
+our $opt_objectstore_provider = "";
+our $opt_objectstore_region = "";
+our $opt_objectstore_bucket = "";
+our $opt_objectstore_endpoint = "";
+our $opt_repo_objstore_id = "";
 
 #
 # Suites run by default (i.e. when invoking ./mtr without parameters)
@@ -299,6 +304,10 @@ our $opt_user                      = "root";
 our $opt_valgrind                  = 0;
 our $opt_valgrind_secondary_engine = 0;
 our $opt_verbose                   = 0;
+our $opt_consensus_cluster         = 1;
+our $opt_consensus_replication     = 1;
+our $consensus_cluster_id_cnt      = 1;
+our $consensus_cluster_info_prefix;
 # Visual Studio produces executables in different sub-directories
 # based on the configuration used to build them. To make life easier,
 # an environment variable or command-line option may be specified to
@@ -446,6 +455,8 @@ sub main {
 
   command_line_setup();
 
+  clean_objectstore_test_dir("", "all");
+
   # Create build thread id directory
   create_unique_id_dir();
 
@@ -923,6 +934,8 @@ sub main {
 
   remove_vardir_subs() if $opt_clean_vardir;
 
+  clean_objectstore_test_dir("", "all");
+
   exit(0);
 }
 
@@ -1166,10 +1179,10 @@ sub run_test_server ($$$) {
           # Unknown message from worker
           mtr_error("Unknown response: '$line' from client");
         }
-	# Thread has received 'BYE', no need to look for more tests
-	if (exists $closed_sock{$sock}) {
-	  next;
-	}
+        # Thread has received 'BYE', no need to look for more tests
+        if (exists $closed_sock{$sock}) {
+          next;
+        }
         # Find next test to schedule
         # - Try to use same configuration as worker used last time
         # - Limit number of parallel ndb tests
@@ -1789,6 +1802,8 @@ sub command_line_setup {
     'user-args'             => \$opt_user_args,
     'user=s'                => \$opt_user,
     'verbose'               => \$opt_verbose,
+    'consensus-cluster=i'   => \$opt_consensus_cluster,
+    'consensus-replication=i' => \$opt_consensus_replication,
     'verbose-restart'       => \&report_option,
     'wait-all'              => \$opt_wait_all,
     'warnings!'             => \$opt_warnings,
@@ -1802,6 +1817,33 @@ sub command_line_setup {
 
   GetOptions(%options) or usage("Can't read options");
 
+  # eg: --table_on_objectstore=true --objectstore_provider=aws --objectstore_region=cn-northwest-1 --objectstore_bucket=ljc
+  foreach my $arg (@opt_extra_bootstrap_opt) {
+    if ($arg =~ /^--objectstore_provider=(.*)$/) {
+      $opt_objectstore_provider = $1;
+    }
+    if ($arg =~ /^--objectstore_region=(.*)$/) {
+      $opt_objectstore_region = $1;
+    }
+    if ($arg =~ /^--objectstore_bucket=(.*)$/) {
+      $opt_objectstore_bucket = $1;
+    }
+    if ($arg =~ /^--objectstore_endpoint=(.*)$/) {
+      $opt_objectstore_endpoint= $1;
+    }
+    if ($arg =~ /^--repo_objectstore_id=(.*)$/) {
+      $opt_repo_objstore_id = $1;
+    }
+  }
+
+  if ($opt_objectstore_provider) {
+    mtr_report("opt_objectstore_provider:$opt_objectstore_provider");
+    mtr_report("opt_objectstore_region:$opt_objectstore_region");
+    mtr_report("opt_objectstore_bucket:$opt_objectstore_bucket");
+    mtr_report("opt_objectstore_endpoint:$opt_objectstore_endpoint");
+    mtr_report("opt_repo_objstore_id:$opt_repo_objstore_id");
+  }
+
   usage("") if $opt_usage;
   list_options(\%options) if $opt_list_options;
 
@@ -1906,7 +1948,10 @@ sub command_line_setup {
     }
   }
 
-  # Find out type of logging that are being used
+  if ($opt_consensus_cluster) {
+    collect_option('skip-ndb', 1);
+  }
+
   foreach my $arg (@opt_extra_mysqld_opt) {
     if ($arg =~ /binlog[-_]format=(\S+)/) {
       # Save this for collect phase
@@ -2325,6 +2370,142 @@ sub command_line_setup {
   check_fips_support();
 }
 
+sub clean_aliyun_bucket_dir($)
+{
+  if (!$opt_objectstore_bucket) {
+    return;
+  }
+  my ($objectstore_test_dir) = @_;
+  my $objectstore_bucket = $opt_objectstore_bucket;
+
+  my $objectstore_cmd = "aliyun oss rm -f oss://$objectstore_test_dir  --recursive";
+
+  my $objectstore_cmd_output = `$objectstore_cmd`;
+  if ($? != 0) {
+    mtr_error("Failed to clean up object store bucket dir oss://$objectstore_test_dir");
+    mtr_error("Command: $objectstore_cmd");
+    mtr_error("Output: $objectstore_cmd_output");
+    return;
+  } else {
+    # make sure the bucket is empty
+    $objectstore_cmd = "aliyun oss ls oss://$objectstore_test_dir";
+    # wait for the bucket to be empty
+    my $timeout = 60;
+    while ($timeout > 0) {
+      $timeout = $timeout - 1;
+      sleep(1);
+      $objectstore_cmd_output = `$objectstore_cmd`;
+      # print "objectstore_cmd_output: $objectstore_cmd_output\n";
+      if ($objectstore_cmd_output =~ /Object Number is: 0/) {
+        last;
+      }
+      if ($? != 0) {
+        mtr_error("Failed to list object store bucket oss://$objectstore_test_dir");
+        mtr_error("Command: $objectstore_cmd");
+        mtr_error("Output: $objectstore_cmd_output");
+        return;
+      }
+    }
+    # print "objectstore_cmd_output: $objectstore_cmd_output\n";
+    if ($objectstore_cmd_output !~ /Object Number is: 0/) {
+      mtr_error("Failed to clean up object store bucket dir oss://$objectstore_test_dir");
+      mtr_error("Bucket is not empty");
+      return;
+    } else {
+      #print "Object store bucket oss://$objectstore_test_dir cleaned up\n";
+    }
+  }
+}
+
+sub clean_aws_bucket_dir($)
+{
+  if (!$opt_objectstore_bucket) {
+    return;
+  }
+  my $objectstore_bucket = $opt_objectstore_bucket;
+  my $objectstore_endpoint = $opt_objectstore_endpoint; 
+
+  my $objectstore_test_dir = shift;
+  my $objectstore_cmd = "aws s3 rm s3://$objectstore_test_dir  --recursive";
+  if ($opt_objectstore_endpoint) {
+    $objectstore_cmd = "aws --endpoint-url $objectstore_endpoint s3 rm s3://$objectstore_test_dir  --recursive"; 
+  }
+
+  my $objectstore_cmd_output = `$objectstore_cmd`;
+  if ($? != 0) {
+    mtr_error("Failed to clean up object store bucket dir $objectstore_test_dir");
+    mtr_error("Command: $objectstore_cmd");
+    mtr_error("Output: $objectstore_cmd_output");
+    return;
+  } else {
+    # make sure the bucket is empty
+    $objectstore_cmd = "aws s3 ls s3://$objectstore_test_dir";
+    if ($opt_objectstore_endpoint) {
+      $objectstore_cmd = "aws --endpoint-url $objectstore_endpoint s3 ls s3://$objectstore_test_dir";
+    }
+    
+    # wait for the bucket to be empty
+    my $timeout = 60;
+    while ($timeout > 0) {
+      $timeout = $timeout - 1;
+      sleep(1);
+      $objectstore_cmd_output = `$objectstore_cmd`;
+      if ($objectstore_cmd_output eq "") {
+        last;
+      }
+      # 1 means no such directory
+      if ($? != 0 && $? != 1) {
+        mtr_error("Failed to list object store bucket $objectstore_test_dir");
+        mtr_error("Command: $objectstore_cmd");
+        mtr_error("Output: $objectstore_cmd_output");
+        return;
+      }
+    }
+    if ($objectstore_cmd_output ne "") {
+      mtr_error("Failed to clean up object store bucket dir $objectstore_test_dir");
+      mtr_error("Bucket is not empty");
+      return;
+    } else {
+      #print "Object store bucket $objectstore_test_dir cleaned up\n";
+    }
+  }
+}
+
+sub clean_objectstore_test_dir($$)
+{
+  if (!$opt_objectstore_provider || !$opt_objectstore_bucket) {
+    return;
+  }
+  my $objectstore_test_dir = shift;
+  my $test_name = shift;
+  if (!$test_name || $test_name eq "shutdown_report") {
+    return;
+  }
+  my $objectstore_provider = $opt_objectstore_provider;
+  my $objectstore_region = $opt_objectstore_region;
+  my $objectstore_bucket = $opt_objectstore_bucket;
+  my $objectstore_endpoint = $opt_objectstore_endpoint;
+  my $objectstore_repo_id = $opt_repo_objstore_id;
+
+  if ($test_name eq "all") {
+    $objectstore_test_dir = "$objectstore_bucket";
+  } else {
+    $objectstore_test_dir = "$objectstore_bucket/$objectstore_test_dir ";
+  }
+  if ($objectstore_provider eq 'aws') {
+    clean_aws_bucket_dir($objectstore_test_dir );
+  } elsif ($objectstore_provider eq 'minio') {
+    clean_aws_bucket_dir($objectstore_test_dir);
+  } elsif ($objectstore_provider eq 'aliyun') {
+    clean_aliyun_bucket_dir($objectstore_test_dir);
+  } elsif ($objectstore_provider eq 'local') {
+    return;
+  } else {
+    mtr_error("Unsupported object store provider $objectstore_provider");
+    return;
+  }
+}
+
 sub check_fips_support() {
   # Run $exe_mysqltest to see if FIPS mode is supported.
   my $args;
@@ -3128,6 +3309,7 @@ sub environment_setup {
   $ENV{'MYSQL_TMP_DIR'}       = $opt_tmpdir;
   $ENV{'MYSQLTEST_VARDIR'}    = $opt_vardir;
   $ENV{'USE_RUNNING_SERVER'}  = using_extern();
+  $ENV{'USE_CONSENSUS_CLUSTER'}   = $opt_consensus_cluster;
 
   if (IS_WINDOWS) {
     $ENV{'SECURE_LOAD_PATH'}      = $glob_mysql_test_dir . "\\std_data";
@@ -4179,7 +4361,7 @@ sub default_mysqld {
 # thus created will later be used for a quick "boot" whenever the
 # server is restarted.
 sub mysql_install_db {
-  my ($mysqld, $datadir, $bootstrap_opts) = @_;
+  my ($mysqld, $datadir, $bootstrap_opts, $tinfo) = @_;
 
   my $install_basedir = $mysqld->value('#mtr_basedir');
   my $install_chsdir  = $mysqld->value('character-sets-dir');
@@ -4216,6 +4398,20 @@ sub mysql_install_db {
   mtr_add_arg($args,
               "--loose-caching_sha2_password_auto_generate_rsa_keys=OFF");
 
+  if ($tinfo && $tinfo->{name} && !$opt_repo_objstore_id && 
+  $opt_objectstore_provider ne '' && $opt_objectstore_provider ne 'local') {
+    my $test_name = $tinfo->{name};
+    my $objstore_test_dir = $test_name;
+    $objstore_test_dir =~ s/\./-/g;
+    if (!$tinfo->{'objectstore_test_dir'}) {
+      $tinfo->{'objectstore_test_dir'} = $objstore_test_dir;
+    }
+    mtr_add_arg($args, "--repo_objectstore_id=$objstore_test_dir");
+    @opt_extra_bootstrap_opt = grep { $_ !~ /--repo_objectstore_id=/ } @opt_extra_bootstrap_opt;
+    push(@opt_extra_bootstrap_opt, "--repo_objectstore_id=$objstore_test_dir");
+    #print "opt_extra_bootstrap_opt: @opt_extra_bootstrap_opt\n";
+  }
+
   # Arguments to bootstrap process.
   my $init_file;
   foreach my $extra_opt (@opt_extra_bootstrap_opt) {
@@ -4227,6 +4423,7 @@ sub mysql_install_db {
     mtr_add_arg($args, $extra_opt);
   }
 
+
   # Add bootstrap arguments from the opt file, if any
   push(@$args, @$bootstrap_opts) if $bootstrap_opts;
 
@@ -4251,6 +4448,9 @@ sub mysql_install_db {
 
   # Create the bootstrap.sql file
   my $bootstrap_sql_file = "$opt_vardir/tmp/bootstrap.sql";
+  if (-f $bootstrap_sql_file) {
+    rmtree($bootstrap_sql_file);
+  }
 
   #Add the init-file to --initialize-insecure process
   mtr_add_arg($args, "--init-file=$bootstrap_sql_file");
@@ -4274,14 +4474,22 @@ sub mysql_install_db {
     # Add the official mysql system tables in a production system.
     mtr_tofile($bootstrap_sql_file, "use mysql;\n");
 
+    if ($opt_consensus_cluster) {
+      mtr_tofile($bootstrap_sql_file, "SET SQL_MODE='';\n");
+    }
+
+    # Create mtr database
+    mtr_tofile($bootstrap_sql_file, "CREATE DATABASE mtr;\n");
+
+
     # Add test data for timezone - this is just a subset, on a real
     # system these tables will be populated either by mysql_tzinfo_to_sql
     # or by downloading the timezone table package from our website
     mtr_appendfile_to_file("include/mtr_test_data_timezone.sql",
-                           $bootstrap_sql_file);
+      $bootstrap_sql_file);
   } else {
     mtr_error(
-       "Error: The test_data_timezone.sql not found" . "in working directory.");
+      "Error: The test_data_timezone.sql not found" . "in working directory.");
   }
 
   if ($opt_skip_sys_schema) {
@@ -4292,9 +4500,9 @@ sub mysql_install_db {
   mtr_tofile(
     $bootstrap_sql_file,
     "UPDATE mysql.tables_priv SET
-               timestamp = CURRENT_TIMESTAMP,
-               Grantor= 'root\@localhost'
-               WHERE USER= 'mysql.session';\n");
+    timestamp = CURRENT_TIMESTAMP,
+    Grantor= 'root\@localhost'
+    WHERE USER= 'mysql.session';\n");
 
   # Make sure no anonymous accounts exists as a safety precaution
   mtr_tofile($bootstrap_sql_file, "DELETE FROM mysql.user where user= '';\n");
@@ -4302,33 +4510,30 @@ sub mysql_install_db {
   # Create test database
   if (defined $opt_charset_for_testdb) {
     mtr_tofile($bootstrap_sql_file,
-               "CREATE DATABASE test CHARACTER SET $opt_charset_for_testdb;\n");
+      "CREATE DATABASE test CHARACTER SET $opt_charset_for_testdb;\n");
   } else {
     mtr_tofile($bootstrap_sql_file, "CREATE DATABASE test;\n");
   }
 
-  # Create mtr database
-  mtr_tofile($bootstrap_sql_file, "CREATE DATABASE mtr;\n");
+  # Add help tables and data for warning detection and suppression
+  mtr_tofile($bootstrap_sql_file, mtr_grab_file("include/mtr_warnings.sql"));
+
+  # Add procedures for checking server is restored after testcase
+  mtr_tofile($bootstrap_sql_file, mtr_grab_file("include/mtr_check.sql"));
 
   mtr_tofile(
     $bootstrap_sql_file,
     "insert into mysql.db values('%','test','','Y','Y','Y','Y','Y',
-            'Y','N','Y','Y','Y','Y','Y','Y','Y','Y','N','N','Y','Y'); \n");
+    'Y','N','Y','Y','Y','Y','Y','Y','Y','Y','N','N','Y','Y'); \n");
 
   # Inserting in acl table generates a timestamp and conventional way
   # generates a null timestamp.
   mtr_tofile($bootstrap_sql_file,
-             "DELETE FROM mysql.proxies_priv where user='root';\n");
+    "DELETE FROM mysql.proxies_priv where user='root';\n");
   mtr_tofile(
     $bootstrap_sql_file,
     "INSERT INTO mysql.proxies_priv VALUES ('localhost', 'root',
-              '', '', TRUE, '', now());\n");
-
-  # Add help tables and data for warning detection and suppression
-  mtr_tofile($bootstrap_sql_file, mtr_grab_file("include/mtr_warnings.sql"));
-
-  # Add procedures for checking server is restored after testcase
-  mtr_tofile($bootstrap_sql_file, mtr_grab_file("include/mtr_check.sql"));
+    '', '', TRUE, '', now());\n");
 
   if (defined $init_file) {
     # Append the contents of the init-file to the end of bootstrap.sql
@@ -4358,11 +4563,35 @@ sub mysql_install_db {
     exit(0);
   }
 
+  if ( $opt_consensus_cluster && $tinfo && ($opt_consensus_replication || $mysqld->name() eq "mysqld.1") ) {
+    #args
+    mtr_add_arg($args, "--raft-replication-cluster-id=1");
+    mtr_add_arg($args, "--raft-replication-start-index=1");
+    mtr_add_arg($args, "--raft-replication-cluster-info=%s@%d", $consensus_cluster_info_prefix, $consensus_cluster_id_cnt);
+    mtr_add_arg($args, "--raft-replication-election-timeout=1000");
+    mtr_add_arg($args, "--raft-replication-io-thread_cnt=8");
+    mtr_add_arg($args, "--raft-replication-worker-thread_cnt=8");
+    mtr_add_arg($args, "--raft-replication-log-level=LOG_ERROR");
+    mtr_add_arg($args, "--skip-slave-start=OFF");
+    if ($opt_consensus_replication) {
+      $consensus_cluster_id_cnt++;
+    }
+  } else {
+    mtr_add_arg($args, "--loose-raft-replication=0");
+  }
+
   # Log bootstrap command
   my $path_bootstrap_log = "$opt_vardir/log/bootstrap.log";
   mtr_tofile($path_bootstrap_log,
              "$exe_mysqld_bootstrap " . join(" ", @$args) . "\n");
 
+  if ($opt_consensus_cluster) {
+    if (-d $install_datadir) {
+      rmtree($install_datadir);
+    }
+    mkpath("$install_datadir");
+  }
+
   my $res = My::SafeProcess->run(name    => "initialize",
                                  path    => $exe_mysqld_bootstrap,
                                  args    => \$args,
@@ -4383,6 +4612,10 @@ sub mysql_install_db {
   if (-f "$datadir/auto.cnf") {
     unlink "$datadir/auto.cnf";
   }
+
+  if (-f $bootstrap_sql_file) {
+    rmtree($bootstrap_sql_file);
+  }
 }
 
 sub run_testcase_check_skip_test($) {
@@ -4417,7 +4650,6 @@ sub run_query {
                                  args   => \$args,
                                  output => $outfile,
                                  error  => $errfile);
-
   return $res;
 }
 
@@ -4455,9 +4687,16 @@ sub check_testcase($$) {
   my %started;
   foreach my $mysqld (mysqlds()) {
     # Skip if server has been restarted with additional options
-    if (defined $mysqld->{'proc'} && !exists $mysqld->{'restart_opts'}) {
-      my $proc = start_check_testcase($tinfo, $mode, $mysqld);
-      $started{ $proc->pid() } = $proc;
+    if ($opt_consensus_cluster) {
+      if (defined $mysqld->{'proc'} && ! exists $mysqld->{'restart_opts'} && $mysqld->name() eq "mysqld.1") {
+        my $proc= start_check_testcase($tinfo, $mode, $mysqld);
+        $started{$proc->pid()}= $proc;
+      }
+    } else {
+      if (defined $mysqld->{'proc'} && !exists $mysqld->{'restart_opts'}) {
+	my $proc = start_check_testcase($tinfo, $mode, $mysqld);
+	$started{ $proc->pid() } = $proc;
+      }
     }
   }
 
@@ -4865,6 +5104,13 @@ sub find_bootstrap_opts {
     unshift(@$opt_file_options, @$bootstrap_opts);
   }
 
+  # For wesql serverless test
+  # Expand environment variables
+  foreach my $opt (@$bootstrap_opts) {
+    $opt =~ s/\$\{(\??\w+)\}/envsubst($1)/ge;
+    $opt =~ s/\$(\??\w+)/envsubst($1)/ge;
+  }
+
   # Command line mysqld options should not have precedence over the opt
   # file options.
   unshift(@$opt_file_options, @opt_extra_mysqld_opt);
@@ -4889,6 +5135,14 @@ sub run_testcase ($) {
   mtr_verbose("Running test:", $tinfo->{name});
   resfile_report_test($tinfo) if $opt_resfile;
 
+  # Skip tests if --skip-bin-log is specified
+  if ($tinfo->{not_log_bin} and $opt_consensus_cluster) {
+    $tinfo->{'skip'} = 1;
+    $tinfo->{'comment'} = "Skip test because --skip-bin-log is specified";
+    mtr_report_test_skipped($tinfo);
+    return;
+  }
+
   # Skip secondary engine tests if the support doesn't exist.
   if (defined $tinfo->{'secondary-engine'} and !$secondary_engine_support) {
     $tinfo->{'skip'}    = 1;
@@ -5008,6 +5262,59 @@ sub run_testcase ($) {
   }
   mark_time_used('restart');
 
+  if ($opt_consensus_cluster) {
+    my $ret;
+    my $err_cnt = 0;
+    my $mysqld_servers = 0;
+    foreach my $mysqld ( mysqlds() ) {
+      my $check_cnt = 10;
+      my $mysqld_leader = 0;
+      $mysqld_servers++;
+      if (!sleep_until_pid_file_created($mysqld->value('pid-file'),
+                                    $opt_start_timeout,
+                                    $mysqld->{'proc'})
+      ) {
+        my $mname = $mysqld->name();
+        mtr_error("Failed to wait the restart mysqld");
+      }
+      # remember the new leader
+      if ($mysqld->name() eq "mysqld.1") {
+        $mysqld_leader = 1;
+        mtr_verbose("I will become leader: " . $mysqld->name());
+      }
+
+      while (1) {
+        # hack: wait server read-write or read-only
+        my $query = $mysqld_leader ? "FLUSH PRIVILEGES" : "SELECT 1";
+        $ret = run_query($mysqld, $query);
+        last if ($ret == 0);
+
+        $check_cnt--;
+        # transfer leader to 1
+        if ($mysqld_leader && $check_cnt == 0) {
+          mtr_verbose("Run leader promote query: " . $mysqld->name() . "  " . $mysqld->value('port') . "  " . $mysqld->value('socket'));
+          $query = "call dbms_consensus.force_promote();";
+          $ret = run_query($mysqld, $query);
+          $check_cnt = 10;
+        }
+
+        sleep(0.1);
+
+        $err_cnt++;
+        if ($err_cnt < 1000) {
+          mtr_report("Fail to check role, try again...");
+        } else {
+          mtr_warning("Fail to check role after $err_cnt times trying!!!");
+          report_failure_and_restart($tinfo);
+          return 1;
+        }
+      }
+    }
+
+    $err_cnt = 0;
+    mtr_verbose("Finish leader promote query.");
+  }
+
   # If '--start' or '--start-dirty' given, stop here to let user manually
   # run tests. If '--wait-all' is also given, do the same, but don't die
   # if one server exits.
@@ -5160,6 +5467,18 @@ sub run_testcase ($) {
     if ($proc eq $test) {
       my $res = $test->exit_status();
 
+      if (!$opt_consensus_cluster) {
+        if ($res == 0 and
+          $opt_warnings and
+          not defined $tinfo->{'skip_check_warnings'} and
+          check_warnings($tinfo)) {
+          # Test case succeeded, but it has produced unexpected warnings,
+          # continue in $res == 1
+          $res = 1;
+          resfile_output($tinfo->{'warnings'}) if $opt_resfile;
+        }
+      }
+
       if ($res == MYSQLTEST_NOSKIP_PASS or $res == MYSQLTEST_NOSKIP_FAIL) {
         $tinfo->{'skip_ignored'} = 1;    # Mark test as noskip pass or fail
       }
@@ -5867,19 +6186,26 @@ sub check_warnings ($) {
   # it possible to wait for any process to exit during the check.
   my %started;
   foreach my $mysqld (mysqlds()) {
-    if (defined $mysqld->{'proc'}) {
-      my $proc = start_check_warnings($tinfo, $mysqld);
-      $started{ $proc->pid() } = $proc;
-      if ($opt_valgrind_mysqld and clusters()) {
-        # In an ndbcluster enabled mysqld, calling mtr.check_warnings()
-        # involves acquiring the global schema lock(GSL) during execution.
-        # And when running with valgrind, if multiple check warnings are run
-        # in parallel, there is a chance that few of them might timeout
-        # without acquiring the GSL and thus failing the test. To avoid that,
-        # run them one by one if the mysqld is running with valgrind and
-        # ndbcluster.
-        my $res = wait_for_check_warnings(\%started, $tinfo);
-        return $res if $res;
+    if ($opt_consensus_cluster && ($opt_consensus_replication || $mysqld->name() eq "mysqld.1")) {
+      if (defined $mysqld->{'proc'} && $mysqld->name() eq "mysqld.1") {
+        my $proc= start_check_warnings($tinfo, $mysqld);
+        $started{$proc->pid()}= $proc;
+      }
+    } else {
+      if (defined $mysqld->{'proc'}) {
+        my $proc = start_check_warnings($tinfo, $mysqld);
+        $started{ $proc->pid() } = $proc;
+        if ($opt_valgrind_mysqld and clusters()) {
+          # In an ndbcluster enabled mysqld, calling mtr.check_warnings()
+          # involves acquiring the global schema lock(GSL) during execution.
+          # And when running with valgrind, if multiple check warnings are run
+          # in parallel, there is a chance that few of them might timeout
+          # without acquiring the GSL and thus failing the test. To avoid that,
+          # run them one by one if the mysqld is running with valgrind and
+          # ndbcluster.
+          my $res = wait_for_check_warnings(\%started, $tinfo);
+          return $res if $res;
+        }
       }
     }
   }
@@ -5984,8 +6310,10 @@ sub check_expected_crash_and_restart($$) {
         }
 
         # Start server with same settings as last time
-        mysqld_start($mysqld, $mysqld->{'started_opts'},
-                     $tinfo, $bootstrap_opts);
+        if (mysqld_start($mysqld, $mysqld->{'started_opts'},
+                     $tinfo, $bootstrap_opts)) {
+          return 1;
+        }
 
         if ($tinfo->{'secondary-engine'}) {
           my $restart_flag = 1;
@@ -6064,7 +6392,9 @@ sub clean_datadir {
       rmtree($mysqld_dir);
     }
   }
-
+  if ($tinfo->{'objectstore_test_dir'}) {
+    clean_objectstore_test_dir($tinfo->{'objectstore_test_dir'}, $tinfo->{name});
+  }
   # Remove all files in tmp and var/tmp
   clean_dir("$opt_vardir/tmp");
   if ($opt_tmpdir ne "$opt_vardir/tmp") {
@@ -6147,7 +6477,7 @@ sub report_failure_and_restart ($) {
     $tinfo->{'dont_kill_server'} = 1;
   }
 
-  # Shutdown properly if not to be killed (for valgrind)
+  # Shotdown properly if not to be killed (for valgrind)
   stop_all_servers($tinfo->{'dont_kill_server'} ? $opt_shutdown_timeout : 0);
 
   $tinfo->{'result'} = 'MTR_RES_FAILED';
@@ -6375,6 +6705,10 @@ sub mysqld_arguments ($$$) {
     mtr_add_arg($args, "%s", "--core-file");
   }
 
+  if (!$opt_consensus_cluster || (!$opt_consensus_replication && $mysqld->name() ne "mysqld.1")) {
+    mtr_add_arg($args, "--loose-raft-replication=0");
+  }
+
   return $args;
 }
 
@@ -6406,6 +6740,18 @@ sub mysqld_start ($$$$) {
 
   foreach my $arg (@$extra_opts) {
     $daemonize_mysqld = 1 if ($arg eq "--daemonize");
+
+    # disable some case with cnf not supported
+    if ($opt_consensus_cluster && ($opt_consensus_replication || $mysqld->name() eq "mysqld.1")) {
+      if ($arg eq "--server-id=0") {
+        mtr_print("Failed to start with mysqld option --server-id=0 for:", $mysqld->name());
+        return 1;
+      }
+      if ($arg eq "--skip-log-bin") {
+        mtr_print("Failed to start mysqld with option --skip-log-bin for:", $mysqld->name());
+        return 1;
+      }
+    }
   }
 
   if ($opt_valgrind_mysqld) {
@@ -6731,10 +7077,15 @@ sub servers_need_restart($) {
   my @slaves;
 
   foreach my $server (mysqlds()) {
-    if (is_slave($server)) {
-      push(@slaves, $server);
-    } else {
+
+    if ($opt_consensus_cluster && $opt_consensus_replication) {
       push(@masters, $server);
+    } else {
+      if (is_slave($server)) {
+	push(@slaves, $server);
+      } else {
+	push(@masters, $server);
+      }
     }
   }
 
@@ -6743,7 +7094,19 @@ sub servers_need_restart($) {
   foreach my $master (@masters) {
     if (server_need_restart($tinfo, $master, $master_restarted)) {
       $master_restarted = 1;
-      push(@restart_servers, $master);
+      # cluster restart all server, skip here.
+      if (!$opt_consensus_cluster) {
+        push(@restart_servers, $master);
+      }
+    }
+  }
+
+  # cluster need restart all server when restart one
+  if ($opt_consensus_cluster) {
+    if ($master_restarted) {
+      foreach my $master (@masters) {
+        push(@restart_servers, $master);
+      }
     }
   }
 
@@ -6888,6 +7251,18 @@ sub start_servers($) {
 
   my $server_id = 0;
   # Start mysqlds
+  $consensus_cluster_id_cnt= 1;
+  #generate consensus_cluster_info_prefix
+  $consensus_cluster_info_prefix= '';
+  if ($opt_consensus_cluster && $opt_consensus_replication) {
+    my $consensus_cluster_info_arr= ();
+    foreach my $mysqld (mysqlds()) {
+      # CONSENSUS_PORT = (server_port + 8000)
+      push (@$consensus_cluster_info_arr, '127.0.0.1:'.($mysqld->value('port')+8000));
+    }
+    mtr_verbose('consensus_cluster_info_prefix: ' . join(';', @$consensus_cluster_info_arr));
+    $consensus_cluster_info_prefix= join(';', @$consensus_cluster_info_arr);
+  }
 
   foreach my $mysqld (mysqlds()) {
     # Group Replication requires a local port to be open on each server
@@ -6907,6 +7282,10 @@ sub start_servers($) {
       $ENV{$xcom_server} = $xcom_port;
     }
 
+    if ($opt_consensus_cluster && !$opt_consensus_replication && $mysqld->name() eq "mysqld.1") {
+      $consensus_cluster_info_prefix = '127.0.0.1:'.($mysqld->value('port')+8000);
+    }
+
     if ($mysqld->{proc}) {
       # Already started, write start of testcase to log file
       mark_testcase_start_in_logs($mysqld, $tinfo);
@@ -6944,34 +7323,46 @@ sub start_servers($) {
     if ($basedir eq $mysqld_basedir) {
       # If dirty, keep possibly grown system db
       if (!$opt_start_dirty) {
-        # Copy datadir from installed system db
-        my $path = ($opt_parallel == 1) ? "$opt_vardir" : "$opt_vardir/..";
-        my $install_db = "$path/data/";
-        if (!-d $datadir or
+        if (!$opt_consensus_cluster) {
+          # Copy datadir from installed system db
+          my $path = ($opt_parallel == 1) ? "$opt_vardir" : "$opt_vardir/..";
+          my $install_db = "$path/data/";
+          if (!-d $datadir or
             (!$bootstrap_opts and
              !$mysqld->{need_reinitialization})
           ) {
-          copytree($install_db, $datadir) if -d $install_db;
-          mtr_error("Failed to copy system db to '$datadir'")
+            copytree($install_db, $datadir) if -d $install_db;
+            mtr_error("Failed to copy system db to '$datadir'")
             unless -d $datadir;
-        }
+          }
+
+          # Restore the value of bootstrap command for the next run.
+          if ($initial_bootstrap_cmd ne $ENV{'MYSQLD_BOOTSTRAP_CMD'}) {
+            $ENV{'MYSQLD_BOOTSTRAP_CMD'} = $initial_bootstrap_cmd;
+          }
+        } else {
+          # should bootstrap with $bootstrap_opts
+          mysql_install_db($mysqld, $datadir, $bootstrap_opts, $tinfo);
+          $mysqld->{need_reinitialization} = 0;
 
-        # Restore the value of bootstrap command for the next run.
-        if ($initial_bootstrap_cmd ne $ENV{'MYSQLD_BOOTSTRAP_CMD'}) {
-          $ENV{'MYSQLD_BOOTSTRAP_CMD'} = $initial_bootstrap_cmd;
+          mtr_error("Failed to install system db to '$datadir'")
+          unless -d $datadir;
         }
       }
     } else {
       mysql_install_db($mysqld);    # For versional testing
       mtr_error("Failed to install system db to '$datadir'")
-        unless -d $datadir;
+      unless -d $datadir;
     }
 
     # Reinitialize the data directory if there are bootstrap options
     # in the opt file.
     if ($mysqld->{need_reinitialization}) {
       clean_dir($datadir);
-      mysql_install_db($mysqld, $datadir, $bootstrap_opts);
+      if ($opt_consensus_cluster && $opt_consensus_replication) {
+        $consensus_cluster_id_cnt--;
+      }
+      mysql_install_db($mysqld, $datadir, $bootstrap_opts, $tinfo);
       $tinfo->{'reinitialized'} = 1;
       # Remove the bootstrap.sql file so that a duplicate set of
       # SQL statements do not get written to the same file.
@@ -6985,16 +7376,19 @@ sub start_servers($) {
 
     # Run <tname>-master.sh
     if ($mysqld->option('#!run-master-sh') and
-        run_sh_script($tinfo->{master_sh})) {
+      run_sh_script($tinfo->{master_sh})) {
       $tinfo->{'comment'} = "Failed to execute '$tinfo->{master_sh}'";
       return 1;
     }
 
     # Run <tname>-slave.sh
-    if ($mysqld->option('#!run-slave-sh') and
+
+    if (!$opt_consensus_cluster || (!$opt_consensus_replication && $mysqld->name() ne "mysqld.1")) {
+      if ($mysqld->option('#!run-slave-sh') and
         run_sh_script($tinfo->{slave_sh})) {
-      $tinfo->{'comment'} = "Failed to execute '$tinfo->{slave_sh}'";
-      return 1;
+        $tinfo->{'comment'} = "Failed to execute '$tinfo->{slave_sh}'";
+        return 1;
+      }
     }
 
     # It's safe to not write log mark if the above sh scripts failed and
@@ -7005,7 +7399,10 @@ sub start_servers($) {
     mark_testcase_start_in_logs($mysqld, $tinfo);
 
     my $extra_opts = get_extra_opts($mysqld, $tinfo);
-    mysqld_start($mysqld, $extra_opts, $tinfo, $bootstrap_opts);
+    if (mysqld_start($mysqld, $extra_opts, $tinfo, $bootstrap_opts)) {
+      $tinfo->{'comment'} = "Failed to start mysqld for " . $mysqld->name();
+      return 1;
+    }
 
     # Save this test case information, so next can examine it
     $mysqld->{'started_tinfo'} = $tinfo;
@@ -7086,7 +7483,11 @@ sub start_check_testcase ($$$) {
   mtr_add_arg($args, "--defaults-file=%s",         $path_config_file);
   mtr_add_arg($args, "--defaults-group-suffix=%s", $mysqld->after('mysqld'));
   mtr_add_arg($args, "--result-file=%s", "$opt_vardir/tmp/$name.result");
-  mtr_add_arg($args, "--test-file=%s",   "include/check-testcase.test");
+  if ($opt_consensus_cluster) {
+    mtr_add_arg($args, "--test-file=%s",   "include/check-testcase-wesql.test");
+  } else {
+    mtr_add_arg($args, "--test-file=%s",   "include/check-testcase.test");
+  }
   mtr_add_arg($args, "--verbose");
   mtr_add_arg($args, "--logdir=%s/tmp",  $opt_vardir);
 
diff --git a/mysql-test/r/innodb_mysql_sync.result b/mysql-test/r/innodb_mysql_sync.result
index 02a6bc0ec60..82ee723f1d2 100644
--- a/mysql-test/r/innodb_mysql_sync.result
+++ b/mysql-test/r/innodb_mysql_sync.result
@@ -86,9 +86,7 @@ KILL QUERY ID;
 SET DEBUG_SYNC= 'now SIGNAL killed';
 # Connection con1
 # Reaping: OPTIMIZE TABLE t1
-Table	Op	Msg_type	Msg_text
-test.t1	optimize	note	Table does not support optimize, doing recreate + analyze instead
-test.t1	optimize	status	Operation failed
+ERROR HY000: Error on observer while running replication hook 'before_commit'.
 # Connection default
 DROP TABLE t1;
 SET DEBUG_SYNC= 'RESET';
diff --git a/mysql-test/r/mysqld--help-notwin.result b/mysql-test/r/mysqld--help-notwin.result
index 967a0bd6bf6..fd8074ca1a0 100644
--- a/mysql-test/r/mysqld--help-notwin.result
+++ b/mysql-test/r/mysqld--help-notwin.result
@@ -1482,6 +1482,280 @@ The following options may be given as the first argument:
  Log slow queries to given log file. Defaults logging to
  hostname-slow.log. Must be enabled to activate other slow
  log options
+ --smartengine[=name] 
+ Enable or disable SMARTENGINE plugin. Possible values are
+ ON, OFF, FORCE (don't start if the plugin fails to load).
+ --smartengine-auto-shrink-enabled 
+ DBOptions::auto_shrink_enabled for SE
+ (Defaults to on; use --skip-smartengine-auto-shrink-enabled to disable.)
+ --smartengine-auto-shrink-schedule-interval=# 
+ DBOptions::auto_shrink_schedule_interval for SE
+ --smartengine-base-background-compactions=# 
+ DBOptions::base_background_compactions for SE
+ --smartengine-batch-group-max-group-size=# 
+ DBOptions::batch_group_max_group_size for SE
+ --smartengine-batch-group-max-leader-wait-time-us=# 
+ DBOptions::batch_group_max_leader_wait_time_us for SE
+ --smartengine-batch-group-slot-array-size=# 
+ DBOptions::batch_group_slot_array_size for SE
+ --smartengine-block-cache-size=# 
+ block_cache size for SE
+ --smartengine-block-size=# 
+ BlockBasedTableOptions::block_size for SE
+ --smartengine-bottommost-level=# 
+ CFOptions::bottommost_level for SE
+ --smartengine-bulk-load-size=# 
+ Max #records in a batch for bulk-load mode
+ --smartengine-cfstats[=name] 
+ Enable or disable SMARTENGINE_CFSTATS plugin. Possible
+ values are ON, OFF, FORCE (don't start if the plugin
+ fails to load).
+ --smartengine-columns[=name] 
+ Enable or disable SMARTENGINE_COLUMNS plugin. Possible
+ values are ON, OFF, FORCE (don't start if the plugin
+ fails to load).
+ --smartengine-compact-cf=# 
+ Compact sub table
+ --smartengine-compaction-delete-percent=# 
+ CFOptions::compaction_delete_percent for SE
+ --smartengine-compaction-history[=name] 
+ Enable or disable SMARTENGINE_COMPACTION_HISTORY plugin.
+ Possible values are ON, OFF, FORCE (don't start if the
+ plugin fails to load).
+ --smartengine-compaction-mode=# 
+ DBOptions::compaction_mode for SE
+ --smartengine-compaction-stats[=name] 
+ Enable or disable SMARTENGINE_COMPACTION_STATS plugin.
+ Possible values are ON, OFF, FORCE (don't start if the
+ plugin fails to load).
+ --smartengine-compaction-task[=name] 
+ Enable or disable SMARTENGINE_COMPACTION_TASK plugin.
+ Possible values are ON, OFF, FORCE (don't start if the
+ plugin fails to load).
+ --smartengine-compaction-task-extents-limit=# 
+ CFOptions::compaction_task_extents_limit for SE
+ --smartengine-compaction-type=# 
+ DBOptions::compaction_type for SE
+ --smartengine-compression-options=name 
+ CFOptions::compression_opts for SE
+ --smartengine-compression-per-level=name 
+ CFOptions::compression_per_level for SE
+ --smartengine-concurrent-writable-file-buffer-num=# 
+ DBOptions::concurrent_writable_file_buffer_num for SE
+ --smartengine-concurrent-writable-file-buffer-switch-limit=# 
+ DBOptions::concurrent_writable_file_buffer_switch_limit
+ for SE
+ --smartengine-concurrent-writable-file-single-buffer-size=# 
+ DBOptions::concurrent_writable_file_single_buffer_size
+ for SE
+ --smartengine-cpu-compaction-thread-num=# 
+ DBOptions::cpu_compaction_thread_num for SE
+ --smartengine-datadir[=name] 
+ SE data directory
+ --smartengine-db-total-write-buffer-size=# 
+ DBOptions::db_total_write_buffer_size for SE
+ --smartengine-db-write-buffer-size=# 
+ DBOptions::db_write_buffer_size for SE
+ --smartengine-dbstats[=name] 
+ Enable or disable SMARTENGINE_DBSTATS plugin. Possible
+ values are ON, OFF, FORCE (don't start if the plugin
+ fails to load).
+ --smartengine-ddl[=name] 
+ Enable or disable SMARTENGINE_DDL plugin. Possible values
+ are ON, OFF, FORCE (don't start if the plugin fails to
+ load).
+ --smartengine-deadlock-detect 
+ Enables deadlock detection
+ --smartengine-debug-info[=name] 
+ Enable or disable SMARTENGINE_DEBUG_INFO plugin. Possible
+ values are ON, OFF, FORCE (don't start if the plugin
+ fails to load).
+ --smartengine-disable-auto-compactions 
+ CFOptions::disable_auto_compaction for SE
+ --smartengine-disable-instant-ddl 
+ disable instant ddl feature if necessary.
+ --smartengine-disable-online-ddl=# 
+ disable online ddl feature if necessary.0: not disable
+ online ddl,1: disable online-rebuild ddl, like modify
+ pk,2: disable all type online-ddl include
+ rebuild/norebuild
+ --smartengine-disable-parallel-ddl 
+ disable parall ddl feature if necessary.
+ --smartengine-dump-malloc-stats 
+ DBOptions::dump_malloc_stats for se
+ --smartengine-dump-memtable-limit-size=# 
+ DBOptions::dump_memtable_limit_size for SE
+ --smartengine-enable-2pc 
+ Enable two phase commit for SE
+ (Defaults to on; use --skip-smartengine-enable-2pc to disable.)
+ --smartengine-estimate-cost-depth=# 
+ DBOptions::estimate_cost_depth for SE
+ --smartengine-flush-delete-percent=# 
+ CFOptions::flush_delete_percent for SE
+ --smartengine-flush-delete-percent-trigger=# 
+ CFOptions::flush_delete_percent_trigger for SE
+ --smartengine-flush-delete-record-trigger=# 
+ CFOptions::flush_delete_record_trigger for SE
+ --smartengine-flush-log-at-trx-commit=# 
+ Sync on transaction commit. Similar to
+ innodb_flush_log_at_trx_commit. 1: sync on commit, 0: not
+ sync until wal_bytes_per_sync, 2: sync per second
+ --smartengine-force-flush-memtable-now 
+ Forces memstore flush which may block all write requests
+ so be careful
+ --smartengine-fpga-compaction-thread-num=# 
+ DBOptions::fpga_compaction_thread_num for SE
+ --smartengine-global-info[=name] 
+ Enable or disable SMARTENGINE_GLOBAL_INFO plugin.
+ Possible values are ON, OFF, FORCE (don't start if the
+ plugin fails to load).
+ --smartengine-hotbackup=name 
+ Hot Backup
+ --smartengine-idle-tasks-schedule-time=# 
+ DBOptions::idle_tasks_schedule_time for SE
+ --smartengine-index-file-map[=name] 
+ Enable or disable SMARTENGINE_INDEX_FILE_MAP plugin.
+ Possible values are ON, OFF, FORCE (don't start if the
+ plugin fails to load).
+ --smartengine-level-compaction-dynamic-level-bytes 
+ CFOptions::level_compaction_dynamic_level_bytes for SE
+ (Defaults to on; use --skip-smartengine-level-compaction-dynamic-level-bytes to disable.)
+ --smartengine-level0-file-num-compaction-trigger=# 
+ CFOptions::level0_file_num_compaction_trigger for SE
+ --smartengine-level0-layer-num-compaction-trigger=# 
+ CFOptions::level0_layer_num_compaction_trigger for SE
+ --smartengine-level1-extents-major-compaction-trigger=# 
+ CFOptions::level1_extents_major_compaction_trigger for SE
+ --smartengine-level2-usage-percent=# 
+ CFOptions::level2_usage_percent for SE
+ --smartengine-lock-scanned-rows 
+ Take and hold locks on rows that are scanned but not
+ updated
+ --smartengine-lock-wait-timeout=# 
+ Number of seconds to wait for lock
+ --smartengine-locks[=name] 
+ Enable or disable SMARTENGINE_LOCKS plugin. Possible
+ values are ON, OFF, FORCE (don't start if the plugin
+ fails to load).
+ --smartengine-master-thread-monitor-interval-ms[=#] 
+ DBOptions::master_thread_monitor_interval_ms for SE
+ --smartengine-max-background-compactions=# 
+ DBOptions::max_background_compactions for SE
+ --smartengine-max-background-dumps=# 
+ DBOptions::max_background_dumps for SE
+ --smartengine-max-background-flushes=# 
+ DBOptions::max_background_flushes for SE
+ --smartengine-max-free-extent-percent=# 
+ DBOptions::max_free_extent_percent for SE
+ --smartengine-max-manifest-file-size=# 
+ DBOptions::max_manifest_file_size for SE
+ --smartengine-max-row-locks=# 
+ Maximum number of locks a transaction can have
+ --smartengine-max-shrink-extent-count=# 
+ DBOptions::max_shrink_extent_count for SE
+ --smartengine-max-total-wal-size=# 
+ DBOptions::max_total_wal_size for SE
+ --smartengine-max-write-buffer-number=# 
+ CFOptions::max_write_buffer_number for SE
+ --smartengine-max-write-buffer-number-to-maintain=# 
+ CFOptions::max_write_buffer_number_to_maintain for SE
+ --smartengine-mem-alloc[=name] 
+ Enable or disable SMARTENGINE_MEM_ALLOC plugin. Possible
+ values are ON, OFF, FORCE (don't start if the plugin
+ fails to load).
+ --smartengine-memtable=name 
+ options for CFOptions::memtable in SE
+ --smartengine-min-write-buffer-number-to-merge=# 
+ CFOptions::min_write_buffer_number_to_merge for SE
+ --smartengine-mutex-backtrace-threshold-ns=# 
+ DBOptions::mutex_backtrace_threshold_ns for SE
+ --smartengine-parallel-read-threads=# 
+ Number of threads to do parallel read.
+ --smartengine-parallel-recovery-thread-num=# 
+ DBOptions::parallel_recovery_thread_num for SE. Default
+ is 0
+ --smartengine-parallel-wal-recovery 
+ DBOptions::parallel_wal_recovery for SE. Default is FALSE
+ --smartengine-pause-background-work 
+ Disable all se background operations
+ --smartengine-perf-context[=name] 
+ Enable or disable SMARTENGINE_PERF_CONTEXT plugin.
+ Possible values are ON, OFF, FORCE (don't start if the
+ plugin fails to load).
+ --smartengine-perf-context-global[=name] 
+ Enable or disable SMARTENGINE_PERF_CONTEXT_GLOBAL plugin.
+ Possible values are ON, OFF, FORCE (don't start if the
+ plugin fails to load).
+ --smartengine-purge-invalid-subtable-bg 
+ Turn on to enable purging invalid subtable in background
+ (Defaults to on; use --skip-smartengine-purge-invalid-subtable-bg to disable.)
+ --smartengine-query-trace[=name] 
+ Enable or disable SMARTENGINE_QUERY_TRACE plugin.
+ Possible values are ON, OFF, FORCE (don't start if the
+ plugin fails to load).
+ --smartengine-query-trace-print-slow 
+ If print slow query detail in error log for SE
+ --smartengine-query-trace-sum=name 
+ If record query detail in IS table for SE
+ --smartengine-query-trace-threshold-time=# 
+ If a query use more than this, a trace log will be
+ printed to error log
+ --smartengine-rate-limiter-bytes-per-sec=# 
+ DBOptions::rate_limiter bytes_per_sec for SE
+ --smartengine-reset-pending-shrink=# 
+ reset subtable's pending shrink
+ --smartengine-row-cache-size=# 
+ row_cache size for SE
+ --smartengine-scan-add-blocks-limit=# 
+ CFOptions::scan_add_blocks_limit for SE
+ --smartengine-shrink-allocate-interval=# 
+ DBOptions::shrink_allocate_interval for SE
+ --smartengine-shrink-table-space=# 
+ Shrink se table space
+ --smartengine-sort-buffer-size=# 
+ Memory buffer size for index creation
+ --smartengine-stats-dump-period-sec=# 
+ DBOptions::stats_dump_period_sec for SE
+ --smartengine-strict-collation-check 
+ Enforce case sensitive collation for SE indexes
+ (Defaults to on; use --skip-smartengine-strict-collation-check to disable.)
+ --smartengine-strict-collation-exceptions=name 
+ List of tables (using regex) that are excluded from the
+ case sensitive collation enforcement
+ --smartengine-subtable[=name] 
+ Enable or disable SMARTENGINE_SUBTABLE plugin. Possible
+ values are ON, OFF, FORCE (don't start if the plugin
+ fails to load).
+ --smartengine-table-cache-numshardbits=# 
+ DBOptions::table_cache_numshardbits for SE
+ --smartengine-table-cache-size=# 
+ DBOptions::table_cache_size for SE
+ --smartengine-table-space[=name] 
+ Enable or disable SMARTENGINE_TABLE_SPACE plugin.
+ Possible values are ON, OFF, FORCE (don't start if the
+ plugin fails to load).
+ --smartengine-tables[=name] 
+ Enable or disable SMARTENGINE_TABLES plugin. Possible
+ values are ON, OFF, FORCE (don't start if the plugin
+ fails to load).
+ --smartengine-total-max-shrink-extent-count=# 
+ DBOptions::total_max_shrink_extent_count for SE
+ --smartengine-trx[=name] 
+ Enable or disable SMARTENGINE_TRX plugin. Possible values
+ are ON, OFF, FORCE (don't start if the plugin fails to
+ load).
+ --smartengine-unsafe-for-binlog 
+ Allowing statement based binary logging which may break
+ consistency
+ --smartengine-wal-dir=name 
+ DBOptions::wal_dir for SE
+ --smartengine-wal-recovery-mode=# 
+ DBOptions::wal_recovery_mode for SE. Default is
+ kAbsoluteConsistency
+ --smartengine-write-buffer-size=# 
+ CFOptions::write_buffer_size for SE
+ --smartengine-write-disable-wal 
+ WriteOptions::disableWAL for SE
  --socket=name       Socket file to use for connection
  --sort-buffer-size=# 
  Each thread that needs to do a sort allocates a buffer of
@@ -2029,6 +2303,114 @@ slave-transaction-retries 10
 slave-type-conversions 
 slow-launch-time 2
 slow-query-log FALSE
+smartengine OFF
+smartengine-auto-shrink-enabled TRUE
+smartengine-auto-shrink-schedule-interval 3600
+smartengine-base-background-compactions 1
+smartengine-batch-group-max-group-size 8
+smartengine-batch-group-max-leader-wait-time-us 50
+smartengine-batch-group-slot-array-size 8
+smartengine-block-cache-size 536870912
+smartengine-block-size 16384
+smartengine-bottommost-level 2
+smartengine-bulk-load-size 10000
+smartengine-cfstats OFF
+smartengine-columns OFF
+smartengine-compact-cf 0
+smartengine-compaction-delete-percent 70
+smartengine-compaction-history OFF
+smartengine-compaction-mode 0
+smartengine-compaction-stats OFF
+smartengine-compaction-task OFF
+smartengine-compaction-task-extents-limit 1000
+smartengine-compaction-type 0
+smartengine-compression-options -14:1:0
+smartengine-compression-per-level kNoCompression
+smartengine-concurrent-writable-file-buffer-num 4
+smartengine-concurrent-writable-file-buffer-switch-limit 32768
+smartengine-concurrent-writable-file-single-buffer-size 65536
+smartengine-cpu-compaction-thread-num 8
+smartengine-datadir ./.smartengine
+smartengine-db-total-write-buffer-size 107374182400
+smartengine-db-write-buffer-size 107374182400
+smartengine-dbstats OFF
+smartengine-ddl OFF
+smartengine-deadlock-detect FALSE
+smartengine-debug-info OFF
+smartengine-disable-auto-compactions FALSE
+smartengine-disable-instant-ddl FALSE
+smartengine-disable-online-ddl 0
+smartengine-disable-parallel-ddl FALSE
+smartengine-dump-malloc-stats FALSE
+smartengine-dump-memtable-limit-size 67108864
+smartengine-enable-2pc TRUE
+smartengine-estimate-cost-depth 0
+smartengine-flush-delete-percent 70
+smartengine-flush-delete-percent-trigger 700000
+smartengine-flush-delete-record-trigger 700000
+smartengine-flush-log-at-trx-commit 1
+smartengine-force-flush-memtable-now FALSE
+smartengine-fpga-compaction-thread-num 8
+smartengine-global-info OFF
+smartengine-hotbackup 
+smartengine-idle-tasks-schedule-time 60
+smartengine-index-file-map OFF
+smartengine-level-compaction-dynamic-level-bytes TRUE
+smartengine-level0-file-num-compaction-trigger 64
+smartengine-level0-layer-num-compaction-trigger 8
+smartengine-level1-extents-major-compaction-trigger 1000
+smartengine-level2-usage-percent 70
+smartengine-lock-scanned-rows FALSE
+smartengine-lock-wait-timeout 1
+smartengine-locks OFF
+smartengine-master-thread-monitor-interval-ms 60000
+smartengine-max-background-compactions 1
+smartengine-max-background-dumps 1
+smartengine-max-background-flushes 1
+smartengine-max-free-extent-percent 10
+smartengine-max-manifest-file-size 18446744073709551615
+smartengine-max-row-locks 1073741824
+smartengine-max-shrink-extent-count 512
+smartengine-max-total-wal-size 107374182400
+smartengine-max-write-buffer-number 1000
+smartengine-max-write-buffer-number-to-maintain 1000
+smartengine-mem-alloc OFF
+smartengine-memtable 
+smartengine-min-write-buffer-number-to-merge 2
+smartengine-mutex-backtrace-threshold-ns 1000000000
+smartengine-parallel-read-threads 4
+smartengine-parallel-recovery-thread-num 0
+smartengine-parallel-wal-recovery FALSE
+smartengine-pause-background-work FALSE
+smartengine-perf-context OFF
+smartengine-perf-context-global OFF
+smartengine-purge-invalid-subtable-bg TRUE
+smartengine-query-trace OFF
+smartengine-query-trace-print-slow FALSE
+smartengine-query-trace-sum OFF
+smartengine-query-trace-threshold-time 100
+smartengine-rate-limiter-bytes-per-sec 0
+smartengine-reset-pending-shrink 0
+smartengine-row-cache-size 0
+smartengine-scan-add-blocks-limit 100
+smartengine-shrink-allocate-interval 3600
+smartengine-shrink-table-space -1
+smartengine-sort-buffer-size 4194304
+smartengine-stats-dump-period-sec 600
+smartengine-strict-collation-check TRUE
+smartengine-strict-collation-exceptions (No default value)
+smartengine-subtable OFF
+smartengine-table-cache-numshardbits 7
+smartengine-table-cache-size 1073741824
+smartengine-table-space OFF
+smartengine-tables OFF
+smartengine-total-max-shrink-extent-count 7680
+smartengine-trx OFF
+smartengine-unsafe-for-binlog FALSE
+smartengine-wal-dir 
+smartengine-wal-recovery-mode 1
+smartengine-write-buffer-size 268435456
+smartengine-write-disable-wal FALSE
 sort-buffer-size 262144
 source-verify-checksum FALSE
 sporadic-binlog-dump-fail FALSE
diff --git a/mysql-test/r/rename_sync.result b/mysql-test/r/rename_sync.result
index c4ffc0f30dc..4d843adc6cc 100644
--- a/mysql-test/r/rename_sync.result
+++ b/mysql-test/r/rename_sync.result
@@ -21,7 +21,8 @@ SET DEBUG_SYNC= 'now SIGNAL cont';
 connection con1;
 # Reap the rename and try to drop the table being renamed. Without the patch,
 # the drop leads to an assert.
-DROP TABLE t2;
+ERROR HY000: Error on observer while running replication hook 'before_commit'.
+DROP TABLE t1;
 connection default;
 # Disconnect and cleanup.
 disconnect con1;
diff --git a/mysql-test/r/session_tracker.result b/mysql-test/r/session_tracker.result
index 23013ed3a8a..b96bb3c2911 100644
--- a/mysql-test/r/session_tracker.result
+++ b/mysql-test/r/session_tracker.result
@@ -217,7 +217,7 @@ SET @@session.sql_mode= @sql_mode_saved;
 -- sql_mode
 -- ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION
 -- statement_id
--- 60
+-- 74
 
 # Switch off the session system variables tracker (using empty string).
 SET @@session.session_track_system_variables='';
diff --git a/mysql-test/suite/auth_sec/include/auth_sec_assert_binlog_events.inc b/mysql-test/suite/auth_sec/include/auth_sec_assert_binlog_events.inc
index e0dbac3d8a5..39b3dd609fd 100644
--- a/mysql-test/suite/auth_sec/include/auth_sec_assert_binlog_events.inc
+++ b/mysql-test/suite/auth_sec/include/auth_sec_assert_binlog_events.inc
@@ -22,5 +22,15 @@ if ($invert == 1)
 }
 
 --let $dont_print_pattern= 1
---let $event_sequence= $gtid_event # $event
+
+if ($USE_CONSENSUS_CLUSTER)
+{
+  --let $event_sequence= Consensus_log # $gtid_event # $event
+}
+
+if (!$USE_CONSENSUS_CLUSTER)
+{
+  --let $event_sequence= $gtid_event # $event
+}
+
 --source include/assert_binlog_events.inc
diff --git a/mysql-test/suite/auth_sec/include/skip_grant_protocols.inc b/mysql-test/suite/auth_sec/include/skip_grant_protocols.inc
index b8c6cba9284..17889881a1e 100644
--- a/mysql-test/suite/auth_sec/include/skip_grant_protocols.inc
+++ b/mysql-test/suite/auth_sec/include/skip_grant_protocols.inc
@@ -17,7 +17,15 @@ let $start_page_size=`SELECT variable_value FROM performance_schema.global_statu
 CREATE DATABASE test;
 EOF
 
-let NEW_CMD = $MYSQLD --no-defaults --initialize-insecure --datadir=$MYSQLD_DATADIR1 --init-file=$BOOTSTRAP_SQL</dev/null>>$MYSQLTEST_VARDIR/tmp/bootstrap.log 2>&1 --innodb-page-size=$start_page_size;
+if (!$USE_CONSENSUS_REPLICATION)
+{
+  let NEW_CMD = $MYSQLD --no-defaults --initialize-insecure --datadir=$MYSQLD_DATADIR1 --init-file=$BOOTSTRAP_SQL</dev/null>>$MYSQLTEST_VARDIR/tmp/bootstrap.log 2>&1 --innodb-page-size=$start_page_size;
+}
+
+if ($USE_CONSENSUS_REPLICATION)
+{
+  let NEW_CMD = $MYSQLD --no-defaults --initialize-insecure --datadir=$MYSQLD_DATADIR1 --cluster-start-index=1 --cluster-info=127.0.0.1:29210@1 --init-file=$BOOTSTRAP_SQL</dev/null>>$MYSQLTEST_VARDIR/tmp/bootstrap.log 2>&1 --innodb-page-size=$start_page_size;
+}
 
 --echo
 --echo # Run the bootstrap command to create a new datadir
diff --git a/mysql-test/suite/funcs_1/t/is_engines.test b/mysql-test/suite/funcs_1/t/is_engines.test
index b1aa71cf382..6b0a95ff21b 100644
--- a/mysql-test/suite/funcs_1/t/is_engines.test
+++ b/mysql-test/suite/funcs_1/t/is_engines.test
@@ -117,9 +117,6 @@ DROP TABLE information_schema.engines;
 
 --error ER_DBACCESS_DENIED_ERROR
 ALTER TABLE information_schema.engines RENAME db_datadict.engines;
---error ER_DBACCESS_DENIED_ERROR
-ALTER TABLE information_schema.engines RENAME information_schema.xengines;
-
 # Cleanup
 DROP DATABASE db_datadict;
 
diff --git a/mysql-test/suite/innodb_undo/include/truncate_at_shutdown.inc b/mysql-test/suite/innodb_undo/include/truncate_at_shutdown.inc
index 1215878a42b..2006edb74fe 100644
--- a/mysql-test/suite/innodb_undo/include/truncate_at_shutdown.inc
+++ b/mysql-test/suite/innodb_undo/include/truncate_at_shutdown.inc
@@ -197,7 +197,15 @@ if ($CRASH_ON_SHUTDOWN == 1)
 # The truncate will get started during shutdown using the settings above.
 # The restarted engine does not need these settings to complete the truncate
 # if the injected crash was far enough along.
---let $restart_parameters="restart:"
+if ($USE_CONSENSUS_CLUSTER)
+{
+  --let $restart_parameters="restart: --raft-replication-cluster-id=1 --raft-replication-start-index=1 --raft-replication-cluster-info=\'127.0.0.1:29235@1\'"
+}
+if (!$USE_CONSENSUS_CLUSTER)
+{
+  --let $restart_parameters="restart:"
+}
+-- echo restart_parameters: "$restart_parameters"
 --let $explicit_default_wait_counter = 15000
 --source include/start_mysqld.inc
 
diff --git a/mysql-test/suite/rpl/r/rpl_encryption_max_binlog_size.result b/mysql-test/suite/rpl/r/rpl_encryption_max_binlog_size.result
index a687ae7f40b..40b8517b44a 100644
--- a/mysql-test/suite/rpl/r/rpl_encryption_max_binlog_size.result
+++ b/mysql-test/suite/rpl/r/rpl_encryption_max_binlog_size.result
@@ -7,6 +7,6 @@ FLUSH LOGS;
 include/assert.inc [Rotate shall be the 3rd event in first binary log]
 CREATE TABLE t1 (c1 INT PRIMARY KEY, c2 VARCHAR(255));
 # Inserting 100 transactions
-# Assert that all 11 binary logs considered the encryption header
+# Assert that all 13 binary logs considered the encryption header
 DROP TABLE t1;
 include/rpl_end.inc
diff --git a/mysql-test/suite/rpl/r/rpl_perfschema_applier_config.result b/mysql-test/suite/rpl/r/rpl_perfschema_applier_config.result
index fc71057b4ff..3833198e8b7 100644
--- a/mysql-test/suite/rpl/r/rpl_perfschema_applier_config.result
+++ b/mysql-test/suite/rpl/r/rpl_perfschema_applier_config.result
@@ -3,7 +3,7 @@ Warnings:
 Note	####	Sending passwords in plain text without SSL/TLS is extremely insecure.
 Note	####	Storing MySQL user name or password information in the connection metadata repository is not secure and is therefore not recommended. Please consider using the USER and PASSWORD connection options for START REPLICA; see the 'START REPLICA Syntax' in the MySQL Manual for more information.
 [connection master]
-include/assert.inc [On master, the table should return an empty set.]
+include/assert.inc [On master, the table should return only consensus_replication_applier.]
 
 # Verify that SELECT works and produces an output similar to
 # the corresponding field in SHOW SLAVE STATUS(SSS) in all scenarios.
diff --git a/mysql-test/suite/rpl/r/rpl_perfschema_connect_config.result b/mysql-test/suite/rpl/r/rpl_perfschema_connect_config.result
index 85d7a0d7930..4b23c050df6 100644
--- a/mysql-test/suite/rpl/r/rpl_perfschema_connect_config.result
+++ b/mysql-test/suite/rpl/r/rpl_perfschema_connect_config.result
@@ -5,7 +5,7 @@ Note	####	Storing MySQL user name or password information in the connection meta
 [connection master]
 call mtr.add_suppression("Source command COM_REGISTER_REPLICA failed.");
 call mtr.add_suppression(" * does not exist in the InnoDB internal");
-include/assert.inc [On master, the table should return an empty set.]
+include/assert.inc [On master, the table should return only consensus_replication_applier.]
 
 # Verify that SELECT works for every field and produces an output
 # similar to the corresponding field in SHOW SLAVE STATUS(SSS).
diff --git a/mysql-test/suite/rpl/t/rpl_drop_scheduled_event.test b/mysql-test/suite/rpl/t/rpl_drop_scheduled_event.test
index e8e9d2dbb69..80e2088759b 100644
--- a/mysql-test/suite/rpl/t/rpl_drop_scheduled_event.test
+++ b/mysql-test/suite/rpl/t/rpl_drop_scheduled_event.test
@@ -38,7 +38,6 @@ CREATE EVENT e1
 --sleep $naptime
 
 SET GLOBAL EVENT_SCHEDULER= ON;
-
 --echo Wait until the event is dropped to disable the event scheduler again.
 --let $wait_condition= SELECT COUNT(*) = 0 FROM information_schema.events
 --source include/wait_condition.inc
diff --git a/mysys/CMakeLists.txt b/mysys/CMakeLists.txt
index 31030c67445..e24768b9b3f 100644
--- a/mysys/CMakeLists.txt
+++ b/mysys/CMakeLists.txt
@@ -26,6 +26,37 @@ SET(MY_TIME_SOURCES my_time.cc my_systime.cc)
 
 ADD_CONVENIENCE_LIBRARY(mytime ${MY_TIME_SOURCES})
 
+SET(MY_OBJSTORE_SOURCES
+  objstore/local.cc
+  objstore/objstore.cc
+  objstore/objstore_lock.cc
+  objstore/aliyun_oss.cc
+  objstore/s3.cc)
+
+ADD_CONVENIENCE_LIBRARY(myobjstore ${MY_OBJSTORE_SOURCES})
+
+IF(NOT APPLE)
+  TARGET_LINK_LIBRARIES(myobjstore_objlib
+    PRIVATE
+    ${OBJSTORE_LIBRARIES}
+    ${OBJSTORE_OSS_LIBRARIES}
+    ${OBJSTORE_PLATFORM_DEPS}
+    )
+  add_dependencies(myobjstore_objlib ${OBJSTORE_OSS_TARGET})
+ENDIF()
+TARGET_LINK_LIBRARIES(myobjstore
+  PRIVATE
+  ${OBJSTORE_LIBRARIES}
+  ${OBJSTORE_OSS_LIBRARIES}
+  ${OBJSTORE_PLATFORM_DEPS}
+  "stdc++fs"
+  )
+add_dependencies(myobjstore ${OBJSTORE_OSS_TARGET})
+
+# shut up the compile warning when encountering aws-sdk-cpp header files.
+SET_SOURCE_FILES_PROPERTIES(${MY_OBJSTORE_SOURCES} PROPERTIES COMPILE_FLAGS
+    "-Wno-error=extra-semi -Wno-error=undef -Wno-error=cast-qual -Wno-error=overloaded-virtual -Wno-error=unused-variable -Wno-error=unused-parameter -Wno-error=suggest-override")
+
 SET(MYSYS_SOURCES
   array.cc
   charset.cc
@@ -184,6 +215,7 @@ ENDIF()
 ADD_CONVENIENCE_LIBRARY(mysys ${MYSYS_SOURCES}
   LINK_LIBRARIES
   mytime
+  myobjstore
   strings
   ext::zlib
   ext::zstd
diff --git a/mysys/my_handler_errors.h b/mysys/my_handler_errors.h
index 51db4f53057..ed425c5222c 100644
--- a/mysys/my_handler_errors.h
+++ b/mysys/my_handler_errors.h
@@ -124,7 +124,11 @@ static const char *handler_error_messages[] = {
     "Invalid table name",
     "Path is too long for the OS",
     "Histogram sampling initialization failed",
-    "Too many nested sub-expressions in a full-text search"};
+    "Too many nested sub-expressions in a full-text search",
+#ifdef WITH_SMARTENGINE
+    "Unexpected nullptr in smartengine handler"
+#endif
+};
 
 // clang-format on
 
diff --git a/mysys/print_version.cc b/mysys/print_version.cc
index 21d33533b9f..554baeed524 100644
--- a/mysys/print_version.cc
+++ b/mysys/print_version.cc
@@ -74,3 +74,7 @@ void build_version(const std::string &progname, std::string *destination) {
                 << MACHINE_TYPE << " (" << MYSQL_COMPILATION_COMMENT << ")";
   *destination = output_buffer.str();
 }
+
+#ifdef WESQL
+void print_wesql_version() { printf("WeSQL Ver %s \n", WESQL_VERSION); }
+#endif
diff --git a/plugin/clone/CMakeLists.txt b/plugin/clone/CMakeLists.txt
index 412544d7aab..ffb833addb1 100644
--- a/plugin/clone/CMakeLists.txt
+++ b/plugin/clone/CMakeLists.txt
@@ -27,6 +27,10 @@ ADD_DEFINITIONS(-DMYSQL_SERVER)
 ADD_DEFINITIONS(-DLOG_SUBSYSTEM_TAG="Clone")
 ADD_DEFINITIONS(-DLOG_COMPONENT_TAG="Clone")
 
+MY_ADD_COMPILE_DEFINITIONS(
+  src/clone_plugin.cc 
+  COMPILE_DEFINITIONS MYSQL_DYNAMIC_PLUGIN)
+  
 MYSQL_ADD_PLUGIN(clone
   src/clone_plugin.cc
   src/clone_client.cc
@@ -35,6 +39,5 @@ MYSQL_ADD_PLUGIN(clone
   src/clone_local.cc
   src/clone_os.cc
   src/clone_hton.cc
-  MODULE_ONLY
   MODULE_OUTPUT_NAME "mysql_clone"
   )
diff --git a/plugin/clone/src/clone_plugin.cc b/plugin/clone/src/clone_plugin.cc
index e93ad4948ce..7ecef335e22 100644
--- a/plugin/clone/src/clone_plugin.cc
+++ b/plugin/clone/src/clone_plugin.cc
@@ -26,8 +26,15 @@ Clone Plugin: Plugin interface
 
 */
 
+#ifdef MYSQL_DYNAMIC_PLUGIN
+#undef MYSQL_DYNAMIC_PLUGIN
 #include <mysql/plugin.h>
 #include <mysql/plugin_clone.h>
+#define MYSQL_DYNAMIC_PLUGIN 
+#else
+#include <mysql/plugin.h>
+#include <mysql/plugin_clone.h>
+#endif 
 
 #include "plugin/clone/include/clone_client.h"
 #include "plugin/clone/include/clone_local.h"
@@ -647,7 +654,7 @@ static SYS_VAR *clone_system_variables[] = {
     nullptr};
 
 /** Declare clone plugin */
-mysql_declare_plugin(clone_plugin){
+mysql_declare_plugin(clone){
     MYSQL_CLONE_PLUGIN,
 
     &clone_descriptor,
diff --git a/router/tests/integration/test_routing_reuse.cc b/router/tests/integration/test_routing_reuse.cc
index cea2719d64e..c5075d7c36a 100644
--- a/router/tests/integration/test_routing_reuse.cc
+++ b/router/tests/integration/test_routing_reuse.cc
@@ -283,6 +283,9 @@ class SharedServer {
                 "--no-defaults",
                 "--initialize-insecure",
                 "--datadir=" + mysqld_dir_name(),
+#ifdef WESQL_CLUSTER
+                "--raft-replication=OFF",
+#endif
                 "--log-error=" + mysqld_dir_name() +
                     mysql_harness::Path::directory_separator + "mysqld.err",
             });
diff --git a/scripts/CMakeLists.txt b/scripts/CMakeLists.txt
index c4ef5694b34..63f9a9f7494 100644
--- a/scripts/CMakeLists.txt
+++ b/scripts/CMakeLists.txt
@@ -150,17 +150,55 @@ ADD_CUSTOM_COMMAND(
   ${CMAKE_CURRENT_SOURCE_DIR}/firewall_stored_procedures.sql
 )
 
+IF(WITH_WESQL)
+  ADD_CUSTOM_COMMAND(
+    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/sql_commands_system_tables_wesql.h
+    COMMAND comp_sql
+    wesql_system_tables
+    ${CMAKE_CURRENT_SOURCE_DIR}/wesql_system_tables.sql
+    sql_commands_system_tables_wesql.h
+    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
+    DEPENDS comp_sql
+    ${CMAKE_CURRENT_SOURCE_DIR}/wesql_system_tables.sql
+  )
+
+  ADD_CUSTOM_COMMAND(
+    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/sql_commands_system_tables_fix_wesql.h
+    COMMAND comp_sql
+    wesql_system_tables_fix
+    ${CMAKE_CURRENT_SOURCE_DIR}/wesql_system_tables_fix.sql
+    sql_commands_system_tables_fix_wesql.h
+    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
+    DEPENDS comp_sql
+    ${CMAKE_CURRENT_SOURCE_DIR}/wesql_system_tables_fix.sql
+  )
+ENDIF()
+
 # Add target for the above to be built
 IF(NOT WITHOUT_SERVER)
-  MY_ADD_CUSTOM_TARGET(GenBootstrapPriv
-    ALL
-    DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/sql_commands_system_data.h
-    ${CMAKE_CURRENT_BINARY_DIR}/sql_commands_system_tables.h
-    ${CMAKE_CURRENT_BINARY_DIR}/sql_commands_system_users.h
-    ${CMAKE_CURRENT_BINARY_DIR}/sql_commands_help_data.h
-    ${CMAKE_CURRENT_BINARY_DIR}/sql_commands_system_tables_data_fix.h
-    ${CMAKE_CURRENT_BINARY_DIR}/sql_firewall_stored_procedures.h
-  )
+  IF(NOT WITH_WESQL)
+    MY_ADD_CUSTOM_TARGET(GenBootstrapPriv
+      ALL
+      DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/sql_commands_system_data.h
+      ${CMAKE_CURRENT_BINARY_DIR}/sql_commands_system_tables.h
+      ${CMAKE_CURRENT_BINARY_DIR}/sql_commands_system_users.h
+      ${CMAKE_CURRENT_BINARY_DIR}/sql_commands_help_data.h
+      ${CMAKE_CURRENT_BINARY_DIR}/sql_commands_system_tables_data_fix.h
+      ${CMAKE_CURRENT_BINARY_DIR}/sql_firewall_stored_procedures.h
+    )
+  ELSE()
+    MY_ADD_CUSTOM_TARGET(GenBootstrapPriv
+      ALL
+      DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/sql_commands_system_data.h
+      ${CMAKE_CURRENT_BINARY_DIR}/sql_commands_system_tables.h
+      ${CMAKE_CURRENT_BINARY_DIR}/sql_commands_system_users.h
+      ${CMAKE_CURRENT_BINARY_DIR}/sql_commands_help_data.h
+      ${CMAKE_CURRENT_BINARY_DIR}/sql_commands_system_tables_data_fix.h
+      ${CMAKE_CURRENT_BINARY_DIR}/sql_firewall_stored_procedures.h
+      ${CMAKE_CURRENT_BINARY_DIR}/sql_commands_system_tables_wesql.h
+      ${CMAKE_CURRENT_BINARY_DIR}/sql_commands_system_tables_fix_wesql.h
+    )
+  ENDIF()
 ENDIF()
 
 IF(UNIX)
diff --git a/scripts/mysql_system_tables.sql b/scripts/mysql_system_tables.sql
index ed1fb372a58..a6640aa74d3 100644
--- a/scripts/mysql_system_tables.sql
+++ b/scripts/mysql_system_tables.sql
@@ -26,6 +26,7 @@
 
 set @have_innodb= (select count(engine) from information_schema.engines where engine='INNODB' and support != 'NO');
 set @is_mysql_encrypted = (select ENCRYPTION from information_schema.INNODB_TABLESPACES where NAME='mysql');
+set @have_smartengine = (select count(engine) from information_schema.engines where engine='SMARTENGINE' and support != 'NO');
 
 -- Tables below are NOT treated as DD tables by MySQL server yet.
 
@@ -385,7 +386,7 @@ SET @cmd="CREATE TABLE IF NOT EXISTS slave_relay_log_info (
   Assign_gtids_to_anonymous_transactions_value TEXT CHARACTER SET utf8mb3 COLLATE utf8mb3_bin  COMMENT 'Indicates the UUID used while generating GTIDs for anonymous transactions',
   PRIMARY KEY(Channel_name)) DEFAULT CHARSET=utf8mb3 STATS_PERSISTENT=0 COMMENT 'Relay Log Information'";
 
-SET @str=IF(@have_innodb <> 0, CONCAT(@cmd, ' ENGINE= INNODB ROW_FORMAT=DYNAMIC TABLESPACE=mysql ENCRYPTION=\'', @is_mysql_encrypted,'\''), CONCAT(@cmd, ' ENGINE= MYISAM'));
+SET @str=IF(@@global.serverless AND @have_smartengine <> 0, CONCAT(@cmd, ' ENGINE= SMARTENGINE'), IF(@have_innodb <> 0, CONCAT(@cmd, ' ENGINE= INNODB ROW_FORMAT=DYNAMIC TABLESPACE=mysql ENCRYPTION=\'', @is_mysql_encrypted,'\''), CONCAT(@cmd, ' ENGINE= MYISAM')));
 PREPARE stmt FROM @str;
 EXECUTE stmt;
 DROP PREPARE stmt;
@@ -426,7 +427,7 @@ SET @cmd= "CREATE TABLE IF NOT EXISTS slave_master_info (
   Gtid_only BOOLEAN NOT NULL DEFAULT FALSE COMMENT 'Indicates if this channel only uses GTIDs and does not persist positions.',
   PRIMARY KEY(Channel_name)) DEFAULT CHARSET=utf8mb3 STATS_PERSISTENT=0 COMMENT 'Master Information'";
 
-SET @str=IF(@have_innodb <> 0, CONCAT(@cmd, ' ENGINE= INNODB ROW_FORMAT=DYNAMIC TABLESPACE=mysql ENCRYPTION=\'', @is_mysql_encrypted,'\''), CONCAT(@cmd, ' ENGINE= MYISAM'));
+SET @str=IF(@@global.serverless AND @have_smartengine <> 0, CONCAT(@cmd, ' ENGINE= SMARTENGINE'), IF(@have_innodb <> 0, CONCAT(@cmd, ' ENGINE= INNODB ROW_FORMAT=DYNAMIC TABLESPACE=mysql ENCRYPTION=\'', @is_mysql_encrypted,'\''), CONCAT(@cmd, ' ENGINE= MYISAM')));
 PREPARE stmt FROM @str;
 EXECUTE stmt;
 DROP PREPARE stmt;
@@ -447,7 +448,7 @@ SET @cmd= "CREATE TABLE IF NOT EXISTS slave_worker_info (
   Channel_name VARCHAR(64) CHARACTER SET utf8mb3 COLLATE utf8mb3_general_ci NOT NULL COMMENT 'The channel on which the replica is connected to a source. Used in Multisource Replication',
   PRIMARY KEY(Channel_name, Id)) DEFAULT CHARSET=utf8mb3 STATS_PERSISTENT=0 COMMENT 'Worker Information'";
 
-SET @str=IF(@have_innodb <> 0, CONCAT(@cmd, ' ENGINE= INNODB ROW_FORMAT=DYNAMIC TABLESPACE=mysql ENCRYPTION=\'', @is_mysql_encrypted,'\''), CONCAT(@cmd, ' ENGINE= MYISAM'));
+SET @str=IF(@@global.serverless AND @have_smartengine <> 0, CONCAT(@cmd, ' ENGINE= SMARTENGINE'), IF(@have_innodb <> 0, CONCAT(@cmd, ' ENGINE= INNODB ROW_FORMAT=DYNAMIC TABLESPACE=mysql ENCRYPTION=\'', @is_mysql_encrypted,'\''), CONCAT(@cmd, ' ENGINE= MYISAM')));
 PREPARE stmt FROM @str;
 EXECUTE stmt;
 DROP PREPARE stmt;
@@ -458,7 +459,7 @@ SET @cmd= "CREATE TABLE IF NOT EXISTS gtid_executed (
     interval_end BIGINT NOT NULL COMMENT 'Last number of interval.',
     PRIMARY KEY(source_uuid, interval_start)) STATS_PERSISTENT=0";
 
-SET @str=IF(@have_innodb <> 0, CONCAT(@cmd, ' ENGINE= INNODB ROW_FORMAT=DYNAMIC TABLESPACE=mysql ENCRYPTION=\'', @is_mysql_encrypted,'\''), CONCAT(@cmd, ' ENGINE= MYISAM'));
+SET @str=IF(@@global.serverless AND @have_smartengine <> 0, CONCAT(@cmd, ' ENGINE= SMARTENGINE'), IF(@have_innodb <> 0, CONCAT(@cmd, ' ENGINE= INNODB ROW_FORMAT=DYNAMIC TABLESPACE=mysql ENCRYPTION=\'', @is_mysql_encrypted,'\''), CONCAT(@cmd, ' ENGINE= MYISAM')));
 PREPARE stmt FROM @str;
 EXECUTE stmt;
 DROP PREPARE stmt;
diff --git a/share/messages_to_clients.txt b/share/messages_to_clients.txt
index e010b378799..a6f94f8f194 100644
--- a/share/messages_to_clients.txt
+++ b/share/messages_to_clients.txt
@@ -9978,6 +9978,60 @@ ER_WARN_DEPRECATED_WITH_NOTE
 
 reserved-error-section 5000 5999
 
+################################################################################
+#
+# Start of WeSQL error message. 7500 - 7999
+# Error message intended to be sent to client should start here.
+#
+start-error-number 7500
+
+ER_CONSENSUS_LEADERSHIP_CHANGE
+  eng "The cluster's leadership has already change, please relocate consensus leader and retry."
+
+ER_CONSENSUS_LOG_TOO_LARGE
+  eng "The consensus log is too large for consensus replication, please split the transcation to small ones."
+
+ER_CONSENSUS_COMMAND_ERROR
+  eng "The consensus membership change failed, error code is %d, error msg: %s"
+
+ER_CONSENSUS_FOLLOWER_NOT_ALLOWED
+  eng "The consensus follower is not allowed to to do current operation."
+
+ER_CONSENSUS_NOT_READY
+  eng "The server is not allowed to do current operation."
+
+ER_CONSENSUS_OTHER_ERROR
+  eng "Other consensus problem, retry."
+
+ER_CONSENSUS_NOT_SUPPORT
+  eng "Cannot do current operation with the Consensus Replication plugin running."
+
+ER_CONSENSUS_CONFIG_BAD
+  eng "Consensus configuration bad."
+
+ER_CONSENSUS_TOO_MANY_NODE
+  eng "The cluster has too many nodes."
+
+ER_CONSENSUS_IP_PORT_FORMAT
+  eng "The consensus node ip:port format is incorrect."
+
+ER_CONSENSUS_INDEX_NOT_VALID
+  eng "The consensus index is invalid or not found."
+
+ER_CONSENSUS_LOG_TYPE_NODE
+  eng "The consensus node is logger, which is not allowed to to do current operation."
+
+ER_NATIVE_PROC_PARAMETER_MISMATCH
+  eng "The %dth parameter didn't match for native procedure %s"
+
+ER_FORCE_STORAGE_ENGINE_TO_SMARTENGINE
+  eng "Force change storage engine from %s to smartengine in serverless mode"
+
+ER_WARN_PURGE_LOG_IN_BINLOG_ARCHIVE_NOT_RUNNING
+  eng "file %s was not purged because binlog arhive not running."
+
+ER_WARN_PURGE_LOG_NOT_PERSISTED
+  eng "file %s was not purged because it is not persisted log file."
 
 ################################################################################
 # DO NOT add messages for the error-log to this file;
diff --git a/share/messages_to_error_log.txt b/share/messages_to_error_log.txt
index cdef214ae5f..7d4b4479f98 100644
--- a/share/messages_to_error_log.txt
+++ b/share/messages_to_error_log.txt
@@ -12293,6 +12293,450 @@ ER_WARN_DEPRECATED_OR_BLOCKED_CIPHER
 # End of 8.0 error messages intended to be written to the server error log.
 #
 
+################################################################################
+#
+# Start of WeSQL error messages intended to be logged to the server error log.
+# 25000 - 29999
+################################################################################
+
+start-error-number 25000
+
+ER_CONSENSUS_FATAL_ERROR
+  eng "Fatal error: %s"
+
+ER_CONSENSUS_REPLICATION_PLUGIN_NOT_INSTALLED
+  eng "Consensus Replication plugin is not installed."
+
+ER_CONSENSUS_CMD_LOG
+  eng "user:%s  host:%s sql:%s result:%d!!!"
+
+ER_CONSENSUS_BINLOG_RECOVERING_POINT
+  eng "Consensus binlog crash recovering using %s to index %llu %s"
+
+ER_CONSENSUS_BINLOG_RECOVERING_AFTER_CRASH_USING
+  eng "Consensus binlog crash recovering using %s, ha_recover: %d"
+
+ER_CONSENSUS_BINLOG_RECOVERING_USING
+  eng "Consensus binlog recovering using %s"
+
+ER_CONSENSUS_RPL_FAILED_TO_REGISTER_SERVER_STATE_OBSERVER
+  eng "Failure when registering the server state observers"
+
+ER_CONSENSUS_RPL_FAILED_TO_REGISTER_TRANS_STATE_OBSERVER
+  eng "Failure when registering the transactions state observers"
+
+ER_CONSENSUS_RPL_FAILED_TO_REGISTER_BINLOG_MANAGER_OBSERVER
+  eng "Failure when registering the binlog manager state observers"
+
+ER_CONSENSUS_RPL_FAILED_TO_REGISTER_APPLIER_OBSERVER
+  eng "Failure when registering the applier observers"
+
+ER_CONSENSUS_RPL_NEEDS_TRANSACTIONAL_TABLE
+  eng "Table %s does not use the transactional storage engine. This is not compatible with Consensus Replication."
+
+ER_CONSENSUS_RPL_IS_STOPPING
+  eng "Plugin 'raft_replication' is stopping."
+
+ER_CONSENSUS_RPL_IS_STOPPED
+  eng "Plugin 'raft_replication' has been stopped."
+
+ER_CONSENSUS_RPL_FAILED_TO_START_ON_BOOT
+  eng "Unable to start Consensus Replication on boot"
+
+ER_CONSENSUS_RPL_FAILED_TO_STOP_ON_PLUGIN_UNINSTALL
+  eng "Failure when stopping Consensus Replication on plugin uninstall"
+
+ER_CONSENSUS_RPL_FAILED_TO_UNREGISTER_SERVER_STATE_OBSERVER
+  eng "Failure when unregistering the server state observers"
+
+ER_CONSENSUS_RPL_FAILED_TO_UNREGISTER_TRANS_STATE_OBSERVER
+  eng "Failure when unregistering the transactions state observers"
+
+ER_CONSENSUS_RPL_FAILED_TO_UNREGISTER_BINLOG_MANAGER_OBSERVER
+  eng "Failure when unregistering the binlog manager observers"
+
+ER_CONSENSUS_RPL_FAILED_TO_UNREGISTER_APPLIER_OBSERVER
+  eng "Failure when unregistering the applier observers"
+
+ER_CONSENSUS_RPL_ALL_OBSERVERS_UNREGISTERED
+  eng "All Consensus Replication server observers have been successfully unregistered"
+
+ER_CONSENSUS_RPL_BINLOG_DISABLED
+  eng "Binlog must be enabled for Consensus Replication"
+
+ER_CONSENSUS_RPL_APPLIER_METADATA_REPO_MUST_BE_TABLE
+  eng "Consensus applier metadata repository must be set to TABLE."
+
+ER_CONSENSUS_RECOVERY_TRX_LOGS
+  eng "Consensus recovery %s, transaction id: %lu, consensus index: %llu, state: %d",
+
+ER_CONSENSUS_RECOVERY_EXTERN_TRX_LOGS
+  eng "Consensus recovery %s, transaction id: '%s', consensus index: %llu, state: %d",
+
+ER_CONSENSUS_LOG_RECOVERY_FINISHED
+  eng "Consensus log recovery finished, max committed index from storage engine: %llu, valid index: %llu, committed HWM index: %llu."
+
+ER_CONSENSUS_CONSIST_RECOVERY_INVALID_POSITION
+  eng "Found invalid recovery end position while recovering from consensus log file '%s', recovery end index: %llu, valid index: %llu, valid postion: %llu, file length: %llu."
+
+ER_CONSENSUS_MTS_RECOVERY_FINISHED
+  eng "MTS recovery HWM consensus index: %llu, checkpoint consensus index: %llu.",
+
+ER_CONSENSUS_MTS_RECOVERY_LAST_LEAD_TERM_INDEX
+  eng "Consensus recovery start apply index, last leader log term: %llu, last leader term log index: %llu, last log term: %llu.",
+
+ER_CONSENSUS_RECOVERY_APPLIED_INDEX_START
+  eng "Consensus recovery start apply index, recover status: %llu, first_index: %llu, start apply index: %llu, committed HWM index: %llu, applier index: %llu."
+
+ER_CONSENSUS_RECOVERY_APPLIED_INDEX_STOP
+  eng "Consensus recovery start apply index, recovered index: %llu."
+
+ER_CONSENSUS_RECOVERY_GTID_FINISHED
+  eng "Consensus recovery gtid sets finished."
+
+ER_CONSENSUS_RECOVERY_LAST_TERM_INDEX
+  eng "Failed to find the index of the last leader term"
+
+ER_CONSENSUS_FIND_LOG_ERROR
+  eng "Failed to find consensus log for index %llu when %s"
+
+ER_CONSENSUS_LOG_READ_FILE_ERROR
+  eng "Failed to read events from consensus log file '%s': %s."
+
+ER_CONSENSUS_LOG_FIND_INDEX_IN_FILE_ERROR
+  eng "Failed to find index %llu in file '%s'"
+
+ER_CONSENSUS_LOG_FIND_POSITION_ERROR
+  eng "Failed to find the position of the index %llu when %s"
+
+ER_CONSENSUS_LOG_READ_BY_INDEX_ERROR
+  eng "Failed to read consensus log by index, index: %llu"
+
+ER_CONSENSUS_LOG_RETRIEVE_LOW_BOUND_POS
+  eng "Retrieve low bound pos of index %llu from index %llu in consensus logs. pos: %llu, matched: %d"
+
+ER_CONSENSUS_LOG_FIND_NEXT_TRX_ERROR
+  eng "Failed to find next transaction index. index: %llu"
+
+ER_CONSENSUS_LOG_FIND_NEXT_TRX_LOG
+  eng "Consensus log find next transaction index. index: %llu, next transaction start index: %llu"
+
+ER_CONSENSUS_GET_NEXT_INDEX_FAILED
+  eng "Failed to retrieve next index from consensus log file: '%s'."
+
+ER_CONSENSUS_READ_MALFORMED_LOG
+  eng "Found invalid index sequence while reading from consensus log file '%s', target index: %llu, current index: %llu, start index: %llu"
+
+ER_CONSENSUS_LOG_UNEXPECTED_EVENT
+  eng "Consensus log file do not contain prev_consensus_log_ev, file: '%s'"
+
+ER_CONSENSUS_PURGE_BEFORE_TIME_LOG
+  eng "Purge consensus logs before time, time: %d, log file: '%s', target_index: %llu"
+
+ER_CONSENSUS_PURGE_BEFORE_FILE_LOG
+  eng "Purge consensus logs before log, log file: '%s', target_index: %llu"
+
+ER_CONSENSUS_PURGE_LOG_ERROR
+  eng "Failed to purge consensus logs, target_index: %llu, error: %s"
+
+ER_CONSENSUS_TRUNCATE_LOG
+  eng "Truncate consensus logs to file '%s', offset: %llu, consensus writing: %d"
+
+ER_CONSENSUS_LOG_TRUNCATE_FILES
+  eng "Truncate consensus log %s '%s'"
+
+ER_CONSENSUS_LOG_TRUNCATE_FILES_AFTER_ERROR
+  eng "Failed to truncate consensus log files after '%s'"
+
+ER_CONSENSUS_LOG_TRUNCATE_OFFSET_ERROR
+  eng "Failed to truncate consensus log file '%s' at %llu"
+
+ER_CONSENSUS_LOG_ROTATE_ERROR
+  eng "Failed to rotate consensus log when appending log entry."
+
+ER_CONSENSUS_LOG_ROTATE_IN_TRX_ERROR
+  eng "Failed to rotate consensus log, because the last consensus log entry is in middle of a large transaction."
+
+ER_CONSENSUS_LOG_MANAGER_LOG_OPS
+  eng "Consensus log manager %s log, index: %llu"
+
+ER_CONSENSUS_LOG_MANAGER_LOG_FILE_OPS
+  eng "Consensus log manager %s log, log file: '%s'"
+
+ER_CONSENSUS_GET_LOG_ENTRY_UNFLUSHED_ERROR
+  eng "Failed to get log entry, because the entry has not been flushed to disk. index: %llu, sync index: %llu"
+
+ER_CONSENSUS_LOG_ENTRY_NOT_FOUND_FROM_CACHE
+  eng "Unable to get the log entry in the cache. channel id: %llu, index: %llu, error: %d"
+
+ER_CONSENSUS_LOG_RESET_PREVIOUS_GITD_SET_ERROR
+  eng "Failed to reset the previous_gtid_set of the consensus log"
+
+ER_CONSENSUS_ARCHIVE_RECOVERY_LOG
+  eng "Consensus archive recovery started from '%s', last log index: %llu, recovery target time: %s"
+
+ER_CONSENSUS_ARCHIVE_LOG_RROCESS_LOG
+  eng "Consensus archive recovery is processing log file '%s', start index: %llu, expected next index: %llu"
+
+ER_CONSENSUS_ARCHIVE_LOG_NOT_CONTINUOUS_ERROR
+  eng "Consensus archive log file '%s' is not continuous with the previous. start index: %llu, expected next index: %llu"
+
+ER_CONSENSUS_ARCHIVE_RECOVERY_IGNORE_LOG
+  eng "Consensus archive reocovery ingored log file '%s'. The end index %llu is less than %llu as expected."
+
+ER_CONSENSUS_ARCHIVE_RECOVERY_TRUNCATE_LOG
+  eng "Consensus archive recovery truncated log to index %llu."
+
+ER_CONSENSUS_ARCHIVE_RECOVERY_GENERATE_LOG
+  eng "Consensus archvie recovery generate a new binlog file from archive file '%s'."
+
+ER_CONSENSUS_ARCHIVE_RECOVERY_ADVANCE_TERM
+  eng "Consensus archive recovery advanced log term to %llu",
+
+ER_CONSENSUS_ARCHIVE_RECOVERY_ADVANCE_NEXT_INDEX
+  eng "Consensus archive recovery advanced the next index of consensus log, new binlog file: '%s', next index: %llu."
+
+ER_CONSENSUS_ARCHIVE_RECOVERY_REACHED_STOP_POINT
+  eng "Consensnsu archive recovery reached the log's stop point. next index: %llu."
+
+ER_CONSENSUS_STATE_LEADER_DEGRADED
+  eng "Consensus state leader degradation has %s, term: %llu, commit index: %llu"
+
+ER_CONSENSUS_STATE_CHANGE_IGNORED
+  eng "Consensus state change has ingored, term: %llu, commit index: %llu, reason: %s"
+
+ER_CONSENSUS_STATE_FOLLOWER_UPGRADE
+  eng "Consensus state follower upgradation has %s, term: %llu, commit index: %llu"
+
+ER_CONSENSUS_STATE_FOLLOWER_CHANGE_TERM
+  eng "Consensus state follower changed term, term: %llu"
+
+ER_CONSENSUS_COMMIT_POSITION_WAIT
+  eng "Consensus commit advance thread wait for the commit index update, term: %llu, commit index: %llu."
+
+ER_CONSENSUS_COMMIT_POSITION_ADVANCED
+  eng "Consensus commit advance thread updated the commit position, log file: '%s', pos: %llu, term: %llu, commit index: %llu."
+
+ER_CONSENSUS_COMMIT_INDEX_ADVANCED
+  eng "Consensus commit index advanced, commit index: %llu, local system log index: %llu."
+
+ER_CONSENSUS_LOCAL_SYSTEM_LOG_WRITTED
+  eng "Consensus writed local system log, index: %llu, commit index: %llu."
+
+ER_CONSENSUS_APPLIER_THREAD_START
+  eng "Consensus applier thread start, recover status: %lld, consensus start apply index: %llu, rli consensus index: %llu."
+
+ER_CONSENSUS_APPLIER_THREAD_STOP
+  eng "Consensus applier thread is terminated because of %s"
+
+ER_CONSENSUS_MTS_GROUP_RECOVERY_APPLIER_INFO_FOR_WORKER
+  eng "Consensus MTS group recovery applier info based on Worker-Id: %lu, group_relay_log_name: %s, group_relay_log_pos: %llu, consensus_apply_index: %llu."
+
+ER_CONSENSUS_APPLIER_START_POS
+  eng "Consensus applier start position, log file: '%s', pos: %llu, apply index: %llu."
+
+ER_CONSENSUS_APPLIER_CATCHUP
+  eng "Consensus applier reach stop position, consensus index: %llu, current term: %llu, stop term: %llu."
+
+ER_CONSENSUS_CREATE_METADATA_ERROR
+  eng "Failed to create metadata '%s': %s."
+
+ER_CONSENSUS_WRITE_METADATA_ERROR
+  eng "Failed to write consensus meta '%s'"
+
+ER_CONSENSUS_READ_METADATA_ERROR
+  eng "Failed to read consensus meta '%s'"
+
+ER_CONSENSUS_CHANGE_META_LOG
+  eng "Force change consensus meta successfully"
+
+ER_CONSENSUS_CHANGE_META_ERROR
+  eng "Failed to change consensus meta, because %s"
+
+ER_CONSENSUS_META_CREATE_OBJECT_STORE_ERROR
+  eng "Failed to create object store for cluster info, provider: %s, region: %s, endpoint:%s, use_https: %s, error: %s."
+
+ER_CONSENSUS_META_PUT_OBJECT_STORE_ERROR
+  eng "Failed to put object store for cluster info, bucket: %s, key: %s, error: %s."
+
+ER_CONSENSUS_META_GET_OBJECT_STORE_ERROR
+  eng "Failed to get object store for cluster info, bucket: %s, key: %s, error: %s."
+
+ER_CONSENSUS_META_MALFORMED_CLUSTER_INFO_ERROR
+  eng "Found malformed cluster info on objectsotre, bucket: %s, key: %s, error: %s."
+
+ER_CONSENSUS_CREATE_THRERD_ERROR
+  eng "Failed to create thread: %s."
+
+ER_CONSENSUS_THREAD_STARTED
+  eng "Consensus %s thread started"
+
+ER_CONSENSUS_THREAD_STOPPED
+  eng "Consensus %s thread was terminated because of %s"
+
+ER_CONSENSUS_SERVER_NOT_READY
+  eng "The server is not allowed to do current operation."
+
+ER_CONSENSUS_LOG_FLUSH_CACHE_ERROR
+  eng "Failed to flush binlog cache to the consensus log, because %s."
+
+ER_CONSENSUS_LOG_WRITE_CONSENSUS_EVENT_FAILED
+  eng "Failed to write a consensus log event"
+
+ER_CONSENSUS_LOG_WRITE_LARGE_EVENT
+  eng "Write a large event, event size: %llu, batches: %lu, current progress: %llu/%llu"
+
+ER_CONSENSUS_LOG_WRITE_EMPYT_LOG
+  eng "Write an empty entry for large event, current pos: %llu, empty log size: %lu, batch size: %llu, consensus_index: %llu, current event progress: %llu/%llu"
+
+ER_CONSENSUS_LOG_WRITE_LARGE_EVENT_PAYLOAD
+  eng "Write the payload entry for large event, current pos: %llu, batch size: %llu, payload start pos: %llu, payload size: %llu, consensus index: %llu, current progress: %llu/%llu"
+
+ER_CONSENSUS_LOG_WRITE_LARGE_TRX_ENTRY
+  eng "Write one entry for large transaction, current pos: %llu, batch_size %llu, index: %llu, current progress: %llu/%llu.",
+
+ER_CONSENSUS_LOG_WRITE_LARGE_TRX_END_ENTRY
+  eng "Write the end entry for large transaction, current pos: %llu, batch_size %llu, index: %llu.",
+
+ER_CONSENSUS_LOG_APPEND_LARGE_EVENT_END_ENTRY
+  eng "Append the whole event to consensus log for the large event, size: %llu"
+
+ER_CONSENSUS_LOG_APPEND_ONE_ENTRY_ERROR
+  eng "Failed to appen one log entry to the consensus log, because %s."
+
+ER_CONSENSUS_LOG_APPEND_TERM_MISMATCH
+  eng "Failed to append a consensus entry because of term mismatch, current term: %llu, entry term: %llu."
+
+ER_CONSENSUS_LOG_APPEND_INDEX_MISMATCH
+  eng "Failed to append a consensus entry because of index mismatch, current index: %llu, entry index: %llu."
+
+ER_CONSENSUS_FAILPOINT_ACTIVE
+  eng "Consensus libary failpoint '%s' is going to activate, type: %d, exec_count: %d, input_type: %d, probability: %1.2f"
+
+ER_COSENNSUS_FAILPOINT_DEACTIVE
+  eng "Consensus libary failpoint '%s' is going to deactivate"
+
+ER_CONSENSUS_LOG_RUN_PREFETCH
+  eng "Consensus log prefetch thread try to fetch, channel: %llu, index: %llu"
+
+ER_CONSENSUS_LOG_PREFETCH_ONE_ENTRY
+  eng "Consensus log prefetch thread fetch a valid log entry, channel: %llu, request index: %llu"
+
+ER_CONSENSUS_LOG_FINISH_PREFETCH
+  eng "Consensus log prefetch for channel %llu has reached the consensus index %llu"
+
+ER_CONSENSUS_LOG_PREFETCH_ERROR
+  eng "Failed to prefetch consensus logs in file '%s', consensus index: %llu, start index: %llu"
+
+ER_CONSENSUS_LOG_PREFETCH_STOPPED
+  eng "Consensus log prefetch has stopped, channel_id: %llu, stop_prefetch_flag: %d, from_beginning: %d"
+
+ER_CONSENSUS_LOG_PREFETCH_CACHE_ADD_OUT_OF_RANGE
+  eng "The consensus log to be added is not in the current prefetch cache range, channel_id: %llu, the first index: %llu, the last index: %llu, the required index: %llu"
+
+ER_CONSENSUS_LOG_PREFETCH_CACHE_SHRINK
+  eng "Consensus log prefetch is full but still within the window. Shrunk the window temporarily. channel_id: %llu, the first index: %llu, the last index: %llu, the required index: %llu, the last request index: %llu"
+
+ER_CONSENSUS_LOG_PREFETCH_CACHE_HIT_LARGE_TRX_TABLE
+  eng "Getting the consensus log from the prefetch cache's large trx table, index: %llu"
+
+ER_CONSENSUS_LOG_PREFETCH_CACHE_SWAP_OUT
+  eng "The consensus log to be accessed has already been swapped out of the prefetch cache, channel_id %llu, the first index: %llu, the required index: %llu"
+
+ER_CONSENSUS_LOG_PREFETCH_CACHE_OUT_OF_RANGE
+  eng "The consensus log to be accessed is out of range in the prefetch cache, channel_id: %llu, the last index: %llu, the required index: %llu"
+
+ER_CONSENSUS_LOG_PREFETCH_CACHE_TRUNCATE
+  eng "Consensus prefetch cache %s truncate, channel_id: %llu, the first index of cache: %llu, the cache size: %u"
+
+ER_CONSENSUS_FIFO_CACHE_OUT_OF_RANGE
+  eng "Consensus log FIFO cache out of range, the max index: %llu, the required index: %llu"
+
+ER_CONSENSUS_FIFO_CACHE_TRUNCATE
+  eng "Consensus log FIFO cache %s truncate, the first index of cache: %llu, the cache size: %u"
+
+ER_CONSENSUS_FIFO_CACHE_SET_BLOB_INDEX
+  eng "Consensus log FIFO cache set lock_blob_index to %llu"
+
+ER_OBJSTORE_ID_CHECK_ERROR
+  eng "Failed to verify the ID of data directory in the object store with the specified repo_objectstore_id: %s"
+
+ER_BINLOG_ARCHIVE_LOG
+  eng "Binlog archive: %s."
+
+ER_BINLOG_ARCHIVE_WORKER_LOG
+  eng "Binlog archive worker %d: %s."
+
+ER_BINLOG_ARCHIVE_UPDATE_INDEX_WORKER_LOG
+  eng "Binlog archive update index worker: %s."
+
+ER_BINLOG_ARCHIVE_STARTUP
+  eng "Binlog archive startup: %s."
+
+ER_BINLOG_ARCHIVE_CREATE_OBJECT_STORE
+  eng "Binlog archive create object store: provider=%s region=%s endpoint=%s bucket=%s use_https=%s %s."
+
+ER_BINLOG_ARCHIVE_GET_OBJECT_TO_FILE
+  eng "Binlog archive get object: %s key=%s file=%s %s."
+
+ER_BINLOG_ARCHIVE_PUT_OBJECT_FROM_BINLOG_SLICE_FILE
+  eng "Binlog archive put binlog slice to object store: key=%s file=%s size=%lld %s."
+
+ER_BINLOG_ARCHIVE_PUT_OBJECT_FROM_BINLOG_INDEX_FILE
+  eng "Binlog archive put binlog index to object store: key=%s index_entry=%s %s."
+
+ER_BINLOG_ARCHIVE_LIST_OBJECT
+  eng "Binlog archive list object: %s key_prefix=%s %s."
+
+ER_BINLOG_ARCHIVE_OPEN_INDEX
+  eng "Binlog archive open index: %s  index=%s."
+
+ER_BINLOG_ARCHIVE_OPEN_INDEX_TERM_CHANGED
+  eng "Binlog archive open index term changed: %lld to %lld."
+
+ER_BINLOG_ARCHIVE_LOG_START
+  eng "Binlog archive: persistent mysql binlog %s/%lld"
+
+ER_BINLOG_ARCHIVE_LOG_SLICE
+  eng "Binlog archive: persistent binlog slice %s"
+
+ER_BINLOG_ARCHIVE_PURGE_LOG
+  eng "Binlog archive: purge persistent binlog %s"
+
+ER_CONSISTENT_SNAPSHOT_LOG
+   eng "Snapshot archive: %s"
+
+ER_CONSISTENT_SNAPSHOT_ARCHIVE_THREAD_LOG
+   eng "Snapshot archive thread: %s"
+
+ER_CONSISTENT_SNAPSHOT_ARCHIVE_INNODB_LOG
+   eng "Snapshot archive innodb: %s"
+
+ER_CONSISTENT_SNAPSHOT_ARCHIVE_SMARTENGINE_LOG
+   eng "Snapshot archive smartengine: %s"
+
+ER_CONSISTENT_SNAPSHOT_ARCHIVE_BINLOG_LOG
+   eng "Snapshot archive binlog: %s"
+
+ER_CONSISTENT_SNAPSHOT_PURGE_LOG
+   eng "Snapshot archive purge: %s"
+
+ER_CONSISTENT_SNAPSHOT_ARCHIVE_INDEX_LOG
+   eng "Snapshot archive index: %s"
+
+ER_CONSISTENT_RECOVERY_LOG
+  eng "Snapshot recovery: %s"
+
+ER_CONSISTENT_RECOVERY_GET_LAST_BINLOG_CONSENSUS_INDEX_LOG
+  eng "Snapshot recovery get last persistent binlog consensus index: %s."
+
+ER_FORCE_DEFAULT_STORAGE_ENGINE_TO_SMARTENGINE
+  eng "Force to use smartengine as default storage engine in serverless mode, not %s."
+
+#
+# End of WeSQL error messages intended to be logged to the server error log.
+#
+
 ################################################################################
 # Error numbers 50000 to 51999 are reserved. Please do not use them for
 # other error messages.
diff --git a/sql/CMakeLists.txt b/sql/CMakeLists.txt
index 4691f507e46..d391e5532f9 100644
--- a/sql/CMakeLists.txt
+++ b/sql/CMakeLists.txt
@@ -633,7 +633,25 @@ SET(SQL_SHARED_SOURCES
   xa/transaction_cache.cc
   xa/xid_extract.cc
   daemon_proxy_keyring/daemon_proxy_keyring.cc
+)
+
+IF(WITH_WESQL)
+  LIST(APPEND SQL_SHARED_SOURCES
+    common/component.cc
+    package/package.cc
+    package/package_cache.cc
+    package/package_common.cc
+    package/proc.cc
+    package/package_parse.cc
+    package/proc_dummy.cc
+    package/show_native_procedure.cc
   )
+  IF(WITH_RAFT_REPLICATION)
+    LIST(APPEND SQL_SHARED_SOURCES
+      rpl_consensus_replication.cc
+    )
+  ENDIF()
+ENDIF()
 
 IF(BUILD_IS_SINGLE_CONFIG)
   GET_PROPERTY(CWD_DEFINITIONS DIRECTORY PROPERTY COMPILE_DEFINITIONS)
@@ -1003,6 +1021,8 @@ SET(BINLOG_SOURCE
   binlog/monitoring/context.cc
   binlog/decompressing_event_object_istream.cc
   binlog.cc
+  binlog_archive.cc
+  binlog_archive_command.cc
   binlog_istream.cc
   binlog_ostream.cc
   binlog_reader.cc
@@ -1011,6 +1031,10 @@ SET(BINLOG_SOURCE
   changestreams/misc/column_filters/column_filter_inbound_func_indexes.cc
   changestreams/misc/column_filters/column_filter_inbound_gipk.cc
   changestreams/misc/column_filters/column_filter_outbound_func_indexes.cc
+  consistent_archive.cc
+  consistent_recovery.cc
+  consistent_snapshot_purge_command.cc
+  consistent_snapshot_force_command.cc
   log_event.cc
   rpl_commit_stage_manager.cc
   rpl_filter.cc
@@ -1089,6 +1113,16 @@ SET (RPL_REPLICA_SRCS
   udf_service_impl.cc
   udf_service_util.cc
   )
+
+IF(WITH_RAFT_REPLICATION)
+  LIST(APPEND RPL_REPLICA_SRCS
+    consensus/consensus_info.cc
+    consensus/consensus_info_factory.cc
+    consensus/consensus_applier_info.cc
+    consensus/consensus_applier_worker.cc
+  )
+ENDIF()
+
 ADD_LIBRARY(rpl_replica STATIC ${RPL_REPLICA_SRCS})
 ADD_DEPENDENCIES(rpl_replica GenError)
 TARGET_LINK_LIBRARIES(rpl_replica
diff --git a/sql/basic_istream.cc b/sql/basic_istream.cc
index 398fdaf31da..9cc73ae195d 100644
--- a/sql/basic_istream.cc
+++ b/sql/basic_istream.cc
@@ -26,6 +26,23 @@
 #include <mysql/psi/mysql_file.h>
 #include "my_dbug.h"
 
+#ifdef WESQL_CLUSTER
+ssize_t IO_cache_istream::read(unsigned char *buffer, size_t length) {
+  DBUG_ENTER("IO_CACHE_istream::read");
+  if (my_b_read(m_io_cache, buffer, length) ||
+      DBUG_EVALUATE_IF("simulate_magic_header_io_failure", 1, 0))
+    DBUG_RETURN(m_io_cache->error);
+  DBUG_RETURN(static_cast<longlong>(length));
+}
+
+bool IO_cache_istream::open() {
+  if (reinit_io_cache(m_io_cache, READ_CACHE, 0, false, false)) {
+    return true;
+  }
+  return false;
+}
+#endif
+
 IO_CACHE_istream::IO_CACHE_istream() = default;
 
 IO_CACHE_istream::~IO_CACHE_istream() { close(); }
diff --git a/sql/basic_istream.h b/sql/basic_istream.h
index 5e20e06024e..5d5eebbcb4a 100644
--- a/sql/basic_istream.h
+++ b/sql/basic_istream.h
@@ -50,6 +50,27 @@ class Basic_istream {
   virtual ~Basic_istream() = default;
 };
 
+#ifdef WESQL_CLUSTER
+/**
+   The abstract class for input streams which are based on IO_CACHE.
+*/
+class IO_cache_istream : public Basic_istream {
+ public:
+  IO_cache_istream(IO_CACHE *io_cache) : m_io_cache(io_cache) {}
+
+  /* Open the stream. Reinit IO_CACHE. */
+  bool open();
+
+  /* Closes the stream. */
+  void close() {}
+
+  ssize_t read(unsigned char *buffer, size_t length) override;
+
+ private:
+  IO_CACHE *m_io_cache;
+};
+#endif
+
 /**
    The abstract class for seekable input streams which have fixed length
    and provide seek operation.
@@ -119,7 +140,6 @@ class IO_CACHE_istream : public Basic_seekable_istream {
      Get the length of the file.
   */
   my_off_t length() override;
-
  private:
   IO_CACHE m_io_cache;
 };
diff --git a/sql/binlog.cc b/sql/binlog.cc
index de76909ed3b..f9f14586ae3 100644
--- a/sql/binlog.cc
+++ b/sql/binlog.cc
@@ -40,6 +40,7 @@
 #include "my_thread.h"
 #include "sql/check_stack.h"
 #include "sql/clone_handler.h"
+#include "sql/consistent_recovery.h"
 #include "sql/raii/thread_stage_guard.h"
 #include "sql_string.h"
 #include "template_utils.h"
@@ -85,6 +86,7 @@
 #include "partition_info.h"
 #include "prealloced_array.h"
 #include "scope_guard.h"
+#include "sql/binlog_archive.h"
 #include "sql/binlog/decompressing_event_object_istream.h"
 #include "sql/binlog/global.h"
 #include "sql/binlog/group_commit/bgc_ticket_manager.h"  // Bgc_ticket_manager
@@ -547,6 +549,16 @@ class MYSQL_BIN_LOG::Binlog_ofile : public Basic_ostream {
     return false;
   }
 
+#ifdef WESQL_CLUSTER
+  bool seek(my_off_t offset) {
+    assert(m_pipeline_head != nullptr);
+
+    if (m_pipeline_head->seek(offset)) return true;
+    m_position = offset;
+    return false;
+  }
+#endif
+
   bool flush() { return m_pipeline_head->flush(); }
   bool sync() { return m_pipeline_head->sync(); }
   bool flush_and_sync() { return flush() || sync(); }
@@ -1746,6 +1758,14 @@ bool MYSQL_BIN_LOG::write_transaction(THD *thd, binlog_cache_data *cache_data,
   DBUG_PRINT("info",
              ("transaction_length= %llu", gtid_event.transaction_length));
 
+#ifdef WESQL_CLUSTER
+  if (!NO_HOOK(binlog_manager)) {
+    return RUN_HOOK(
+        binlog_manager, write_transaction,
+        (thd, this, &gtid_event, cache_data, writer->is_checksum_enabled()));
+  }
+#endif
+
   bool ret = gtid_event.write(writer);
   if (ret) goto end;
 
@@ -1777,8 +1797,12 @@ int MYSQL_BIN_LOG::gtid_end_transaction(THD *thd) {
 
   if (thd->owned_gtid.sidno > 0) {
     assert(thd->variables.gtid_next.type == ASSIGNED_GTID);
-
-    if (!opt_bin_log || (thd->slave_thread && !opt_log_replica_updates)) {
+    if (!opt_bin_log ||
+#ifdef WESQL_CLUSTER
+        (thd->slave_thread &&
+         thd->consensus_context.consensus_replication_applier) ||
+#endif
+        (thd->slave_thread && !opt_log_replica_updates)) {
       /*
         If the binary log is disabled for this thread (either by
         log_bin=0 or sql_log_bin=0 or by log_replica_updates=0 for a
@@ -3202,13 +3226,23 @@ bool purge_source_logs_to_file(THD *thd, const char *to_log) {
     case Shared_backup_lock_guard::Lock_result::oom:
       return purge_error_message(thd, LOG_INFO_MEM);
   }
-
+  
   char search_file_name[FN_REFLEN];
   constexpr auto auto_purge{false};
   constexpr auto include_to_log{false};
   constexpr auto need_index_lock{true};
   constexpr auto need_update_threads{true};
   mysql_bin_log.make_log_name(search_file_name, to_log);
+
+#ifdef WESQL_CLUSTER
+  if (!NO_HOOK(binlog_manager)) {
+    auto purge_error =
+        RUN_HOOK(binlog_manager, purge_logs, (0, 0, search_file_name, false));
+    if (!purge_error) my_ok(thd);
+    return purge_error != 0;
+  }
+#endif
+
   auto purge_error = mysql_bin_log.purge_logs(
       search_file_name, include_to_log, need_index_lock, need_update_threads,
       nullptr, auto_purge);
@@ -3243,6 +3277,15 @@ bool purge_source_logs_before_date(THD *thd, time_t purge_time) {
       return purge_error_message(thd, LOG_INFO_MEM);
   }
 
+#ifdef WESQL_CLUSTER
+  if (!NO_HOOK(binlog_manager)) {
+    auto purge_error =
+        RUN_HOOK(binlog_manager, purge_logs, (purge_time, 0, nullptr, false));
+    if (!purge_error) my_ok(thd);
+    return purge_error != 0;
+  }
+#endif
+
   // purge
   constexpr auto auto_purge{false};
   auto purge_error =
@@ -3365,6 +3408,9 @@ bool show_binlog_events(THD *thd, MYSQL_BIN_LOG *binary_log) {
   DBUG_TRACE;
 
   assert(thd->lex->sql_command == SQLCOM_SHOW_BINLOG_EVENTS ||
+#ifdef WESQL_CLUSTER
+         thd->lex->sql_command == SQLCOM_SHOW_CONSENSUSLOG_EVENTS ||
+#endif
          thd->lex->sql_command == SQLCOM_SHOW_RELAYLOG_EVENTS);
 
   if (binary_log->is_open()) {
@@ -3515,6 +3561,10 @@ MYSQL_BIN_LOG::MYSQL_BIN_LOG(uint *sync_period, bool relay_log)
       sync_period_ptr(sync_period),
       sync_counter(0),
       is_relay_log(relay_log),
+#ifdef WESQL_CLUSTER
+      is_consensus_log(false),    // used by consensus module
+      is_consensus_write(false),  // writed by consensus module
+#endif
       checksum_alg_reset(binary_log::BINLOG_CHECKSUM_ALG_UNDEF),
       relay_log_checksum_alg(binary_log::BINLOG_CHECKSUM_ALG_UNDEF),
       previous_gtid_set_relaylog(nullptr),
@@ -4263,6 +4313,10 @@ static enum_read_gtids_from_binlog_status read_gtids_from_binlog(
     switch (ev->get_type_code()) {
       case binary_log::FORMAT_DESCRIPTION_EVENT:
       case binary_log::ROTATE_EVENT:
+#ifdef WESQL_CLUSTER
+      case binary_log::PREVIOUS_CONSENSUS_INDEX_LOG_EVENT:
+      case binary_log::CONSENSUS_LOG_EVENT:
+#endif
         // do nothing; just accept this event and go to next
         break;
       case binary_log::PREVIOUS_GTIDS_LOG_EVENT: {
@@ -4555,7 +4609,7 @@ bool MYSQL_BIN_LOG::init_gtid_sets(Gtid_set *all_gtids, Gtid_set *lost_gtids,
 
   Checkable_rwlock *sid_lock =
       is_relay_log ? all_gtids->get_sid_map()->get_sid_lock() : global_sid_lock;
-  /*
+/*
     If this is a relay log, we must have the IO thread Master_info trx_parser
     in order to correctly feed it with relay log events.
   */
@@ -4910,6 +4964,17 @@ bool MYSQL_BIN_LOG::open_binlog(
 
   Format_description_log_event s;
 
+#ifdef WESQL_CLUSTER
+  if (!is_relay_log && !NO_HOOK(binlog_manager)) {
+    if (RUN_HOOK(binlog_manager, new_file,
+                 (this, log_file_name, null_created_arg, need_sid_lock,
+                  extra_description_event, write_file_name_to_index_file))) {
+      goto err;
+    }
+    goto after_init_file;
+  }
+#endif
+
   if (m_binlog_file->is_empty()) {
     /*
       The binary log file was empty (probably newly created)
@@ -5061,6 +5126,10 @@ bool MYSQL_BIN_LOG::open_binlog(
   }
   if (m_binlog_file->flush_and_sync()) goto err;
 
+#ifdef WESQL_CLUSTER
+after_init_file:
+#endif
+
   if (write_file_name_to_index_file) {
     DBUG_EXECUTE_IF("crash_create_critical_before_update_index",
                     DBUG_SUICIDE(););
@@ -5935,6 +6004,7 @@ int MYSQL_BIN_LOG::purge_logs(const char *to_log, bool included,
   bool exit_loop = false;
   LOG_INFO log_info;
   THD *thd = current_thd;
+  LOG_INFO last_persisted_log_info;
   DBUG_TRACE;
   DBUG_PRINT("info", ("to_log= %s", to_log));
 
@@ -5958,6 +6028,32 @@ int MYSQL_BIN_LOG::purge_logs(const char *to_log, bool included,
     goto err;
   }
 
+  if (opt_serverless && opt_binlog_archive) {
+    Binlog_archive *binlog_archive = Binlog_archive::get_instance();
+    mysql_mutex_t *binlog_archive_lock =
+        binlog_archive->get_binlog_archive_lock();
+    mysql_mutex_lock(binlog_archive_lock);
+    if (!binlog_archive->is_thread_running()) {
+      mysql_mutex_unlock(binlog_archive_lock);
+      if (!auto_purge)
+        push_warning_printf(
+            thd, Sql_condition::SL_WARNING,
+            ER_WARN_PURGE_LOG_IN_BINLOG_ARCHIVE_NOT_RUNNING,
+            ER_THD(thd, ER_WARN_PURGE_LOG_IN_BINLOG_ARCHIVE_NOT_RUNNING),
+            to_log);
+      goto err;
+    }
+    mysql_mutex_unlock(binlog_archive_lock);
+    binlog_archive->get_mysql_current_archive_binlog(&last_persisted_log_info,
+                                                     true);
+    if (last_persisted_log_info.log_file_name[0] == '\0') {
+      if (!auto_purge)
+        push_warning_printf(
+            thd, Sql_condition::SL_WARNING, ER_WARN_PURGE_LOG_NOT_PERSISTED,
+            ER_THD(thd, ER_WARN_PURGE_LOG_NOT_PERSISTED), to_log);
+      goto err;
+    }
+  }
   /*
     File name exists in index file; delete until we find this file
     or a file that is used.
@@ -5967,6 +6063,18 @@ int MYSQL_BIN_LOG::purge_logs(const char *to_log, bool included,
 
   while ((compare_log_name(to_log, log_info.log_file_name) ||
           (exit_loop = included))) {
+    if (opt_serverless && opt_binlog_archive) {
+      // If binlog_archive is enabled, check if log file is persisted by
+      // binlog_archive thread before purging it.
+      if (compare_log_name(last_persisted_log_info.log_file_name,
+                           log_info.log_file_name) > 0) {
+        if (!auto_purge)
+          push_warning_printf(
+              thd, Sql_condition::SL_WARNING, ER_WARN_PURGE_LOG_NOT_PERSISTED,
+              ER_THD(thd, ER_WARN_PURGE_LOG_NOT_PERSISTED), to_log);
+        break;
+      }
+    }
     if (is_active(log_info.log_file_name)) {
       if (!auto_purge)
         push_warning_printf(
@@ -6009,6 +6117,14 @@ int MYSQL_BIN_LOG::purge_logs(const char *to_log, bool included,
     goto err;
   }
 
+#ifdef WESQL_CLUSTER
+  if (!is_relay_log && !NO_HOOK(binlog_manager)) {
+    error = RUN_HOOK(binlog_manager, after_purge_file,
+                     (this, log_info.log_file_name));
+    goto err;
+  }
+#endif
+
   // Update gtid_state->lost_gtids
   if (!is_relay_log) {
     global_sid_lock->wrlock();
@@ -6540,7 +6656,11 @@ int MYSQL_BIN_LOG::new_file_impl(
     goto end;
   }
 
-  if (!is_relay_log) {
+  if (!is_relay_log
+#ifdef WESQL_CLUSTER
+      && !is_consensus_write
+#endif
+  ) {
     /* Save set of GTIDs of the last binlog into table on binlog rotation */
     if ((error = gtid_state->save_gtids_of_last_binlog_into_table())) {
       if (error == ER_RPL_GTID_TABLE_CANNOT_OPEN) {
@@ -6607,6 +6727,11 @@ int MYSQL_BIN_LOG::new_file_impl(
     Rotate_log_event r(new_name + dirname_length(new_name), 0, LOG_EVENT_OFFSET,
                        is_relay_log ? Rotate_log_event::RELAY_LOG : 0);
 
+#ifdef WESQL_CLUSTER
+    // don't be ignored by slave SQL thread
+    if (is_consensus_log) r.server_id = 0;
+#endif
+
     if (DBUG_EVALUATE_IF("fault_injection_new_file_rotate_event", (error = 1),
                          false) ||
         (error = write_event_to_binlog(&r))) {
@@ -6864,6 +6989,24 @@ bool MYSQL_BIN_LOG::truncate_update_log_file(const char *log_name,
   return true;
 }
 
+bool update_log_file_set_flag_in_use(const char *log_name, bool in_use) {
+  std::unique_ptr<MYSQL_BIN_LOG::Binlog_ofile> ofile(
+      MYSQL_BIN_LOG::Binlog_ofile::open_existing(key_file_binlog, log_name, MYF(MY_WME)));
+
+  if (!ofile) {
+    LogErr(ERROR_LEVEL, ER_BINLOG_CANT_OPEN_CRASHED_BINLOG);
+    return false;
+  }
+
+  uchar flags = in_use ? 1 : 0;
+  if (ofile->update(&flags, 1, BIN_LOG_HEADER_SIZE + FLAGS_OFFSET)) {
+    LogErr(ERROR_LEVEL, ER_BINLOG_CANT_CLEAR_IN_USE_FLAG_FOR_CRASHED_BINLOG);
+    return false;
+  }
+
+  return true;
+}
+
 bool MYSQL_BIN_LOG::write_event(Log_event *ev, Master_info *mi) {
   DBUG_TRACE;
 
@@ -7198,6 +7341,14 @@ void MYSQL_BIN_LOG::auto_purge_at_server_startup() {
 
   auto purge_time = calculate_auto_purge_lower_time_bound();
   constexpr auto auto_purge{true};
+
+#ifdef WESQL_CLUSTER
+  if (!NO_HOOK(binlog_manager)) {
+    (void)RUN_HOOK(binlog_manager, purge_logs, (purge_time, 0, nullptr, true));
+    return;
+  }
+#endif
+
   purge_logs_before_date(purge_time, auto_purge);
 }
 
@@ -7249,6 +7400,14 @@ void MYSQL_BIN_LOG::auto_purge() {
     is persisted inside storage engines.
   */
   ha_flush_logs();
+
+#ifdef WESQL_CLUSTER
+  if (!NO_HOOK(binlog_manager)) {
+    (void)RUN_HOOK(binlog_manager, purge_logs, (purge_time, 0, nullptr, true));
+    return;
+  }
+#endif
+
   purge_logs_before_date(purge_time, auto_purge);
 }
 
@@ -7534,13 +7693,13 @@ bool MYSQL_BIN_LOG::write_incident(Incident_log_event *ev, THD *thd,
       cache_mngr->stmt_cache.reset();
       return error;
     }
-
+    
     if (need_lock_log)
       mysql_mutex_lock(&LOCK_log);
     else
       mysql_mutex_assert_owner(&LOCK_log);
-  }
-
+    }
+  
   if (do_flush_and_sync) {
     if (!error && !(error = flush_and_sync())) {
       bool check_purge = false;
@@ -7935,6 +8094,11 @@ int MYSQL_BIN_LOG::open_binlog(const char *opt_name) {
     return 1;
   }
 
+#ifdef WESQL_CLUSTER
+  if (!NO_HOOK(binlog_manager))
+    return (RUN_HOOK(binlog_manager, binlog_recovery, (this)));
+#endif
+
   if (using_heuristic_recover()) {
     /* generate a new binlog to mask a corrupted one */
     mysql_mutex_lock(&LOCK_log);
@@ -8184,6 +8348,15 @@ TC_LOG::enum_result MYSQL_BIN_LOG::commit(THD *thd, bool all) {
   if (cache_mngr == nullptr) {
     if (!skip_commit && trx_coordinator::commit_in_engines(thd, all))
       return RESULT_ABORTED;
+#ifdef WESQL_CLUSTER
+    /* The consensus_replication_applier will not write binlog after applying
+     event and it will lost binlogged flag for xa prepare event.  */
+    else if (skip_commit && thd->slave_thread &&
+             thd->consensus_context.consensus_replication_applier) {
+      trx_coordinator::set_prepared_in_tc_in_engines(thd, all);
+      thd->get_transaction()->xid_state()->set_binlogged();
+    }
+#endif
     return RESULT_SUCCESS;
   }
 
@@ -8399,6 +8572,15 @@ TC_LOG::enum_result MYSQL_BIN_LOG::commit(THD *thd, bool all) {
     if (trx_coordinator::commit_in_engines(thd, all))
       return RESULT_INCONSISTENT;
   }
+#ifdef WESQL_CLUSTER
+  /* The consensus_replication_applier will not write binlog after applying
+   event and it will lost binlogged flag for xa prepare event.  */
+  else if (thd->slave_thread &&
+           thd->consensus_context.consensus_replication_applier) {
+    trx_coordinator::set_prepared_in_tc_in_engines(thd, all);
+    thd->get_transaction()->xid_state()->set_binlogged();
+  }
+#endif
 
   return RESULT_SUCCESS;
 }
@@ -8600,6 +8782,13 @@ void MYSQL_BIN_LOG::process_commit_stage_queue(THD *thd, THD *first) {
       m_dependency_tracker.update_max_committed(head);
       mysql_mutex_unlock(&LOCK_replica_trans_dep_tracker);
     }
+
+#ifdef WESQL_CLUSTER
+    /* before_finish_in_engines failed, ignore commit in engines */
+    if (RUN_HOOK(binlog_manager, before_finish_in_engines, (head, false)))
+      continue;
+#endif
+
     /*
       Flush/Sync error should be ignored and continue
       to commit phase. And thd->commit_error cannot be
@@ -8608,6 +8797,7 @@ void MYSQL_BIN_LOG::process_commit_stage_queue(THD *thd, THD *first) {
     assert(head->commit_error != THD::CE_COMMIT_ERROR);
     Thd_backup_and_restore switch_thd(thd, head);
     bool all = head->get_transaction()->m_flags.real_commit;
+
     assert(!head->get_transaction()->m_flags.commit_low ||
            head->get_transaction()->m_flags.ready_preempt);
     ::finish_transaction_in_engines(head, all, false);
@@ -8624,6 +8814,15 @@ void MYSQL_BIN_LOG::process_commit_stage_queue(THD *thd, THD *first) {
 
   for (THD *head = first; head; head = head->next_to_commit) {
     Thd_backup_and_restore switch_thd(thd, head);
+
+#ifdef WESQL_CLUSTER
+    /* before_finish_in_engines failed, ignore set prepared in engines */
+    if (RUN_HOOK(binlog_manager, before_finish_in_engines, (head, false))) {
+      if (head->get_transaction()->m_flags.xid_written) dec_prep_xids(head);
+      continue;
+    }
+#endif
+
     auto all = head->get_transaction()->m_flags.real_commit;
     // Mark transaction as prepared in TC, if applicable
     trx_coordinator::set_prepared_in_tc_in_engines(head, all);
@@ -8780,7 +8979,17 @@ int MYSQL_BIN_LOG::finish_commit(THD *thd) {
   auto all = thd->get_transaction()->m_flags.real_commit;
   auto committed_low = thd->get_transaction()->m_flags.commit_low;
 
+#ifdef WESQL_CLUSTER
+  if (RUN_HOOK(binlog_manager, before_finish_in_engines, (thd, true))) {
+    if (committed_low || is_loggable_xa_prepare(thd))
+      (void)trx_coordinator::rollback_in_engines(thd, all);
+    if (!thd->owned_gtid_is_empty()) gtid_state->update_on_rollback(thd);
+    if (thd->get_transaction()->m_flags.xid_written) dec_prep_xids(thd);
+    goto finish;
+  }
+#endif
   assert(thd->commit_error != THD::CE_COMMIT_ERROR);
+
   ::finish_transaction_in_engines(thd, all, false);
 
   // If the ordered commit didn't updated the GTIDs for this thd yet
@@ -8807,6 +9016,11 @@ int MYSQL_BIN_LOG::finish_commit(THD *thd) {
     thd->get_transaction()->m_flags.run_hooks = false;
   }
 
+#ifdef WESQL_CLUSTER
+finish:
+  (void)RUN_HOOK(binlog_manager, after_finish_commit, (thd));
+#endif
+
   DBUG_EXECUTE_IF("leaving_finish_commit", {
     const char act[] = "now SIGNAL signal_leaving_finish_commit";
     assert(!debug_sync_set_action(current_thd, STRING_WITH_LEN(act)));
@@ -8917,6 +9131,17 @@ int MYSQL_BIN_LOG::ordered_commit(THD *thd, bool all, bool skip_commit) {
   my_off_t total_bytes = 0;
   bool do_rotate = false;
 
+#ifdef WESQL_CLUSTER
+  /* run before_flush hook before assigning bgc ticket */
+  if (RUN_HOOK(binlog_manager, before_binlog_flush, (thd))) {
+    if (!skip_commit || is_loggable_xa_prepare(thd)) {
+      (void)trx_coordinator::rollback_in_engines(thd, all);
+    }
+    thd_get_cache_mngr(thd)->reset();
+    return thd->commit_error;
+  }
+#endif
+
   CONDITIONAL_SYNC_POINT_FOR_TIMESTAMP("before_assign_session_to_bgc_ticket");
   thd->rpl_thd_ctx.binlog_group_commit_ctx().assign_ticket();
 
@@ -8990,12 +9215,28 @@ int MYSQL_BIN_LOG::ordered_commit(THD *thd, bool all, bool skip_commit) {
   flush_error =
       process_flush_stage_queue(&total_bytes, &do_rotate, &wait_queue);
 
+#ifdef WESQL_CLUSTER
+  if (flush_error == 0) {
+    (void)RUN_HOOK(binlog_manager, after_queue_write, (wait_queue));
+  }
+#endif
+
   if (flush_error == 0 && total_bytes > 0)
     flush_error = flush_cache_to_file(&flush_end_pos);
   DBUG_EXECUTE_IF("crash_after_flush_binlog", DBUG_SUICIDE(););
 
   update_binlog_end_pos_after_sync = (get_sync_period() == 1);
 
+#ifdef WESQL_CLUSTER
+  bool delay_update_binlog_end_pos;
+  if (flush_error == 0) {
+    delay_update_binlog_end_pos = false;
+    (void)RUN_HOOK(binlog_manager, after_queue_flush,
+                   (wait_queue, delay_update_binlog_end_pos));
+    if (delay_update_binlog_end_pos) update_binlog_end_pos_after_sync = true;
+  }
+#endif
+
   /*
     If the flush finished successfully, we can call the after_flush
     hook. Being invoked here, we have the guarantee that the hook is
@@ -9062,6 +9303,15 @@ int MYSQL_BIN_LOG::ordered_commit(THD *thd, bool all, bool skip_commit) {
     sync_error = result.first;
   }
 
+#ifdef WESQL_CLUSTER
+  if (flush_error == 0 && sync_error == 0) {
+    delay_update_binlog_end_pos = false;
+    (void)RUN_HOOK(binlog_manager, after_queue_sync,
+                   (wait_queue, delay_update_binlog_end_pos));
+    if (delay_update_binlog_end_pos) update_binlog_end_pos_after_sync = false;
+  }
+#endif
+
   if (update_binlog_end_pos_after_sync && flush_error == 0 && sync_error == 0) {
     THD *tmp_thd = final_queue;
     const char *binlog_file = nullptr;
@@ -9158,6 +9408,13 @@ commit_stage:
       mysql_mutex_unlock(leave_mutex_before_commit_stage);
     if (flush_error == 0 && sync_error == 0)
       sync_error = call_after_sync_hook(final_queue);
+
+#ifdef WESQL_CLUSTER
+    if (flush_error == 0 && sync_error == 0) {
+      (void)RUN_HOOK(binlog_manager, after_enrolling_stage,
+                     (thd, this, Commit_stage_manager::COMMIT_STAGE));
+    }
+#endif
   }
 
   /*
@@ -9198,6 +9455,15 @@ commit_stage:
     */
 
     DEBUG_SYNC(thd, "ready_to_do_rotation");
+
+#ifdef WESQL_CLUSTER
+    (void)RUN_HOOK(binlog_manager, before_rotate_and_purge,
+                   (thd, this, do_rotate));
+    if (!do_rotate) {
+      return thd->commit_error == THD::CE_COMMIT_ERROR;
+    }
+#endif
+
     bool check_purge = false;
     mysql_mutex_lock(&LOCK_log);
     /*
@@ -9211,6 +9477,10 @@ commit_stage:
       thd->commit_error = THD::CE_COMMIT_ERROR;
     else if (check_purge)
       auto_purge();
+
+#ifdef WESQL_CLUSTER
+    (void)RUN_HOOK(binlog_manager, after_rotate_and_purge, (thd, this));
+#endif
   }
   /*
     flush or sync errors are handled above (using binlog_error_action).
@@ -9369,6 +9639,16 @@ inline void MYSQL_BIN_LOG::update_binlog_end_pos(const char *file,
   unlock_binlog_end_pos();
 }
 
+#ifdef WESQL_CLUSTER
+void MYSQL_BIN_LOG::update_binlog_end_pos(my_off_t pos) {
+  lock_binlog_end_pos();
+  if (is_open() && (pos > atomic_binlog_end_pos))
+    atomic_binlog_end_pos = pos;
+  signal_update();
+  unlock_binlog_end_pos();
+}
+#endif
+
 bool THD::is_binlog_cache_empty(bool is_transactional) const {
   DBUG_TRACE;
 
@@ -11699,3 +11979,7 @@ mysql_declare_plugin(binlog){
     nullptr, /* config options                  */
     0,
 } mysql_declare_plugin_end;
+
+#ifdef WESQL_CLUSTER
+#include "sql/consensus_binlog.cc"
+#endif
diff --git a/sql/binlog.h b/sql/binlog.h
index 54ef17e6561..ff284f772ed 100644
--- a/sql/binlog.h
+++ b/sql/binlog.h
@@ -321,6 +321,11 @@ class MYSQL_BIN_LOG : public TC_LOG {
   /* This is relay log */
   bool is_relay_log;
 
+#ifdef WESQL_CLUSTER
+  bool is_consensus_log;
+  bool is_consensus_write;
+#endif
+
   uint8 checksum_alg_reset;  // to contain a new value when binlog is rotated
   /*
     Holds the last seen in Relay-Log FD's checksum alg value.
@@ -921,6 +926,41 @@ class MYSQL_BIN_LOG : public TC_LOG {
   int get_current_log(LOG_INFO *linfo, bool need_lock_log = true);
   int raw_get_current_log(LOG_INFO *linfo);
   uint next_file_id();
+#ifdef WESQL_CLUSTER
+  int init_consensus_binlog(bool null_created_arg, bool need_sid_lock,
+                            bool &write_file_name_to_index_file,
+                            uint64 current_index, uint32 &tv_sec);
+  bool open_for_consensus(PSI_file_key log_file_key, const char *log_name,
+                          bool set_flags);
+  bool open_exist_consensus_binlog(const char *log_name, ulong max_size_arg,
+                                   bool set_flags, bool need_lock_index);
+  void update_binlog_end_pos(my_off_t pos);
+  int reopen_log_index(bool need_lock_index);
+  int switch_and_seek_log(const char *file_name, my_off_t offset,
+                          bool need_lock_index = false);
+  int get_file_names(std::vector<std::string> &file_name_vector);
+  bool consensus_init_gtid_sets(Gtid_set *all_gtids, Gtid_set *lost_gtids,
+                                bool verify_checksum, bool need_lock,
+                                bool is_server_starting = false,
+                                uint64 last_index = 0,
+                                const char *log_name = nullptr);
+  int truncate_logs_from_index(const char *last_file_name,
+                               std::vector<std::string> &delete_vector);
+  int truncate_files_after(const char *file_name, bool need_lock_index = false);
+  int truncate_all_files();
+  int truncate_log(const char *file_name, my_off_t offset,
+                   Relay_log_info *rli = NULL);
+
+  int new_file_from_archive(const char *archive_log_name, bool need_lock_log);
+  bool open_binlog_from_archive(
+#ifdef HAVE_PSI_INTERFACE
+      PSI_file_key log_file_key,
+#endif
+      const char *log_name, const char *new_name, ulong max_size_arg,
+      const char *archive_log_name, bool need_lock_index);
+
+  ulonglong get_log_size();
+#endif
   /**
     Retrieves the contents of the index file associated with this log object
     into an `std::list<std::string>` object. The order held by the index file is
@@ -1163,5 +1203,21 @@ extern ulong rpl_read_size;
  */
 
 bool normalize_binlog_name(char *to, const char *from, bool is_relay_log);
-
+bool update_log_file_set_flag_in_use(const char *log_name, bool in_use);
+#ifdef WESQL_CLUSTER
+void binlog_update_end_pos(MYSQL_BIN_LOG *binlog, const char *file,
+                           my_off_t pos);
+bool binlog_write_event_directly(MYSQL_BIN_LOG *binlog, Log_event *ev);
+int truncate_binlog_file_to_valid_pos(const char *log_name, my_off_t valid_pos,
+                                      my_off_t binlog_size, bool update);
+int binlog_file_flush_and_sync(MYSQL_BIN_LOG::Binlog_ofile *binlog_file);
+my_off_t binlog_file_get_current_pos(MYSQL_BIN_LOG::Binlog_ofile *binlog_file);
+my_off_t binlog_file_get_real_size(MYSQL_BIN_LOG::Binlog_ofile *binlog_file);
+int write_buffer_to_binlog_file(MYSQL_BIN_LOG::Binlog_ofile *binlog_file,
+                                const unsigned char *buffer, my_off_t length);
+Binlog_cache_storage *binlog_cache_get_storage(binlog_cache_data *cache_data);
+size_t binlog_cache_get_event_counter(binlog_cache_data *binlog_cache);
+void update_trx_compression(binlog_cache_data *cache_data, Gtid &owned_gtid, 
+                            uint64_t immediate_commit_timestamp);
+#endif
 #endif /* BINLOG_H_INCLUDED */
diff --git a/sql/binlog/recovery.h b/sql/binlog/recovery.h
index 12781e72e2e..5098b29116d 100644
--- a/sql/binlog/recovery.h
+++ b/sql/binlog/recovery.h
@@ -147,6 +147,9 @@ class Binlog_recovery {
   Binlog_recovery &recover();
 
  private:
+#ifdef WESQL_CLUSTER
+ public:
+#endif
   /** File reader for the last available binary log file */
   Binlog_file_reader &m_reader;
   /** Position of the last binlog event that ended a transaction */
diff --git a/sql/binlog_ostream.h b/sql/binlog_ostream.h
index 84c08ffed0f..135663f8d03 100644
--- a/sql/binlog_ostream.h
+++ b/sql/binlog_ostream.h
@@ -137,6 +137,10 @@ class IO_CACHE_binlog_cache_storage : public Truncatable_ostream {
   bool flush() override { return false; }
   bool sync() override { return false; }
 
+#ifdef WESQL_CLUSTER
+  IO_CACHE *get_io_cache() { return &m_io_cache; }
+#endif
+
  private:
   IO_CACHE m_io_cache;
   my_off_t m_max_cache_size = 0;
@@ -232,6 +236,10 @@ class Binlog_cache_storage : public Basic_ostream {
   */
   bool is_empty() const { return length() == 0; }
 
+#ifdef WESQL_CLUSTER
+  IO_CACHE *get_io_cache() { return m_file.get_io_cache(); }
+#endif
+
  private:
   Truncatable_ostream *m_pipeline_head = nullptr;
   IO_CACHE_binlog_cache_storage m_file;
diff --git a/sql/binlog_reader.cc b/sql/binlog_reader.cc
index c3ffc36e21b..139b436c815 100644
--- a/sql/binlog_reader.cc
+++ b/sql/binlog_reader.cc
@@ -280,6 +280,20 @@ Binlog_read_error::Error_type binlog_event_deserialize(
     case binary_log::WRITE_ROWS_EVENT:
       ev = new Write_rows_log_event(buf, fde);
       break;
+#ifdef WESQL_CLUSTER
+    case binary_log::CONSENSUS_LOG_EVENT:
+      ev = new Consensus_log_event(buf, 0, fde);
+      break;
+    case binary_log::PREVIOUS_CONSENSUS_INDEX_LOG_EVENT:
+      ev = new Previous_consensus_index_log_event(buf, 0, fde);
+      break;
+    case binary_log::CONSENSUS_CLUSTER_INFO_EVENT:
+      ev = new Consensus_cluster_info_log_event(buf, 0, fde);
+      break;
+    case binary_log::CONSENSUS_EMPTY_EVENT:
+      ev = new Consensus_empty_log_event(buf, 0, fde);
+      break;
+#endif
     case binary_log::UPDATE_ROWS_EVENT:
       ev = new Update_rows_log_event(buf, fde);
       break;
diff --git a/sql/dd/impl/system_registry.cc b/sql/dd/impl/system_registry.cc
index df389f22337..6797ba1ced9 100644
--- a/sql/dd/impl/system_registry.cc
+++ b/sql/dd/impl/system_registry.cc
@@ -210,6 +210,11 @@ void System_tables::add_remaining_dd_tables() {
   register_table("backup_sbt_history", system);
   register_table("columns_priv", system);
   register_table("component", system);
+#ifdef WESQL
+  register_table("consensus_info", system);
+  register_table("consensus_applier_info", system);
+  register_table("consensus_applier_worker", system);
+#endif
   register_table("db", system);
   register_table("default_roles", system);
   register_table("engine_cost", system);
diff --git a/sql/dd/impl/upgrade/server.cc b/sql/dd/impl/upgrade/server.cc
index 9f222287e18..8ab9ed5ab1e 100644
--- a/sql/dd/impl/upgrade/server.cc
+++ b/sql/dd/impl/upgrade/server.cc
@@ -65,6 +65,11 @@
 #include "sql/trigger.h"  // Trigger
 #include "sql/trigger_def.h"
 
+#ifdef WESQL
+#include "scripts/sql_commands_system_tables_wesql.h"
+#include "scripts/sql_commands_system_tables_fix_wesql.h"
+#endif
+
 typedef ulonglong sql_mode_t;
 extern const char *mysql_sys_schema[];
 extern const char *fill_help_tables[];
@@ -955,5 +960,90 @@ bool I_S_upgrade_required() {
          opt_upgrade_mode == UPGRADE_FORCE;
 }
 
+#ifdef WESQL
+static bool create_wesql_tables(THD *thd) {
+  const char **query_ptr;
+
+  DBUG_EXECUTE_IF(
+      "schema_read_only",
+      if (dd::execute_query(thd, "CREATE SCHEMA schema_read_only") ||
+          dd::execute_query(thd, "ALTER SCHEMA schema_read_only READ ONLY=1") ||
+          dd::execute_query(thd, "CREATE TABLE schema_read_only.t(i INT)") ||
+          dd::execute_query(thd, "DROP SCHEMA schema_read_only") ||
+          dd::execute_query(thd, "CREATE TABLE IF NOT EXISTS S.upgrade(i INT)"))
+          assert(false););
+
+  if (ignore_error_and_execute(thd, "USE mysql")) {
+    LogErr(ERROR_LEVEL, ER_DD_UPGRADE_FAILED_FIND_VALID_DATA_DIR);
+    return true;
+  }
+
+  LogErr(INFORMATION_LEVEL, ER_SERVER_UPGRADE_MYSQL_TABLES);
+  for (query_ptr = &wesql_system_tables[0]; *query_ptr != nullptr;
+       query_ptr++)
+    if (ignore_error_and_execute(thd, *query_ptr)) return true;
+
+  return false;
+}
+
+static bool fix_wesql_tables(THD *thd) {
+  const char **query_ptr;
+
+  DBUG_EXECUTE_IF(
+      "schema_read_only",
+      if (dd::execute_query(thd, "CREATE SCHEMA schema_read_only") ||
+          dd::execute_query(thd, "ALTER SCHEMA schema_read_only READ ONLY=1") ||
+          dd::execute_query(thd, "CREATE TABLE schema_read_only.t(i INT)") ||
+          dd::execute_query(thd, "DROP SCHEMA schema_read_only") ||
+          dd::execute_query(thd, "CREATE TABLE IF NOT EXISTS S.upgrade(i INT)"))
+          assert(false););
+
+  if (ignore_error_and_execute(thd, "USE mysql")) {
+    LogErr(ERROR_LEVEL, ER_DD_UPGRADE_FAILED_FIND_VALID_DATA_DIR);
+    return true;
+  }
+
+  LogErr(INFORMATION_LEVEL, ER_SERVER_UPGRADE_MYSQL_TABLES);
+  for (query_ptr = &wesql_system_tables[0]; *query_ptr != nullptr;
+       query_ptr++)
+    if (ignore_error_and_execute(thd, *query_ptr)) return true;
+
+  LogErr(INFORMATION_LEVEL, ER_SERVER_UPGRADE_MYSQL_TABLES);
+  for (query_ptr = &wesql_system_tables_fix[0]; *query_ptr != nullptr;
+       query_ptr++)
+    if (ignore_error_and_execute(thd, *query_ptr)) return true;
+
+  return false;
+}
+
+bool initialize_wesql_schemas(THD *thd) {
+  Disable_autocommit_guard autocommit_guard(thd);
+  Bootstrap_error_handler bootstrap_error_handler;
+
+  Server_option_guard<bool> acl_guard(&opt_noacl, true);
+  Server_option_guard<bool> general_log_guard(&opt_general_log, false);
+  Server_option_guard<bool> slow_log_guard(&opt_slow_log, false);
+  Disable_binlog_guard disable_binlog(thd);
+  Disable_sql_log_bin_guard disable_sql_log_bin(thd);
+
+  bootstrap_error_handler.set_log_error(false);
+  bool err = false;
+
+  if (thd->system_thread == SYSTEM_THREAD_SERVER_INITIALIZE) {
+    sysd::notify("STATUS=WeSQL schema create in progress\n");
+    err = create_wesql_tables(thd);
+  } else if (thd->system_thread == SYSTEM_THREAD_SERVER_UPGRADE) {
+    sysd::notify("STATUS=WeSQL schema upgrade in progress\n");
+    err = fix_wesql_tables(thd);
+  }
+
+  bootstrap_error_handler.set_log_error(true);
+
+  sysd::notify("STATUS=WeSQL schema process complete\n");
+
+  return dd::end_transaction(thd, err);
+}
+#endif
+
 }  // namespace upgrade
 }  // namespace dd
diff --git a/sql/dd/upgrade/server.h b/sql/dd/upgrade/server.h
index f6b2d9a9e7f..6d141e90aa0 100644
--- a/sql/dd/upgrade/server.h
+++ b/sql/dd/upgrade/server.h
@@ -75,6 +75,10 @@ bool no_server_upgrade_required();
 
 bool I_S_upgrade_required();
 
+#ifdef WESQL
+bool initialize_wesql_schemas(THD *thd);
+#endif
+
 }  // namespace upgrade
 
 }  // namespace dd
diff --git a/sql/dd_table_share.cc b/sql/dd_table_share.cc
index facc14e5c33..3afef3a4612 100644
--- a/sql/dd_table_share.cc
+++ b/sql/dd_table_share.cc
@@ -381,6 +381,13 @@ static bool prepare_share(THD *thd, TABLE_SHARE *share,
 
         field->set_flag(PART_KEY_FLAG);
         if (key == primary_key) {
+#ifdef WITH_SMARTENGINE
+          /**For smartengine, reload ha_table_flags after pk index setup_key_part_field,
+           because handler flag HA_PRIMARY_KEY_IN_READ_INDEX may be setted. That will
+           influence add pk parts info to sk info(add_pk_parts_to_sk), which optimizer
+           use to build min-max tree for covering index.*/
+          ha_option = handler_file->ha_table_flags();
+#endif
           field->set_flag(PRI_KEY_FLAG);
           /*
              If this field is part of the primary key and all keys contains
diff --git a/sql/event_parse_data.cc b/sql/event_parse_data.cc
index 7655b7833fa..de9ad5e0b9d 100644
--- a/sql/event_parse_data.cc
+++ b/sql/event_parse_data.cc
@@ -530,8 +530,14 @@ void Event_parse_data::check_originator_id(THD *thd) {
     DBUG_PRINT("info", ("Invoked object status set to SLAVESIDE_DISABLED."));
     if ((status == Event_parse_data::ENABLED) ||
         (status == Event_parse_data::DISABLED)) {
-      status = Event_parse_data::SLAVESIDE_DISABLED;
-      status_changed = true;
+#ifdef WESQL_CLUSTER
+      if (!thd->consensus_context.consensus_replication_applier) {
+#endif
+        status = Event_parse_data::SLAVESIDE_DISABLED;
+        status_changed = true;
+#ifdef WESQL_CLUSTER
+      }
+#endif
     }
     originator = thd->server_id;
   } else
diff --git a/sql/handler.cc b/sql/handler.cc
index 64041ab330a..7cbaa1ae35a 100644
--- a/sql/handler.cc
+++ b/sql/handler.cc
@@ -1321,8 +1321,22 @@ void trans_register_ha(THD *thd, bool all, handlerton *ht_arg,
     return; /* already registered, return */
   }
 
+#ifdef WESQL_CLUSTER
+  if (thd->slave_thread &&
+      thd->consensus_context.consensus_replication_applier) {
+    ha_info->set_add_tail(ht_arg->db_type != DB_TYPE_INNODB &&
+                          ht_arg->db_type != DB_TYPE_BINLOG);
+  }
+#endif
   trn_ctx->register_ha(trx_scope, ha_info, ht_arg);
+#ifdef WESQL_CLUSTER
+  if (!thd->slave_thread ||
+      !thd->consensus_context.consensus_replication_applier) {
+    trn_ctx->set_ha_trx_info(trx_scope, ha_info);
+  }
+#else
   trn_ctx->set_ha_trx_info(trx_scope, ha_info);
+#endif
 
   if (ht_arg->prepare == nullptr) trn_ctx->set_no_2pc(trx_scope, true);
 
@@ -7962,6 +7976,23 @@ int handler::ha_reset() {
   return retval;
 }
 
+#ifdef WITH_SMARTENGINE
+bool operating_on_smartengine_during_xa(THD *thd, handlerton *hton) {
+  if (hton->db_type == DB_TYPE_SMARTENGINE) {
+    const bool PRINT_ERROR_WHEN_CHECK_IN_XA = false;
+    const bool is_in_xa = (thd->get_transaction()->xid_state()->check_in_xa(
+          PRINT_ERROR_WHEN_CHECK_IN_XA));
+    if (is_in_xa) {
+      my_error(HA_ERR_WRONG_COMMAND, MYF(0),
+          "SMARTENGINE not support XA transactions");
+    }
+    return is_in_xa;
+  } else {
+    return false;
+  }
+}
+#endif
+
 int handler::ha_write_row(uchar *buf) {
   int error;
   Log_func *log_func = Write_rows_log_event::binlog_row_logging_function;
@@ -7971,6 +8002,14 @@ int handler::ha_write_row(uchar *buf) {
   DBUG_EXECUTE_IF("inject_error_ha_write_row", return HA_ERR_INTERNAL_ERROR;);
   DBUG_EXECUTE_IF("simulate_storage_engine_out_of_memory",
                   return HA_ERR_SE_OUT_OF_MEMORY;);
+
+#ifdef WITH_SMARTENGINE
+  if (operating_on_smartengine_during_xa(ha_thd(), ht)) {
+    /**smartengine currently not support executing xa dml. */
+    return HA_ERR_UNSUPPORTED;
+  }
+#endif
+
   mark_trx_read_write();
 
   DBUG_EXECUTE_IF(
@@ -8756,6 +8795,22 @@ void ha_post_recover(void) {
                        MYSQL_STORAGE_ENGINE_PLUGIN, nullptr);
 }
 
+#ifdef WITH_SMARTENGINE
+static bool post_engine_recover_handlerton(THD *, plugin_ref plugin, void *) {
+  handlerton *hton = plugin_data<handlerton *>(plugin);
+
+  if (hton->state == SHOW_OPTION_YES && hton->post_engine_recover)
+    hton->post_engine_recover();
+
+  return false;
+}
+
+void ha_post_engine_recover(void) {
+  (void)plugin_foreach(nullptr, post_engine_recover_handlerton,
+                       MYSQL_STORAGE_ENGINE_PLUGIN, nullptr);
+}
+#endif
+
 void handler::ha_set_primary_handler(handler *primary_handler) {
   assert((ht->flags & HTON_IS_SECONDARY_ENGINE) != 0);
   assert(primary_handler->table->s->has_secondary_engine());
diff --git a/sql/handler.h b/sql/handler.h
index 8ed28d594d0..dde9d951165 100644
--- a/sql/handler.h
+++ b/sql/handler.h
@@ -204,6 +204,15 @@ enum enum_alter_inplace_result {
   HA_ALTER_INPLACE_INSTANT
 };
 
+/**smartengine hton name*/
+#ifdef WITH_SMARTENGINE
+#ifdef WITH_XENGINE_COMPATIBLE_MODE
+#define SMARTENGINE_NAME "XENGINE"
+#else 
+#define SMARTENGINE_NAME "SMARTENGINE"
+#endif // end of WITH_XENGINE_COMPATIBLE_MODE
+#endif // end of WITH_SMARTENGINE
+
 /* Bits in table_flags() to show what database can do */
 
 #define HA_NO_TRANSACTIONS (1 << 0)     /* Doesn't support transactions */
@@ -668,6 +677,9 @@ enum legacy_db_type {
   /** Performance schema engine. */
   DB_TYPE_PERFORMANCE_SCHEMA,
   DB_TYPE_TEMPTABLE,
+#ifdef WITH_SMARTENGINE
+  DB_TYPE_SMARTENGINE,
+#endif
   DB_TYPE_FIRST_DYNAMIC = 42,
   DB_TYPE_DEFAULT = 127  // Must be last
 };
@@ -2287,6 +2299,48 @@ typedef void (*post_ddl_t)(THD *thd);
 */
 typedef void (*post_recover_t)(void);
 
+#ifdef WITH_SMARTENGINE
+/** do checkpoint for storage engine
+*/
+typedef int (*checkpoint_t)(THD *thd);
+
+/** Create a backup snapshot for storage engine.
+
+@param[out] backup_snapshot_id        Backup snapshot id to create.
+@param[out] binlog_file               Binlog file name.
+@param[out] binlog_file_offset        Binlog file offset.
+*/
+typedef int (*create_backup_snapshot_t)(THD *thd, uint64_t *backup_snapshot_id,
+                                        std::string &binlog_file,
+                                        uint64_t *binlog_file_offset);
+
+/** do incremental backup for storage engine
+*/
+typedef int (*incremental_backup_t)(THD *thd);
+
+/** Cleanup temporary backup directory for storage engine.
+ */
+typedef int (*cleanup_tmp_backup_dir_t)(THD *thd);
+
+/** Release a backup snapshot for storage engine.
+
+@param[in]  backup_snapshot_id        Backup snapshot id to release.
+*/
+typedef int (*release_backup_snapshot_t)(THD *thd, uint64_t backup_snapshot_id);
+
+/** List all backup snapshots for storage engine.
+
+@param[out] backup_snapshot_ids       Backup snapshot ids.
+ */
+typedef int (*list_backup_snapshots_t)(
+    THD *thd, std::vector<uint64_t> &backup_snapshot_ids);
+#endif
+
+/**
+  Perform SE-specific initialization after recovery of binlog/gtid.
+*/
+typedef void (*post_engine_recover_t)(void);
+
 /**
   Lock a handlerton (resource) log to collect log information.
 */
@@ -2762,6 +2816,18 @@ struct handlerton {
 
   post_ddl_t post_ddl;
   post_recover_t post_recover;
+#ifdef WITH_SMARTENGINE
+  post_engine_recover_t post_engine_recover;
+#endif
+
+#ifdef WITH_SMARTENGINE
+  checkpoint_t checkpoint;
+  create_backup_snapshot_t create_backup_snapshot;
+  incremental_backup_t incremental_backup;
+  cleanup_tmp_backup_dir_t cleanup_tmp_backup_dir;
+  release_backup_snapshot_t release_backup_snapshot;
+  list_backup_snapshots_t list_backup_snapshots;
+#endif
 
   /** Clone data transfer interfaces */
   Clone_interface_t clone_interface;
@@ -6867,6 +6933,10 @@ class handler {
     return false;
   }
 
+#ifdef WITH_SMARTENGINE
+  virtual Handler_share **get_ha_share_ref() { return ha_share; }
+#endif
+
   void set_ha_table(TABLE *table_arg) { table = table_arg; }
 
   int get_lock_type() const { return m_lock_type; }
@@ -7320,6 +7390,13 @@ int ha_recover(Xid_commit_list *commit_list = nullptr,
 */
 void ha_post_recover();
 
+#ifdef WITH_SMARTENGINE
+/**
+  Perform SE-specific initialization after recovery of binlog/gtid.
+*/
+void ha_post_engine_recover(void);
+#endif
+
 /*
  transactions: interface to low-level handlerton functions. These are
  intended to be used by the transaction coordinators to
diff --git a/sql/lex.h b/sql/lex.h
index a0665941017..90417c9860a 100644
--- a/sql/lex.h
+++ b/sql/lex.h
@@ -156,6 +156,8 @@ static const SYMBOL symbols[] = {
     {SYM("COMPRESSION", COMPRESSION_SYM)},
     {SYM("COMPRESSED", COMPRESSED_SYM)},
     {SYM("ENCRYPTION", ENCRYPTION_SYM)},
+    {SYM("CONSENSUS", CONSENSUS_SYM)},
+    {SYM("CONSENSUS_LOG", CONSENSUSLOG_SYM)},
     {SYM("CONCURRENT", CONCURRENT)},
     {SYM("CONDITION", CONDITION_SYM)},
     {SYM("CONNECTION", CONNECTION_SYM)},
@@ -817,6 +819,7 @@ static const SYMBOL symbols[] = {
     {SYM("XA", XA_SYM)},
     {SYM("XID", XID_SYM)},
     {SYM("XML", XML_SYM)}, /* LOAD XML Arnold/Erik */
+    {SYM("RAFT_REPLICATION", RAFT_REPLICATION)},
     {SYM("YEAR", YEAR_SYM)},
     {SYM("YEAR_MONTH", YEAR_MONTH_SYM)},
     {SYM("ZEROFILL", ZEROFILL_SYM)},
diff --git a/sql/log.cc b/sql/log.cc
index 33c7a4cb4d7..5c1e92bb606 100644
--- a/sql/log.cc
+++ b/sql/log.cc
@@ -105,6 +105,11 @@
 
 #include "sql/server_component/log_builtins_imp.h"
 
+#ifdef WITH_SMARTENGINE
+#include "storage/smartengine/core/monitoring/query_perf_context.h"
+#include "storage/smartengine/util/se_logger.h"
+#endif
+
 using std::max;
 using std::min;
 
@@ -1975,6 +1980,10 @@ bool reopen_error_log() {
     if (result)
       my_error(ER_DA_CANT_OPEN_ERROR_LOG, MYF(0), error_log_file, ".",
                ""); /* purecov: inspected */
+#ifdef WITH_SMARTENGINE
+    else if (mysql_reinit_se_log())
+      sql_print_error("Failed to re-initialize logger in smartengine: %s", error_log_file);
+#endif
   }
 
   return result;
diff --git a/sql/log.h b/sql/log.h
index a5bb557276c..ab39a669417 100644
--- a/sql/log.h
+++ b/sql/log.h
@@ -787,7 +787,11 @@ extern Slow_log_throttle log_throttle_qni;
 #define sql_print_warning(...) \
   log_errlog_formatted(WARNING_LEVEL, ##__VA_ARGS__)
 
+#ifdef WITH_SMARTENGINE
+#define sql_print_error(...) log_errlog_formatted(loglevel::ERROR_LEVEL, ##__VA_ARGS__)
+#else
 #define sql_print_error(...) log_errlog_formatted(ERROR_LEVEL, ##__VA_ARGS__)
+#endif
 
 /**
   Prints a printf style message to the error log.
diff --git a/sql/log_event.cc b/sql/log_event.cc
index b8e1541b2a9..81fcfe57ad2 100644
--- a/sql/log_event.cc
+++ b/sql/log_event.cc
@@ -930,6 +930,16 @@ const char *Log_event::get_type_str(Log_event_type type) {
       return "XA_prepare";
     case binary_log::PARTIAL_UPDATE_ROWS_EVENT:
       return "Update_rows_partial";
+#ifdef WESQL_CLUSTER
+    case binary_log::CONSENSUS_LOG_EVENT:
+      return "Consensus_log";
+    case binary_log::PREVIOUS_CONSENSUS_INDEX_LOG_EVENT:
+      return "Previous_consensus_index";
+    case binary_log::CONSENSUS_CLUSTER_INFO_EVENT:
+      return "Consensus_cluster_info";
+    case binary_log::CONSENSUS_EMPTY_EVENT:
+      return "Consensus_empty";
+#endif
     case binary_log::TRANSACTION_PAYLOAD_EVENT:
       return "Transaction_payload";
     default:
@@ -1039,6 +1049,10 @@ int Log_event::do_update_pos(Relay_log_info *rli) {
   int error = 0;
   assert(!rli->belongs_to_client());
 
+#ifdef WESQL_CLUSTER
+  (void)RUN_HOOK(binlog_applier, on_stmt_done, (rli));
+#endif
+
   if (rli) error = rli->stmt_done(common_header->log_pos);
   return error;
 }
@@ -1202,6 +1216,9 @@ bool Log_event::need_checksum() {
               which IO thread instantiates via queue_binlog_ver_3_event.
            */
            get_type_code() == binary_log::ROTATE_EVENT ||
+#ifdef WESQL_CLUSTER
+           get_type_code() == binary_log::PREVIOUS_CONSENSUS_INDEX_LOG_EVENT ||
+#endif
            /*
               The previous event has its checksum option defined
               according to the format description event.
@@ -2648,6 +2665,11 @@ Slave_worker *Log_event::get_slave_worker(Relay_log_info *rli) {
       rli->mts_groups_assigned++;
 
       rli->curr_group_isolated = false;
+
+#ifdef WESQL_CLUSTER
+      (void)RUN_HOOK(binlog_applier, on_mts_groups_assigned, (rli, &group));
+#endif
+
       group.reset(common_header->log_pos, rli->mts_groups_assigned);
       // the last occupied GAQ's array index
       gaq->assigned_group_index = gaq->en_queue(&group);
@@ -6249,6 +6271,10 @@ int Xid_apply_log_event::do_apply_event(Relay_log_info const *rli) {
       goto err;
   }
 
+#ifdef WESQL_CLUSTER
+  (void)RUN_HOOK(binlog_applier, on_commit_positions, (rli_ptr, nullptr, true));
+#endif
+
   DBUG_PRINT(
       "info",
       ("do_apply group source %s %llu  group relay %s %llu event %s %llu\n",
@@ -6298,13 +6324,18 @@ int Xid_apply_log_event::do_apply_event(Relay_log_info const *rli) {
                       rli_ptr->get_group_master_log_pos(),
                       rli_ptr->get_group_relay_log_name(),
                       rli_ptr->get_group_relay_log_pos()));
+
   mysql_mutex_unlock(&rli_ptr->data_lock);
   error = do_commit(thd);
   mysql_mutex_lock(&rli_ptr->data_lock);
+
   if (error) {
     rli->report(ERROR_LEVEL, thd->get_stmt_da()->mysql_errno(),
                 "Error in Xid_log_event: Commit could not be completed, '%s'",
                 thd->get_stmt_da()->message_text());
+#ifdef WESQL_CLUSTER
+    (void)RUN_HOOK(binlog_applier, on_rollback_positions, (rli_ptr));
+#endif
   } else {
     DBUG_EXECUTE_IF(
         "crash_after_commit_before_update_pos",
@@ -10310,6 +10341,10 @@ int Rows_log_event::do_update_pos(Relay_log_info *rli) {
       Step the group log position if we are not in a transaction,
       otherwise increase the event log position.
     */
+#ifdef WESQL_CLUSTER
+    (void)RUN_HOOK(binlog_applier, on_stmt_done, (rli));
+#endif
+
     error = rli->stmt_done(common_header->log_pos);
   } else {
     rli->inc_event_relay_log_pos();
@@ -14340,3 +14375,7 @@ std::pair<bool, binary_log::Log_event_basic_info> extract_log_event_basic_info(
       uint2korr(buf + FLAGS_OFFSET) & LOG_EVENT_IGNORABLE_F;
   return std::make_pair(false, event_info);
 }
+
+#ifdef WESQL_CLUSTER
+#include "consensus_log_event.cc"
+#endif
diff --git a/sql/log_event.h b/sql/log_event.h
index c288026b810..22d6c7b9d24 100644
--- a/sql/log_event.h
+++ b/sql/log_event.h
@@ -799,6 +799,26 @@ class Log_event {
     return common_header->type_code;
   }
 
+#ifdef WESQL_CLUSTER
+  bool is_control_event() {
+    return common_header->type_code == binary_log::FORMAT_DESCRIPTION_EVENT ||
+           common_header->type_code ==
+               binary_log::PREVIOUS_CONSENSUS_INDEX_LOG_EVENT ||
+           common_header->type_code == binary_log::PREVIOUS_GTIDS_LOG_EVENT ||
+           common_header->type_code == binary_log::CONSENSUS_LOG_EVENT ||
+           common_header->type_code == binary_log::ROTATE_EVENT;
+  }
+
+  /* event generate by consensus replication */
+  bool is_consensus_event() {
+    return common_header->type_code ==
+               binary_log::PREVIOUS_CONSENSUS_INDEX_LOG_EVENT ||
+           common_header->type_code == binary_log::CONSENSUS_LOG_EVENT ||
+           common_header->type_code == binary_log::CONSENSUS_EMPTY_EVENT ||
+           common_header->type_code == binary_log::CONSENSUS_CLUSTER_INFO_EVENT;
+  }
+#endif
+
   /**
     Return true if the event has to be logged using SBR for DMLs.
   */
@@ -4397,5 +4417,8 @@ std::pair<bool, binary_log::Log_event_basic_info> extract_log_event_basic_info(
 /**
   @} (end of group Replication)
 */
+#ifdef WESQL_CLUSTER
+#include "sql/consensus_log_event.h"
+#endif
 
 #endif /* _log_event_h */
diff --git a/sql/mysqld.cc b/sql/mysqld.cc
index 3f94e768956..d2a6878b9a1 100644
--- a/sql/mysqld.cc
+++ b/sql/mysqld.cc
@@ -774,15 +774,18 @@ MySQL clients support the protocol:
 #include "sql/auth/auth_common.h"         // grant_init
 #include "sql/auth/sql_authentication.h"  // init_rsa_keys
 #include "sql/auth/sql_security_ctx.h"
-#include "sql/auto_thd.h"   // Auto_THD
-#include "sql/binlog.h"     // mysql_bin_log
-#include "sql/bootstrap.h"  // bootstrap
+#include "sql/auto_thd.h"        // Auto_THD
+#include "sql/binlog.h"          // mysql_bin_log
+#include "sql/binlog_archive.h"  // start_binlog_archive
+#include "sql/bootstrap.h"       // bootstrap
 #include "sql/check_stack.h"
 #include "sql/conn_handler/connection_acceptor.h"  // Connection_acceptor
 #include "sql/conn_handler/connection_handler_impl.h"  // Per_thread_connection_handler
 #include "sql/conn_handler/connection_handler_manager.h"  // Connection_handler_manager
 #include "sql/conn_handler/socket_connection.h"  // stmt_info_new_packet
-#include "sql/current_thd.h"                     // current_thd
+#include "sql/consistent_archive.h"              // start_consistent_archive
+#include "sql/consistent_recovery.h"
+#include "sql/current_thd.h"  // current_thd
 #include "sql/dd/cache/dictionary_client.h"
 #include "sql/debug_sync.h"  // debug_sync_end
 #include "sql/derror.h"
@@ -885,6 +888,10 @@ MySQL clients support the protocol:
 #include "typelib.h"
 #include "violite.h"
 
+#ifdef WESQL
+#include "sql/package/package_interface.h"
+#endif
+
 #ifdef WITH_PERFSCHEMA_STORAGE_ENGINE
 #include "storage/perfschema/pfs_server.h"
 #endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */
@@ -1221,6 +1228,9 @@ bool opt_no_monitor = false;
 
 bool opt_no_dd_upgrade = false;
 long opt_upgrade_mode = UPGRADE_AUTO;
+#ifdef WESQL
+bool opt_upgrade_wesql = false;
+#endif
 bool opt_initialize = false;
 bool opt_skip_replica_start = false;  ///< If set, slave is not autostarted
 bool opt_enable_named_pipe = false;
@@ -1500,6 +1510,65 @@ char server_version[SERVER_VERSION_LENGTH];
 const char *mysqld_unix_port;
 char *opt_mysql_tmpdir;
 
+bool consistent_recovery_consensus_recovery = false;
+uint64_t consistent_recovery_snapshot_end_binlog_position = 0;
+uint64_t consistent_recovery_snasphot_end_consensus_index = 0;
+char consistent_recovery_apply_stop_timestamp[MAX_DATETIME_FULL_WIDTH +
+                                        4];  // YYYY-MM-DDTHH:MM:SS.######Z
+// The last truncated MySQL binlog file returned by consensus. The final binlog
+// may contain incomplete transactions that need to be truncated, but with the
+// current binlog archive design, incomplete transactions should not occur.
+char consistent_recovery_consensus_truncated_end_binlog[FN_REFLEN + 1];
+// The truncated position of last truncated MySQL binlog file returned by consensus.
+my_off_t consistent_recovery_consensus_truncated_end_position = 0;
+ulong opt_binlog_archive_slice_max_size = 0;
+bool opt_binlog_archive = true;
+char *opt_binlog_archive_dir = nullptr;
+bool opt_binlog_archive_using_consensus_index = false;
+bool opt_binlog_archive_expire_auto_purge = true;
+ulong opt_binlog_archive_expire_seconds = 0;
+ulonglong opt_binlog_archive_period = 0;
+ulong opt_binlog_archive_parallel_workers = 0;
+char *opt_consistent_snapshot_archive_dir = nullptr;
+bool opt_consistent_snapshot_persistent_on_objstore = false;
+bool opt_initialize_use_objstore = false;
+bool opt_consistent_snapshot_archive = true;
+ulong opt_consistent_snapshot_archive_period = 10;
+bool opt_consistent_snapshot_expire_auto_purge = true;
+ulong opt_consistent_snapshot_expire_seconds = 0;
+ulong opt_consistent_snapshot_innodb_tar_mode = 0;
+ulong opt_consistent_snapshot_se_tar_mode = 0;
+bool opt_consistent_snapshot_smartengine_backup_checkpoint=false;
+bool opt_recovery_from_objstore = false;
+char *opt_recovery_consistent_snapshot_tmpdir = nullptr;
+bool opt_recovery_consistent_snapshot_only = false;
+char *opt_recovery_consistent_snapshot_timestamp = nullptr;
+bool opt_initialize_from_objstore = false;
+char *opt_initialize_objstore_provider = nullptr;
+char *opt_initialize_objstore_region = nullptr;
+char *opt_initialize_objstore_endpoint = nullptr;
+bool opt_initialize_objstore_use_https = false;
+char *opt_initialize_objstore_bucket = nullptr;
+char *opt_initialize_repo_objstore_id = nullptr;
+char *opt_initialize_branch_objstore_id = nullptr;
+bool opt_initialize_smartengine_objectstore_data = false;
+bool opt_serverless = true;
+/**
+  TODO(cnut): how to validate the relationship between different variables of
+  object store, such as if opt_table_on_objstore is true, opt_objstore_provider/
+  opt_objstore_region/opt_objstore_bucket can not be empty.
+*/
+bool opt_table_on_objstore = false;
+char *opt_objstore_provider;
+char *opt_objstore_region;
+char *opt_objstore_endpoint;
+bool opt_objstore_use_https = false;
+char *opt_objstore_bucket;
+char *opt_objstore_mtr_test_bucket_dir;
+char *opt_repo_objstore_id = nullptr;
+char *opt_branch_objstore_id = nullptr;
+char *opt_server_id_on_objstore = nullptr;
+
 char *opt_authentication_policy;
 std::vector<std::string> authentication_policy_list;
 /*
@@ -2362,6 +2431,11 @@ static void close_connections(void) {
   Call_close_conn call_close_conn(true);
   thd_manager->do_for_all_thd(&call_close_conn);
 
+  // Must be called before ha_pre_dd_shutdown.ha_pre_dd_shutdown will close
+  // smartengine plugin and clone plugin.
+  stop_consistent_archive();
+  stop_binlog_archive();
+
   (void)RUN_HOOK(server_state, after_server_shutdown, (nullptr));
 
   /*
@@ -2493,6 +2567,8 @@ void clean_up_mysqld_mutexes() { clean_up_mutexes(); }
 static void mysqld_exit(int exit_code) {
   assert((exit_code >= MYSQLD_SUCCESS_EXIT && exit_code <= MYSQLD_ABORT_EXIT) ||
          exit_code == MYSQLD_RESTART_EXIT);
+  (Binlog_archive::get_instance())->deinit_pthread_object();
+  (Consistent_archive::get_instance())->deinit_pthread_object();
   mysql_audit_finalize();
   Srv_session::module_deinit();
   delete_optimizer_cost_module();
@@ -4272,6 +4348,10 @@ SHOW_VAR com_status_vars[] = {
      (char *)offsetof(System_status_var,
                       com_stat[(uint)SQLCOM_SHOW_BINLOG_EVENTS]),
      SHOW_LONG_STATUS, SHOW_SCOPE_ALL},
+    {"show_consensuslogs",
+     (char *)offsetof(System_status_var,
+                      com_stat[(uint)SQLCOM_SHOW_CONSENSUSLOGS]),
+     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},
     {"show_binlogs",
      (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SHOW_BINLOGS]),
      SHOW_LONG_STATUS, SHOW_SCOPE_ALL},
@@ -4443,6 +4523,14 @@ SHOW_VAR com_status_vars[] = {
      (char *)offsetof(System_status_var,
                       com_stat[(uint)SQLCOM_STOP_GROUP_REPLICATION]),
      SHOW_LONG_STATUS, SHOW_SCOPE_ALL},
+    {"raft_replication_start",
+     (char *)offsetof(System_status_var,
+                      com_stat[(uint)SQLCOM_START_RAFT_REPLICATION]),
+     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},
+    {"raft_replication_stop",
+     (char *)offsetof(System_status_var,
+                      com_stat[(uint)SQLCOM_STOP_RAFT_REPLICATION]),
+     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},
     {"stmt_execute", (char *)offsetof(System_status_var, com_stmt_execute),
      SHOW_LONG_STATUS, SHOW_SCOPE_ALL},
     {"stmt_close", (char *)offsetof(System_status_var, com_stmt_close),
@@ -4498,6 +4586,16 @@ SHOW_VAR com_status_vars[] = {
     {"xa_start",
      (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_XA_START]),
      SHOW_LONG_STATUS, SHOW_SCOPE_ALL},
+    {"native_admin_proc",
+     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_ADMIN_PROC]),
+     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},
+    {"native_trans_proc",
+     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_TRANS_PROC]),
+     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},
+    {"show_consensuslog_events",
+     (char *)offsetof(System_status_var,
+                      com_stat[(uint)SQLCOM_SHOW_CONSENSUSLOG_EVENTS]),
+     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},
     {NullS, NullS, SHOW_LONG, SHOW_SCOPE_ALL}};
 
 LEX_CSTRING sql_statement_names[(uint)SQLCOM_END + 1];
@@ -4817,6 +4915,9 @@ int init_common_variables() {
   */
   mysql_bin_log.init_pthread_objects();
 
+  (Binlog_archive::get_instance())->init_pthread_object();
+  (Consistent_archive::get_instance())->init_pthread_object();
+
   /* TODO: remove this when my_time_t is 64 bit compatible */
   if (!is_time_t_valid_for_timestamp(server_start_time)) {
     LogErr(ERROR_LEVEL, ER_UNSUPPORTED_DATE);
@@ -4859,6 +4960,12 @@ int init_common_variables() {
   default_storage_engine = "InnoDB";
   default_tmp_storage_engine = default_storage_engine;
 
+#ifdef WITH_SMARTENGINE
+  // Smartengine is the default storage engine of wesql.
+  if (!opt_initialize) {
+    default_storage_engine = SMARTENGINE_NAME;
+  }
+#endif // WITH_SMARTENGINE
   /*
     Add server status variables to the dynamic list of
     status variables that is shown by SHOW STATUS.
@@ -6286,6 +6393,14 @@ static int init_server_components() {
       opt_bin_logname = my_strdup(key_memory_opt_bin_logname, buf, MYF(0));
     }
 
+    // Recovery binlog from archive dir or object store.
+    // Must recovery binlog and index, before open index file first.
+    if (opt_serverless &&
+        consistent_recovery.recovery_binlog(opt_binlog_index_name, ln)) {
+      LogErr(ERROR_LEVEL, ER_CONSISTENT_SNAPSHOT_LOG,
+             "Failed to recovery binlog from object storage");
+      unireg_abort(MYSQLD_ABORT_EXIT);
+    }
     /*
       Skip opening the index file if we start with --help. This is necessary
       to avoid creating the file in an otherwise empty datadir, which will
@@ -6503,6 +6618,33 @@ static int init_server_components() {
       LogErr(ERROR_LEVEL, ER_CANT_INITIALIZE_BUILTIN_PLUGINS);
     unireg_abort(1);
   }
+  // innodb and smartengine are core plugins.
+  if (opt_serverless) {
+    // Consistent recovery innodb after innodb plugin is loaded.
+    if (consistent_recovery.recovery_mysql_innodb()) {
+      LogErr(ERROR_LEVEL, ER_CONSISTENT_SNAPSHOT_LOG,
+             "Failed to recovery innodb data from object storage");
+      unireg_abort(MYSQLD_ABORT_EXIT);
+    }
+    // Consistent recovery smartengine after smartengine plugin is loaded.
+    if (consistent_recovery.recovery_smartengine()) {
+      LogErr(ERROR_LEVEL, ER_CONSISTENT_SNAPSHOT_LOG,
+             "Failed to recovery smartengine data from object storage");
+      unireg_abort(MYSQLD_ABORT_EXIT);
+    }
+
+    // Consistent recovery smartengine sst when clone instance.
+    if (unlikely(opt_initialize) && opt_initialize_from_objstore &&
+        consistent_recovery.recovery_smartengine_objectstore_data()) {
+      LogErr(ERROR_LEVEL, ER_CONSISTENT_SNAPSHOT_LOG,
+             "Failed to recovery smartengine sst from object storage");
+      unireg_abort(MYSQLD_ABORT_EXIT);
+    }
+    // Consistent recovery finish.
+    consistent_recovery.recovery_consistent_snapshot_finish();
+    if(unlikely(opt_initialize) && opt_initialize_from_objstore) 
+      unireg_abort(MYSQLD_SUCCESS_EXIT);
+  }
 
   /*
     Needs to be done before dd::init() which runs DDL commands (for real)
@@ -6785,6 +6927,27 @@ static int init_server_components() {
     unireg_abort(1);
   }
 
+#ifdef WESQL
+  if (!is_help_or_validate_option()) {
+    bool r = false;
+    init_optimizer_cost_module(true);
+    if (opt_initialize || dd_upgrade_was_initiated) {
+      r = ::bootstrap::run_bootstrap_thread(
+          nullptr, nullptr, &dd::upgrade::initialize_wesql_schemas,
+          SYSTEM_THREAD_SERVER_INITIALIZE);
+    } else if (opt_upgrade_wesql) {
+      r = ::bootstrap::run_bootstrap_thread(
+          nullptr, nullptr, &dd::upgrade::initialize_wesql_schemas,
+          SYSTEM_THREAD_SERVER_UPGRADE);
+    }
+    delete_optimizer_cost_module();
+    if (r) {
+      LogErr(ERROR_LEVEL, ER_SERVER_UPGRADE_FAILED);
+      unireg_abort(MYSQLD_ABORT_EXIT);
+    }
+  }
+#endif
+
   if (opt_initialize) log_output_options = LOG_FILE;
 
   /*
@@ -6818,6 +6981,20 @@ static int init_server_components() {
   /*
     Set the default storage engines
   */
+#ifdef WITH_SMARTENGINE
+  // In serverless mode, the storage engine of user tables is enforced to
+  // be smartengine, so the value of parameter default_storage_engine must
+  // be smartengine. Here, the degault storage engine is not implicitly
+  // change to smartengine, instead an error is raised. It's to avoid
+  // confusion in parameter configuration for default_storage_engine.
+  if (!opt_initialize && opt_serverless &&
+      (strlen(default_storage_engine) != strlen(SMARTENGINE_NAME) ||
+       0 != strncasecmp(default_storage_engine, SMARTENGINE_NAME, strlen(SMARTENGINE_NAME)))) {
+    LogErr(ERROR_LEVEL, ER_FORCE_DEFAULT_STORAGE_ENGINE_TO_SMARTENGINE, default_storage_engine);
+    unireg_abort(MYSQLD_ABORT_EXIT);
+  }
+#endif // WITH_SMARTENGINE
+
   if (initialize_storage_engine(default_storage_engine, "",
                                 &global_system_variables.table_plugin))
     unireg_abort(MYSQLD_ABORT_EXIT);
@@ -6890,7 +7067,22 @@ static int init_server_components() {
     unireg_abort(MYSQLD_ABORT_EXIT);
   }
 
-  if (opt_bin_log) {
+  // When Logger node startup, get last persisted binlog consensus index.
+  // Use the next consensus index of the last persisted binlog as logger a
+  // starting index.
+  if (!opt_initialize && opt_serverless &&
+      consistent_recovery.get_last_persistent_binlog_consensus_index()) {
+    unireg_abort(MYSQLD_ABORT_EXIT);
+  }
+
+#ifdef WESQL_CLUSTER
+  if (!NO_HOOK(binlog_manager)) {
+    if (RUN_HOOK(binlog_manager, after_binlog_recovery, (&mysql_bin_log))) {
+      unireg_abort(MYSQLD_ABORT_EXIT);
+    }
+  } else
+#endif
+      if (opt_bin_log) {
     /*
       Configures what object is used by the current log to store processed
       gtid(s). This is necessary in the MYSQL_BIN_LOG::MYSQL_BIN_LOG to
@@ -7531,6 +7723,11 @@ int mysqld_main(int argc, char **argv)
   */
   init_server_psi_keys();
 
+  /* Init conconcurrency control system */
+#ifdef WESQL
+  im::package_context_init();
+#endif
+
   /*
     Now that some instrumentation is in place,
     recreate objects which were initialised early,
@@ -7818,6 +8015,16 @@ int mysqld_main(int argc, char **argv)
     unireg_abort(exit_state);
   }
 
+  // In recovery serverless mode, we first create the data directory if it does
+  // not exist. Otherwise, my_setwd will fail.
+  if (!is_help_or_validate_option() && opt_serverless &&
+      (!opt_initialize && opt_recovery_from_objstore)) {
+    MY_STAT stat;
+    if (!my_stat(mysql_real_data_home, &stat, MYF(0)) &&
+        initialize_create_data_directory(mysql_real_data_home))
+      unireg_abort(MYSQLD_ABORT_EXIT); /* purecov: inspected */
+  }
+
   /*
    We have enough space for fiddling with the argv, continue
   */
@@ -7830,6 +8037,63 @@ int mysqld_main(int argc, char **argv)
     unireg_abort(MYSQLD_ABORT_EXIT); /* purecov: inspected */
   }
 
+  // Check the validity of the UUID using the specified objstore_uuid
+  if (!is_help_or_validate_option() && opt_serverless &&
+      opt_repo_objstore_id != nullptr) {
+    if (*opt_repo_objstore_id == '\0') {
+      LogErr(ERROR_LEVEL, ER_OBJSTORE_ID_CHECK_ERROR, "invalid empty objectstore id");
+      unireg_abort(MYSQLD_ABORT_EXIT); /* purecov: inspected */
+    }
+    std::string err_msg;
+    std::string_view endpoint(
+        opt_objstore_endpoint ? std::string_view(opt_objstore_endpoint) : "");
+    if (objstore::ensure_object_store_lock(
+            std::string_view(opt_objstore_provider),
+            std::string_view(opt_objstore_region), &endpoint,
+            std::string_view(opt_objstore_bucket),
+            std::string_view(opt_repo_objstore_id),
+            std::string_view(opt_branch_objstore_id),
+            !opt_initialize || !opt_table_on_objstore, err_msg)) {
+      LogErr(ERROR_LEVEL, ER_OBJSTORE_ID_CHECK_ERROR, err_msg.c_str());
+      unireg_abort(MYSQLD_ABORT_EXIT); /* purecov: inspected */
+    }
+  }
+
+  // 1. Recovery from object store, if $data_home/mysql directory not exists.
+  // 2. Clone a new instance from object store.
+  // InnoDB data recovery will be done after innodb plugin is loaded.
+  // Smartengine recovery will be done after smartengine plugin is loaded.
+  // Binlog recovery will be done after bin-log and bin-log-index option is
+  // ready.
+  if (!is_help_or_validate_option() && opt_serverless &&
+      (opt_recovery_from_objstore || opt_initialize_from_objstore)) {
+    Consistent_snapshot_recovery_status recovery_status = {};
+    if (consistent_recovery.read_consistent_snapshot_recovery_status(
+            recovery_status) == 0) {
+      // If recovery process is not completed, we need to recover from object
+      // store again.
+      if (consistent_recovery.recovery_consistent_snapshot(0))
+        unireg_abort(MYSQLD_ABORT_EXIT); /* purecov: inspected */
+    } else {
+      // Only check if mysql directory exists when in recovery mode.
+      char mysql_path[FN_REFLEN];
+      MY_STAT stat;
+      strmake(mysql_path, mysql_real_data_home, sizeof(mysql_path) - 1);
+      convert_dirname(mysql_path, mysql_path, NullS);
+      strcat(mysql_path, "mysql");
+      if ((opt_initialize && opt_initialize_from_objstore) ||
+          (!opt_initialize && opt_recovery_from_objstore &&
+           !my_stat(mysql_path, &stat, MYF(0)))) {
+        // 1. If $datadir/mysql not exists, we need to recover from object
+        // store.
+        // 2. If opt_initialize_from_objstore is set, we need to recover from
+        // object store.
+        if (consistent_recovery.recovery_consistent_snapshot(0))
+          unireg_abort(MYSQLD_ABORT_EXIT); /* purecov: inspected */
+      }
+    }
+  }
+
   /*
    The subsequent calls may take a long time : e.g. innodb log read.
    Thus set the long running service control manager timeout
@@ -7879,6 +8143,16 @@ int mysqld_main(int argc, char **argv)
     if (gtid_state->read_gtid_executed_from_table() == -1) unireg_abort(1);
   }
 
+#ifdef WESQL_CLUSTER
+  if (!NO_HOOK(binlog_manager)) {
+    if (RUN_HOOK(binlog_manager, gtid_recovery, (&mysql_bin_log))) {
+      unireg_abort(MYSQLD_ABORT_EXIT);
+    }
+    if (RUN_HOOK(server_state, after_engine_recovery, (nullptr))) {
+      unireg_abort(MYSQLD_ABORT_EXIT);
+    }
+  } else
+#endif
   if (opt_bin_log) {
     /*
       Initialize GLOBAL.GTID_EXECUTED and GLOBAL.GTID_PURGED from
@@ -7998,6 +8272,14 @@ int mysqld_main(int argc, char **argv)
     (void)RUN_HOOK(server_state, after_engine_recovery, (nullptr));
   }
 
+#ifdef WITH_SMARTENGINE
+  ha_post_engine_recover();
+#endif
+
+  if (!opt_initialize && opt_serverless) {
+    consistent_recovery.consistent_snapshot_consensus_recovery_finish();
+  }
+
   if (init_ssl_communication()) unireg_abort(MYSQLD_ABORT_EXIT);
   if (network_init()) unireg_abort(MYSQLD_ABORT_EXIT);
 
@@ -8133,8 +8415,22 @@ int mysqld_main(int argc, char **argv)
 
   initialize_information_schema_acl();
 
+#ifdef WESQL_CLUSTER
+  if (RUN_HOOK(server_state, after_recovery, (nullptr)))
+    unireg_abort(MYSQLD_ABORT_EXIT);
+#else
   (void)RUN_HOOK(server_state, after_recovery, (nullptr));
+#endif
 
+  // Start binlog and consistent snapshot thread, after consensus service.
+  // The consensus service is started within the `after_recovery` hook.
+  if (!opt_initialize) {
+    // start binlog archive and consistent snapshot archive.
+    if (start_binlog_archive() || start_consistent_archive()) {
+      unireg_abort(MYSQLD_ABORT_EXIT);
+    }
+  }
+  
   if (Events::init(opt_noacl || opt_initialize))
     unireg_abort(MYSQLD_ABORT_EXIT);
 
@@ -9267,6 +9563,12 @@ struct my_option my_long_options[] = {
      &opt_upgrade_mode, &opt_upgrade_mode, &upgrade_mode_typelib, GET_ENUM,
      REQUIRED_ARG, UPGRADE_AUTO, 0, 0, nullptr, 0, nullptr},
 
+#ifdef WESQL
+    {"upgrade-wesql", 0, "Set server upgrade system tables for wesql.",
+     &opt_upgrade_wesql, &opt_upgrade_wesql, nullptr, GET_BOOL, NO_ARG, 0, 0, 0,
+     nullptr, 0, nullptr},
+#endif
+
     {nullptr, 0, nullptr, nullptr, nullptr, nullptr, GET_NO_ARG, NO_ARG, 0, 0,
      0, nullptr, 0, nullptr}};
 
@@ -11131,6 +11433,7 @@ static int get_options(int *argc_ptr, char ***argv_ptr) {
 #ifndef _WIN32
   if (mysqld_chroot) set_root(mysqld_chroot);
 #endif
+
   if (fix_paths()) return 1;
 
   /*
@@ -11184,6 +11487,11 @@ static void set_server_version(void) {
 #ifndef NDEBUG
   if (!strstr(MYSQL_SERVER_SUFFIX_STR, "-debug"))
     end = my_stpcpy(end, "-debug");
+#if defined(WESQL) && defined(WESQL_TEST)
+  if (SERVER_VERSION_LENGTH - (end - server_version) >
+      static_cast<int>(sizeof("-wtest")))
+    end = my_stpcpy(end, "-wtest");
+#endif
 #endif
 #ifdef HAVE_VALGRIND
   if (SERVER_VERSION_LENGTH - (end - server_version) >
@@ -11795,6 +12103,13 @@ PSI_mutex_key key_monitor_info_run_lock;
 PSI_mutex_key key_LOCK_delegate_connection_mutex;
 PSI_mutex_key key_LOCK_group_replication_connection_mutex;
 
+#ifdef WESQL_CLUSTER
+PSI_mutex_key key_consensus_info_data_lock;
+PSI_mutex_key key_consensus_info_run_lock;
+PSI_mutex_key key_consensus_info_sleep_lock;
+PSI_mutex_key key_consensus_info_thd_lock;
+#endif
+
 /* clang-format off */
 static PSI_mutex_info all_server_mutexes[]=
 {
@@ -11861,6 +12176,12 @@ static PSI_mutex_info all_server_mutexes[]=
   { &key_mutex_slave_parallel_pend_jobs, "Relay_log_info::pending_jobs_lock", 0, 0, PSI_DOCUMENT_ME},
   { &key_mutex_slave_parallel_worker_count, "Relay_log_info::exit_count_lock", 0, 0, PSI_DOCUMENT_ME},
   { &key_mutex_slave_parallel_worker, "Worker_info::jobs_lock", 0, 0, PSI_DOCUMENT_ME},
+#ifdef WESQL_CLUSTER
+  {&key_consensus_info_data_lock, "Consensus_info::data_lock", 0, 0, PSI_DOCUMENT_ME},
+  {&key_consensus_info_run_lock, "Consensus_info::run_lock", 0, 0, PSI_DOCUMENT_ME},
+  {&key_consensus_info_sleep_lock, "Consensus_info::sleep_lock", 0, 0, PSI_DOCUMENT_ME},
+  {&key_consensus_info_thd_lock, "Consensus_info::info_thd_lock", 0, 0, PSI_DOCUMENT_ME},
+#endif
   { &key_TABLE_SHARE_LOCK_ha_data, "TABLE_SHARE::LOCK_ha_data", 0, 0, PSI_DOCUMENT_ME},
   { &key_LOCK_error_messages, "LOCK_error_messages", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},
   { &key_LOCK_log_throttle_qni, "LOCK_log_throttle_qni", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},
@@ -11887,7 +12208,7 @@ static PSI_mutex_info all_server_mutexes[]=
   { &key_monitor_info_run_lock, "Source_IO_monitor::run_lock", 0, 0, PSI_DOCUMENT_ME},
   { &key_LOCK_delegate_connection_mutex, "LOCK_delegate_connection_mutex", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},
   { &key_LOCK_group_replication_connection_mutex, "LOCK_group_replication_connection_mutex", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},
-{ &key_LOCK_authentication_policy, "LOCK_authentication_policy", PSI_FLAG_SINGLETON, 0, "A lock to ensure execution of CREATE USER or ALTER USER sql and SET @@global.authentication_policy variable are serialized"},
+  { &key_LOCK_authentication_policy, "LOCK_authentication_policy", PSI_FLAG_SINGLETON, 0, "A lock to ensure execution of CREATE USER or ALTER USER sql and SET @@global.authentication_policy variable are serialized"},
   { &key_LOCK_global_conn_mem_limit, "LOCK_global_conn_mem_limit", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME}
 };
 /* clang-format on */
@@ -11906,6 +12227,14 @@ PSI_rwlock_key key_rwlock_Binlog_transmit_delegate_lock;
 PSI_rwlock_key key_rwlock_Binlog_relay_IO_delegate_lock;
 PSI_rwlock_key key_rwlock_resource_group_mgr_map_lock;
 
+#ifdef WESQL_CLUSTER
+PSI_rwlock_key key_rwlock_Binlog_applier_delegate_lock;
+PSI_rwlock_key key_rwlock_Binlog_manager_delegate_lock;
+PSI_rwlock_key key_LOCK_consensus_info;
+PSI_rwlock_key key_LOCK_consensus_applier_info;
+PSI_rwlock_key key_LOCK_consensus_applier_worker;
+#endif
+
 /* clang-format off */
 static PSI_rwlock_info all_server_rwlocks[]=
 {
@@ -11922,6 +12251,13 @@ static PSI_rwlock_info all_server_rwlocks[]=
   { &key_rwlock_Trans_delegate_lock, "Trans_delegate::lock", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},
   { &key_rwlock_Server_state_delegate_lock, "Server_state_delegate::lock", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},
   { &key_rwlock_Binlog_storage_delegate_lock, "Binlog_storage_delegate::lock", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},
+#ifdef WESQL_CLUSTER
+  { &key_rwlock_Binlog_applier_delegate_lock, "Binlog_applier_delegate::lock", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},
+  { &key_rwlock_Binlog_manager_delegate_lock, "Binlog_manager_delegate::lock", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},
+  { &key_LOCK_consensus_info, "Consensus_info::LOCK_info", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},
+  { &key_LOCK_consensus_applier_info, "Consensus_applier_info::LOCK_info", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},
+  { &key_LOCK_consensus_applier_worker, "Consensus_applier_worker::LOCK_info", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},
+#endif
   { &key_rwlock_receiver_sid_lock, "gtid_retrieved", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},
   { &key_rwlock_rpl_filter_lock, "rpl_filter_lock", 0, 0, PSI_DOCUMENT_ME},
   { &key_rwlock_channel_to_filter_lock, "channel_to_filter_lock", 0, 0, PSI_DOCUMENT_ME},
@@ -11960,6 +12296,12 @@ PSI_cond_key key_cond_slave_worker_hash;
 PSI_cond_key key_monitor_info_run_cond;
 PSI_cond_key key_COND_delegate_connection_cond_var;
 PSI_cond_key key_COND_group_replication_connection_cond_var;
+#ifdef WESQL_CLUSTER
+PSI_cond_key key_consensus_info_data_cond;
+PSI_cond_key key_consensus_info_start_cond;
+PSI_cond_key key_consensus_info_stop_cond;
+PSI_cond_key key_consensus_info_sleep_cond;
+#endif
 
 /* clang-format off */
 static PSI_cond_info all_server_conds[]=
@@ -11997,6 +12339,12 @@ static PSI_cond_info all_server_conds[]=
   { &key_cond_slave_parallel_pend_jobs, "Relay_log_info::pending_jobs_cond", 0, 0, PSI_DOCUMENT_ME},
   { &key_cond_slave_parallel_worker, "Worker_info::jobs_cond", 0, 0, PSI_DOCUMENT_ME},
   { &key_cond_mta_gaq, "Relay_log_info::mta_gaq_cond", 0, 0, PSI_DOCUMENT_ME},
+#ifdef WESQL_CLUSTER
+  {&key_consensus_info_data_cond, "Consensus_info::data_cond", 0, 0, PSI_DOCUMENT_ME},
+  {&key_consensus_info_start_cond, "Consensus_info::start_cond", 0, 0, PSI_DOCUMENT_ME},
+  {&key_consensus_info_stop_cond, "Consensus_info::stop_cond", 0, 0, PSI_DOCUMENT_ME},
+  {&key_consensus_info_sleep_cond, "Consensus_info::sleep_cond", 0, 0, PSI_DOCUMENT_ME},
+#endif
   { &key_gtid_ensure_index_cond, "Gtid_state", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},
   { &key_COND_compress_gtid_table, "COND_compress_gtid_table", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},
   { &key_commit_order_manager_cond, "Commit_order_manager::m_workers.cond", 0, 0, PSI_DOCUMENT_ME},
diff --git a/sql/mysqld.h b/sql/mysqld.h
index 8b5a842b54b..7dd3f67e1f3 100644
--- a/sql/mysqld.h
+++ b/sql/mysqld.h
@@ -180,6 +180,9 @@ extern MYSQL_PLUGIN_IMPORT std::atomic<int32>
     connection_events_loop_aborted_flag;
 extern bool opt_no_dd_upgrade;
 extern long opt_upgrade_mode;
+#ifdef WESQL
+extern bool opt_upgrade_wesql;
+#endif
 extern bool opt_initialize;
 extern bool opt_safe_user_create;
 extern bool opt_local_infile, opt_myisam_use_mmap;
@@ -542,6 +545,22 @@ extern PSI_socket_key key_socket_tcpip;
 extern PSI_socket_key key_socket_unix;
 extern PSI_socket_key key_socket_client_connection;
 
+#ifdef WESQL_CLUSTER
+extern PSI_cond_key key_consensus_info_data_cond;
+extern PSI_cond_key key_consensus_info_start_cond;
+extern PSI_cond_key key_consensus_info_stop_cond;
+extern PSI_cond_key key_consensus_info_sleep_cond;
+
+extern PSI_mutex_key key_consensus_info_data_lock;
+extern PSI_mutex_key key_consensus_info_run_lock;
+extern PSI_mutex_key key_consensus_info_sleep_lock;
+extern PSI_mutex_key key_consensus_info_thd_lock;
+
+extern PSI_rwlock_key key_LOCK_consensus_info;
+extern PSI_rwlock_key key_LOCK_consensus_applier_info;
+extern PSI_rwlock_key key_LOCK_consensus_applier_worker;
+#endif
+
 #endif /* HAVE_PSI_INTERFACE */
 
 /*
@@ -698,6 +717,56 @@ extern MYSQL_PLUGIN_IMPORT char pidfile_name[];
 
 #define mysql_tmpdir (my_tmpdir(&mysql_tmpdir_list))
 
+extern char *opt_repo_objstore_id;
+extern char *opt_branch_objstore_id;
+extern char *opt_server_id_on_objstore;
+extern bool consistent_recovery_consensus_recovery;
+extern uint64_t consistent_recovery_snapshot_end_binlog_position;
+extern uint64_t consistent_recovery_snasphot_end_consensus_index;
+extern char consistent_recovery_apply_stop_timestamp[MAX_DATETIME_FULL_WIDTH + 4];
+extern char consistent_recovery_consensus_truncated_end_binlog[FN_REFLEN + 1];
+extern my_off_t consistent_recovery_consensus_truncated_end_position;
+extern ulong opt_binlog_archive_slice_max_size;
+extern bool opt_binlog_archive;
+extern char *opt_binlog_archive_dir;
+extern bool opt_binlog_archive_using_consensus_index;
+extern bool opt_binlog_archive_expire_auto_purge;
+extern ulong opt_binlog_archive_expire_seconds;
+extern ulonglong opt_binlog_archive_period;
+extern ulong opt_binlog_archive_parallel_workers;
+extern char *opt_consistent_snapshot_archive_dir;
+extern bool opt_consistent_snapshot_persistent_on_objstore;
+extern bool opt_initialize_use_objstore;
+extern bool opt_consistent_snapshot_archive;
+extern ulong opt_consistent_snapshot_archive_period;
+extern bool opt_consistent_snapshot_expire_auto_purge;
+extern ulong opt_consistent_snapshot_expire_seconds;
+extern ulong opt_consistent_snapshot_se_tar_mode;
+extern ulong opt_consistent_snapshot_innodb_tar_mode;
+extern bool opt_consistent_snapshot_smartengine_backup_checkpoint;
+extern bool opt_recovery_from_objstore;
+extern char *opt_recovery_consistent_snapshot_tmpdir;
+extern bool opt_recovery_consistent_snapshot_only;
+extern char *opt_recovery_consistent_snapshot_timestamp;
+extern bool opt_initialize_from_objstore;
+extern char *opt_initialize_objstore_provider;
+extern char *opt_initialize_objstore_region;
+extern char *opt_initialize_objstore_endpoint;
+extern bool opt_initialize_objstore_use_https;
+extern char *opt_initialize_objstore_bucket;
+extern char *opt_initialize_repo_objstore_id;
+extern char *opt_initialize_branch_objstore_id;
+extern bool opt_initialize_smartengine_objectstore_data;
+
+extern MYSQL_PLUGIN_IMPORT bool opt_serverless;
+extern MYSQL_PLUGIN_IMPORT bool opt_table_on_objstore;
+extern MYSQL_PLUGIN_IMPORT char *opt_objstore_provider;
+extern MYSQL_PLUGIN_IMPORT char *opt_objstore_region;
+extern MYSQL_PLUGIN_IMPORT char *opt_objstore_endpoint;
+extern MYSQL_PLUGIN_IMPORT bool opt_objstore_use_https;
+extern MYSQL_PLUGIN_IMPORT char *opt_objstore_bucket;
+extern MYSQL_PLUGIN_IMPORT char *opt_objstore_mtr_test_bucket_dir;
+
 /*
   Server mutex locks and condition variables.
  */
diff --git a/sql/parse_tree_nodes.cc b/sql/parse_tree_nodes.cc
index f1504a6333d..e9696f10c93 100644
--- a/sql/parse_tree_nodes.cc
+++ b/sql/parse_tree_nodes.cc
@@ -1996,8 +1996,23 @@ bool PT_create_table_engine_option::contextualize(Table_ddl_parse_context *pc) {
 
   pc->create_info->used_fields |= HA_CREATE_USED_ENGINE;
   const bool is_temp_table = pc->create_info->options & HA_LEX_CREATE_TMP_TABLE;
+#ifdef WITH_SMARTENGINE
+  LEX_CSTRING actual_engine = engine;
+  const bool is_system_thd = pc->thd->is_system_thread();
+  const bool use_smartengine = (engine.length == strlen(SMARTENGINE_NAME)) &&
+      (0 == strncasecmp(engine.str, SMARTENGINE_NAME, engine.length));
+  if (opt_serverless && !is_system_thd && !is_temp_table && !use_smartengine) {
+    actual_engine.str = SMARTENGINE_NAME;
+    actual_engine.length = strlen(SMARTENGINE_NAME);
+    push_warning_printf(pc->thd, Sql_condition::SL_WARNING, ER_FORCE_STORAGE_ENGINE_TO_SMARTENGINE,
+                        "Force change storage engine from %s to smartengine in serveless mode", engine.str);
+  }
+  return resolve_engine(pc->thd, actual_engine, is_temp_table, false,
+                        &pc->create_info->db_type);
+#else
   return resolve_engine(pc->thd, engine, is_temp_table, false,
                         &pc->create_info->db_type);
+#endif // WITH_SMARTENGINE
 }
 
 bool PT_create_table_secondary_engine_option::contextualize(
diff --git a/sql/range_optimizer/range_optimizer.cc b/sql/range_optimizer/range_optimizer.cc
index ae4f89f487e..45ab5d8e871 100644
--- a/sql/range_optimizer/range_optimizer.cc
+++ b/sql/range_optimizer/range_optimizer.cc
@@ -606,6 +606,23 @@ int test_quick_select(THD *thd, MEM_ROOT *return_mem_root,
       index_merge_allowed &&
       thd->optimizer_switch_flag(OPTIMIZER_SWITCH_INDEX_MERGE_INTERSECT);
 
+#ifdef WITH_SMARTENGINE
+  /**In order to fix the issue of non-optimal covered indexes preventing range
+   * scan selection.If the best cost comes from the cost of a covered index, and
+   * that covered index cannot actually be used by the current query, then this
+   * cost will prevent the range scan plan from being selected (see function
+   * get_key_scans_params()).
+   *
+   * The original cost is retained here. If later, during the evaluation of the
+   * index range scan logic(get_key_scans_params()), the best cost comes from
+   * a covered index, then the read cost will be set to original cost to avoid
+   * discarding a better range scan plan mistakenly.
+   *
+   * The above logic only applies to tables using the smartengine storage engine.*/
+  double covering_index_cost = 0;
+  double base_cost = cost_est.total_cost();
+#endif
+
   /* Calculate cost of full index read for the shortest covering index */
   if (!table->covering_keys.is_clear_all()) {
     int key_for_use = find_shortest_key(table, &table->covering_keys);
@@ -617,6 +634,10 @@ int test_quick_select(THD *thd, MEM_ROOT *return_mem_root,
     key_read_time.add_cpu(
         cost_model->row_evaluate_cost(static_cast<double>(records)));
 
+#ifdef WITH_SMARTENGINE
+    covering_index_cost = key_read_time.total_cost();
+#endif
+
     bool chosen = false;
     if (key_read_time < cost_est) {
       cost_est = key_read_time;
@@ -729,9 +750,23 @@ int test_quick_select(THD *thd, MEM_ROOT *return_mem_root,
       */
       Opt_trace_object trace_range_alt(trace, "analyzing_range_alternatives",
                                        Opt_trace_context::RANGE_OPTIMIZER);
+#ifdef WITH_SMARTENGINE
+      double read_cost = best_cost;
+      /**As stated above, if the conditions are met, the read cost will be set
+       * to the original cost. if this covered index is availablem it will still
+       * be selected in get_key_scans_params.*/
+      if ((DB_TYPE_SMARTENGINE == table->file->ht->db_type)
+          && (covering_index_cost == best_cost)) {
+          read_cost = base_cost;
+      }
+      AccessPath *range_path = get_key_scans_params(
+          thd, &param, tree, false, true, interesting_order,
+          skip_records_in_range, read_cost, /*ror_only=*/false, needed_reg);
+#else
       AccessPath *range_path = get_key_scans_params(
           thd, &param, tree, false, true, interesting_order,
           skip_records_in_range, best_cost, /*ror_only=*/false, needed_reg);
+#endif
 
       /* Get best 'range' plan and prepare data for making other plans */
       if (range_path) {
diff --git a/sql/replication.h b/sql/replication.h
index 6a60f207520..8467b501294 100644
--- a/sql/replication.h
+++ b/sql/replication.h
@@ -728,6 +728,164 @@ typedef struct Binlog_relay_IO_observer {
   applier_log_event_t applier_log_event;
 } Binlog_relay_IO_observer;
 
+#ifdef WESQL_CLUSTER
+class binlog_cache_data;
+class Format_description_log_event;
+class Log_event;
+class MYSQL_BIN_LOG;
+class Gtid_log_event;
+class Relay_log_info;
+class Rpl_applier_reader;
+class Slave_job_group;
+class THD;
+
+/**
+   Binlog applier observer parameters
+ */
+typedef struct Binlog_applier_param {
+  Relay_log_info *rli;
+} Binlog_applier_param;
+
+typedef int (*rli_init_info_t)(Binlog_applier_param *param,
+                          bool force_retriever_gtid, bool &exit_init);
+typedef int (*rli_end_info_t)(Binlog_applier_param *param, bool &exit_end);
+typedef int (*before_start_t)(Binlog_applier_param *param, ulong n_workers);
+typedef int (*on_mts_finalize_recovery_t)(Binlog_applier_param *param);
+typedef int (*on_mts_recovery_groups_t)(Binlog_applier_param *param,
+                                        bool &exit);
+typedef int (*after_stop_t)(Binlog_applier_param *param);
+typedef int (*before_read_next_event_t)(Binlog_applier_param *param,
+                                        bool &applier_stop);
+typedef int (*before_apply_event_t)(Binlog_applier_param *param, Log_event *ev);
+typedef int (*on_mts_groups_assigned_t)(Binlog_applier_param *param,
+                                        Slave_job_group *ptr_g);
+typedef int (*on_stmt_done_t)(Binlog_applier_param *param);
+typedef int (*on_commit_positions_t)(Binlog_applier_param *param,
+                                     Slave_job_group *ptr_g, bool check_xa);
+typedef int (*on_rollback_positions_t)(Binlog_applier_param *param);
+typedef int (*on_checkpoint_routine_t)(Binlog_applier_param *param);
+typedef int (*reader_before_open_t)(Binlog_applier_param *param,
+                             Rpl_applier_reader *applier_reader);
+typedef int (*reader_before_read_event_t)(Binlog_applier_param *param,
+                              Rpl_applier_reader *applier_reader);
+typedef int (*reader_before_close_t)(Binlog_applier_param *param,
+                                        Rpl_applier_reader *applier_reader);
+
+/**
+   Observe binlog applier
+*/
+typedef struct Binlog_applier_observer {
+  uint32 len;
+
+  rli_init_info_t rli_init_info;
+  rli_end_info_t rli_end_info;
+  before_start_t before_start;
+  on_mts_recovery_groups_t on_mts_recovery_groups;
+  on_mts_finalize_recovery_t on_mts_finalize_recovery;
+  after_stop_t after_stop;
+  before_read_next_event_t before_read_next_event;
+  before_apply_event_t before_apply_event;
+  on_mts_groups_assigned_t on_mts_groups_assigned;
+  on_stmt_done_t on_stmt_done;
+  on_commit_positions_t on_commit_positions;
+  on_rollback_positions_t on_rollback_positions;
+  on_checkpoint_routine_t on_checkpoint_routine;
+  reader_before_open_t reader_before_open;
+  reader_before_read_event_t reader_before_read_event;
+  reader_before_close_t reader_before_close;
+} Binlog_applier_observer;
+
+/**
+   Binlog manager observer parameters
+ */
+typedef struct Binlog_manager_param {
+  THD *thd;
+  MYSQL_BIN_LOG *binlog;
+} Binlog_manager_param;
+
+typedef int (*binlog_recovery_t)(Binlog_manager_param *param);
+typedef int (*after_binlog_recovery_t)(Binlog_manager_param *param);
+typedef int (*gtid_recovery_t)(Binlog_manager_param *param);
+typedef int (*new_file_t)(Binlog_manager_param *param,
+                          const char *log_file_name, bool null_created_arg,
+                          bool need_sid_lock,
+                          Format_description_log_event *extra_description_event,
+                          bool &write_file_name_to_index_file);
+typedef int (*after_purge_file_t)(Binlog_manager_param *param,
+                                  const char *log_file_name);
+typedef int (*rotate_and_purge_t)(Binlog_manager_param *param,
+                                  bool force_rotate);
+typedef int (*purge_logs_t)(Binlog_manager_param *param, ulong purge_time,
+                            ulong purge_size, const char *to_log,
+                            bool auto_purge);
+typedef int (*reencrypt_logs_t)(Binlog_manager_param *param);
+typedef int (*before_binlog_flush_t)(Binlog_manager_param *param);
+typedef int (*write_transaction_t)(Binlog_manager_param *param,
+                                   Gtid_log_event *gtid_event,
+                                   binlog_cache_data *cache_data,
+                                   bool have_checksum);
+typedef int (*after_queue_write_t)(Binlog_manager_param *param);
+typedef int (*after_queue_flush_t)(Binlog_manager_param *param,
+                                   bool &delay_update_binlog_pos);
+typedef int (*after_queue_sync_t)(Binlog_manager_param *param,
+                                  bool &delay_update_binlog_pos);
+typedef int (*after_enrolling_stage_t)(Binlog_manager_param *param, int stage);
+typedef int (*before_finish_in_engines_t)(Binlog_manager_param *param,
+                                          bool finish_commit);
+typedef int (*after_finish_commit_t)(Binlog_manager_param *param);
+typedef int (*before_rotate_and_purge_t)(Binlog_manager_param *param,
+                                         bool &do_rotate);
+typedef int (*after_rotate_and_purge_t)(Binlog_manager_param *param);
+
+typedef int (*get_unique_index_from_pos_t)(Binlog_manager_param *,
+                                           const char *log_file_name,
+                                           my_off_t log_pos,
+                                           uint64 &unique_index);
+typedef int (*get_pos_from_unique_index_t)(Binlog_manager_param *,
+                                           uint64 unique_index,
+                                           char *log_file_name,
+                                           my_off_t &log_pos);
+
+/**
+   Observe binlog applier
+*/
+typedef struct Binlog_manager_observer {
+  uint32 len;
+
+  binlog_recovery_t binlog_recovery;
+  after_binlog_recovery_t after_binlog_recovery;
+  gtid_recovery_t gtid_recovery;
+  new_file_t new_file;
+  after_purge_file_t after_purge_file;
+  before_binlog_flush_t before_binlog_flush;
+  write_transaction_t  write_transaction;
+  after_queue_write_t after_queue_write;
+  after_queue_flush_t after_queue_flush;
+  after_queue_sync_t after_queue_sync;
+  after_enrolling_stage_t after_enrolling_stage;
+  before_finish_in_engines_t before_finish_in_engines;
+  after_finish_commit_t after_finish_commit;
+  before_rotate_and_purge_t before_rotate_and_purge;
+  after_rotate_and_purge_t after_rotate_and_purge;
+
+  rotate_and_purge_t rotate_and_purge;
+  purge_logs_t purge_logs;
+  reencrypt_logs_t reencrypt_logs;
+
+  get_unique_index_from_pos_t get_unique_index_from_pos;
+  get_pos_from_unique_index_t get_pos_from_unique_index;
+} Binlog_manager_observer;
+
+int register_binlog_applier_observer(Binlog_applier_observer *observer,
+                                     void *p);
+int unregister_binlog_applier_observer(Binlog_applier_observer *observer,
+                                       void *);
+int register_binlog_manager_observer(Binlog_manager_observer *observer,
+                                     void *p);
+int unregister_binlog_manager_observer(Binlog_manager_observer *observer,
+                                       void *);
+#endif
+
 /**
    Register a transaction observer
 
diff --git a/sql/rpl_applier_reader.cc b/sql/rpl_applier_reader.cc
index 2d7b1b13d46..0141cc17f4a 100644
--- a/sql/rpl_applier_reader.cc
+++ b/sql/rpl_applier_reader.cc
@@ -261,6 +261,14 @@ bool Rpl_applier_reader::read_active_log_end_pos() {
   return false;
 }
 
+#ifdef WESQL_CLUSTER
+bool Rpl_applier_reader::reload_active_log_end_pos() {
+  m_log_end_pos = m_rli->relay_log.get_binlog_end_pos();
+  m_reading_active_log = m_rli->relay_log.is_active(m_linfo.log_file_name);
+  return reopen_log_reader_if_needed();
+}
+#endif
+
 Rotate_log_event *Rpl_applier_reader::generate_rotate_event() {
   DBUG_TRACE;
   Rotate_log_event *ev = nullptr;
@@ -341,6 +349,11 @@ bool Rpl_applier_reader::reopen_log_reader_if_needed() {
 
     my_off_t pos = m_relaylog_file_reader.position();
     m_relaylog_file_reader.close();
+#ifdef WESQL_CLUSTER
+    if (m_rli->info_thd->consensus_context.consensus_replication_applier) {
+      if (m_relaylog_file_reader.open(m_linfo.log_file_name, pos)) return true;
+    } else
+#endif
     if (m_relaylog_file_reader.open(m_linfo.log_file_name) ||
         m_relaylog_file_reader.seek(pos))
       return true;
@@ -416,6 +429,10 @@ bool Rpl_applier_reader::purge_applied_logs() {
 
   if (!relay_log_purge) return false;
 
+#ifdef WESQL_CLUSTER
+  if (!m_rli->relay_log.is_relay_log) return false;
+#endif
+
   // lock BACKUP lock for the duration of PURGE operation
   Shared_backup_lock_guard backup_lock{current_thd};
   switch (backup_lock) {
diff --git a/sql/rpl_applier_reader.h b/sql/rpl_applier_reader.h
index a8b01197669..94cb99fb6d3 100644
--- a/sql/rpl_applier_reader.h
+++ b/sql/rpl_applier_reader.h
@@ -83,6 +83,13 @@ class Rpl_applier_reader {
   */
   Log_event *read_next_event();
 
+#ifdef WESQL_CLUSTER
+  bool is_reading_active_log() { return m_reading_active_log; }
+  /* Purge logs by other thread and reset the log file index offset */
+  LOG_INFO *get_log_info() { return &m_linfo; }
+  bool reload_active_log_end_pos();
+#endif
+
  private:
   Relaylog_file_reader m_relaylog_file_reader;
   Relay_log_info *m_rli = nullptr;
diff --git a/sql/rpl_channel_service_interface.cc b/sql/rpl_channel_service_interface.cc
index 3e3698bb7b0..c701163742e 100644
--- a/sql/rpl_channel_service_interface.cc
+++ b/sql/rpl_channel_service_interface.cc
@@ -295,6 +295,12 @@ int channel_create(const char *channel, Channel_creation_info *channel_info) {
   if (!strcmp(channel_map.get_default_channel(), channel))
     return RPL_CHANNEL_SERVICE_DEFAULT_CHANNEL_CREATION_ERROR;
 
+#ifdef WESQL_CLUSTER
+  if (is_consensus_replication_enabled() &&
+      !strcmp(channel_map.get_consensus_replication_applier_channel(), channel))
+    return RPL_CHANNEL_SERVICE_DEFAULT_CHANNEL_CREATION_ERROR;
+#endif
+
   /* Service channels are not supposed to use sql_replica_skip_counter */
   mysql_mutex_lock(&LOCK_sql_replica_skip_counter);
   if (sql_replica_skip_counter > 0)
diff --git a/sql/rpl_channel_service_interface.h b/sql/rpl_channel_service_interface.h
index 23f441357e4..efd05f7e2c5 100644
--- a/sql/rpl_channel_service_interface.h
+++ b/sql/rpl_channel_service_interface.h
@@ -49,6 +49,9 @@
 */
 enum enum_channel_type {
   SLAVE_REPLICATION_CHANNEL,  // Master slave replication channels
+#ifdef WESQL_CLUSTER
+  CONSENSUS_REPLICATION_CHANNEL,
+#endif
   GROUP_REPLICATION_CHANNEL   // Group replication channels
 };
 
diff --git a/sql/rpl_commit_stage_manager.cc b/sql/rpl_commit_stage_manager.cc
index d13c9ee7beb..ab36048785f 100644
--- a/sql/rpl_commit_stage_manager.cc
+++ b/sql/rpl_commit_stage_manager.cc
@@ -33,6 +33,10 @@
 #include "sql/rpl_replica_commit_order_manager.h"  // Commit_order_manager
 #include "sql/rpl_rli_pdb.h"                       // Slave_worker
 
+#ifdef WESQL_CLUSTER
+#include "sql/rpl_handler.h"
+#endif
+
 class Slave_worker;
 class Commit_order_manager;
 
@@ -314,7 +318,7 @@ bool Commit_stage_manager::enroll_for(StageID stage, THD *thd,
     case COMMIT_STAGE:
       DEBUG_SYNC(thd, "bgc_after_enrolling_for_commit_stage");
       CONDITIONAL_SYNC_POINT_FOR_TIMESTAMP("after_writing_to_tc_log");
-      break;
+    break;
     case AFTER_COMMIT_STAGE:
       DEBUG_SYNC(thd, "bgc_after_enrolling_for_after_commit_stage");
       CONDITIONAL_SYNC_POINT_FOR_TIMESTAMP(
@@ -331,6 +335,11 @@ bool Commit_stage_manager::enroll_for(StageID stage, THD *thd,
   DBUG_EXECUTE_IF("assert_follower", assert(!leader););
 #endif
 
+#ifdef WESQL_CLUSTER
+  (void)RUN_HOOK(binlog_manager, after_enrolling_stage,
+                 (thd, &mysql_bin_log, stage));
+#endif
+
   /*
     If the queue was not empty, we're a follower and wait for the
     leader to process the queue. If we were holding a mutex, we have
diff --git a/sql/rpl_context.h b/sql/rpl_context.h
index b9c2b913522..24d6c281fd1 100644
--- a/sql/rpl_context.h
+++ b/sql/rpl_context.h
@@ -49,7 +49,8 @@ enum enum_rpl_channel_type {
   NO_CHANNEL_INFO = 0,       // No information exists about the channel
   RPL_STANDARD_CHANNEL = 1,  // It is a standard replication channel
   GR_APPLIER_CHANNEL = 2,    // It is a GR applier channel
-  GR_RECOVERY_CHANNEL = 3    // It is a GR recovery channel
+  GR_RECOVERY_CHANNEL = 3,   // It is a GR recovery channel
+  CR_APPLIER_CHANNEL = 4     // It is a CR applier channel
 };
 
 /**
diff --git a/sql/rpl_gtid_state.cc b/sql/rpl_gtid_state.cc
index 5dc91f51c5e..98e8f2af69a 100644
--- a/sql/rpl_gtid_state.cc
+++ b/sql/rpl_gtid_state.cc
@@ -880,7 +880,12 @@ void Gtid_state::update_gtids_impl_own_gtid(THD *thd, bool is_commit) {
     CONDITIONAL_SYNC_POINT_FOR_TIMESTAMP("before_gtid_externalization");
     executed_gtids._add_gtid(thd->owned_gtid);
     thd->rpl_thd_ctx.session_gtids_ctx().notify_after_gtid_executed_update(thd);
-    if (thd->slave_thread && opt_bin_log && !opt_log_replica_updates) {
+    if (thd->slave_thread &&
+#ifdef WESQL_CLUSTER
+        // consensus applier can't add owned gtid to lost and not in table set
+        !thd->consensus_context.consensus_replication_applier &&
+#endif
+        opt_bin_log && !opt_log_replica_updates) {
       lost_gtids._add_gtid(thd->owned_gtid);
       gtids_only_in_table._add_gtid(thd->owned_gtid);
     }
diff --git a/sql/rpl_handler.cc b/sql/rpl_handler.cc
index 9a1586214e0..f8ad08a5777 100644
--- a/sql/rpl_handler.cc
+++ b/sql/rpl_handler.cc
@@ -74,6 +74,11 @@ Server_state_delegate *server_state_delegate;
 Binlog_transmit_delegate *binlog_transmit_delegate;
 Binlog_relay_IO_delegate *binlog_relay_io_delegate;
 
+#ifdef WESQL_CLUSTER
+Binlog_applier_delegate *binlog_applier_delegate;
+Binlog_manager_delegate *binlog_manager_delegate;
+#endif
+
 bool opt_replication_optimize_for_static_plugin_config{false};
 std::atomic<bool> opt_replication_sender_observe_commit_only{false};
 
@@ -359,6 +364,12 @@ int delegates_init() {
       place_transmit_mem[sizeof(Binlog_transmit_delegate)];
   alignas(Binlog_relay_IO_delegate) static char
       place_relay_io_mem[sizeof(Binlog_relay_IO_delegate)];
+#ifdef WESQL_CLUSTER
+  alignas(Binlog_applier_delegate) static char
+      place_applier_mem[sizeof(Binlog_applier_delegate)];
+  alignas(Binlog_manager_delegate) static char
+      place_binlog_manager_mem[sizeof(Binlog_manager_delegate)];
+#endif
 
   transaction_delegate = new (place_trans_mem) Trans_delegate;
   if (!transaction_delegate->is_inited()) {
@@ -385,6 +396,21 @@ int delegates_init() {
     return 1;
   }
 
+#ifdef WESQL_CLUSTER
+  binlog_applier_delegate = new (place_applier_mem) Binlog_applier_delegate;
+  if (!binlog_applier_delegate->is_inited()) {
+    LogErr(ERROR_LEVEL, ER_RPL_BINLOG_TRANSMIT_DELEGATES_INIT_FAILED);
+    return 1;
+  }
+
+  binlog_manager_delegate =
+      new (place_binlog_manager_mem) Binlog_manager_delegate;
+  if (!binlog_manager_delegate->is_inited()) {
+    LogErr(ERROR_LEVEL, ER_RPL_BINLOG_RELAY_DELEGATES_INIT_FAILED);
+    return 1;
+  }
+#endif
+
   return 0;
 }
 
@@ -1292,6 +1318,347 @@ int Binlog_relay_IO_delegate::applier_log_event(THD *thd, int &out) {
   return ret;
 }
 
+#ifdef WESQL_CLUSTER
+int Binlog_applier_delegate::rli_init_info(Relay_log_info *rli,
+                                      bool force_retriever_gtid,
+                                      bool &exit_init) {
+  Binlog_applier_param param;
+  param.rli = rli;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, rli_init_info, (&param, force_retriever_gtid, exit_init));
+  return ret;
+}
+
+int Binlog_applier_delegate::rli_end_info(Relay_log_info *rli, bool &exit_end) {
+  Binlog_applier_param param;
+  param.rli = rli;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, rli_end_info, (&param, exit_end));
+  return ret;
+}
+
+int Binlog_applier_delegate::before_start(Relay_log_info *rli,
+                                          ulong n_workers) {
+  Binlog_applier_param param;
+  param.rli = rli;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, before_start, (&param, n_workers));
+  return ret;
+}
+
+int Binlog_applier_delegate::on_mts_recovery_groups(Relay_log_info *rli,
+                                                    bool &exit) {
+  Binlog_applier_param param;
+  param.rli = rli;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, on_mts_recovery_groups, (&param, exit));
+  return ret;
+}
+
+int Binlog_applier_delegate::on_mts_finalize_recovery(Relay_log_info *rli) {
+  Binlog_applier_param param;
+  param.rli = rli;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, on_mts_finalize_recovery, (&param));
+  return ret;
+}
+
+int Binlog_applier_delegate::after_stop(Relay_log_info *rli) {
+  Binlog_applier_param param;
+  param.rli = rli;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, after_stop, (&param));
+  return ret;
+}
+
+int Binlog_applier_delegate::reader_before_open(Relay_log_info *rli,
+                                         Rpl_applier_reader *applier_reader) {
+  Binlog_applier_param param;
+  param.rli = rli;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, reader_before_open, (&param, applier_reader));
+  return ret;
+}
+
+int Binlog_applier_delegate::reader_before_read_event(
+    Relay_log_info *rli, Rpl_applier_reader *applier_reader) {
+  Binlog_applier_param param;
+  param.rli = rli;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, reader_before_read_event, (&param, applier_reader));
+  return ret;
+}
+
+int Binlog_applier_delegate::reader_before_close(
+    Relay_log_info *rli, Rpl_applier_reader *applier_reader) {
+  Binlog_applier_param param;
+  param.rli = rli;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, reader_before_close, (&param, applier_reader));
+  return ret;
+}
+
+int Binlog_applier_delegate::before_read_next_event(Relay_log_info *rli,
+                                                    bool &applier_stop) {
+  Binlog_applier_param param;
+  param.rli = rli;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, before_read_next_event, (&param, applier_stop));
+  return ret;
+}
+
+int Binlog_applier_delegate::before_apply_event(Relay_log_info *rli,
+                                                Log_event *ev) {
+  Binlog_applier_param param;
+  param.rli = rli;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, before_apply_event, (&param, ev));
+  return ret;
+}
+
+int Binlog_applier_delegate::on_mts_groups_assigned(Relay_log_info *rli,
+                                                    Slave_job_group *ptr_g) {
+  Binlog_applier_param param;
+  param.rli = rli;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, on_mts_groups_assigned, (&param, ptr_g));
+  return ret;
+}
+
+int Binlog_applier_delegate::on_stmt_done(Relay_log_info *rli) {
+  Binlog_applier_param param;
+  param.rli = rli;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, on_stmt_done, (&param));
+  return ret;
+};
+
+int Binlog_applier_delegate::on_commit_positions(Relay_log_info *rli,
+                                                 Slave_job_group *ptr_g,
+                                                 bool check_xa) {
+  Binlog_applier_param param;
+  param.rli = rli;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, on_commit_positions, (&param, ptr_g, check_xa));
+  return ret;
+}
+
+int Binlog_applier_delegate::on_rollback_positions(Relay_log_info *rli) {
+  Binlog_applier_param param;
+  param.rli = rli;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, on_rollback_positions, (&param));
+  return ret;
+}
+
+int Binlog_applier_delegate::on_checkpoint_routine(Relay_log_info *rli) {
+  Binlog_applier_param param;
+  param.rli = rli;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, on_checkpoint_routine, (&param));
+  return ret;
+}
+
+int Binlog_manager_delegate::binlog_recovery(MYSQL_BIN_LOG *binlog) {
+  Binlog_manager_param param;
+  param.binlog = binlog;
+  param.thd = nullptr;
+
+  int ret = 0;
+  FOREACH_OBSERVER(ret, binlog_recovery, (&param));
+  return ret;
+}
+
+int Binlog_manager_delegate::after_binlog_recovery(MYSQL_BIN_LOG *binlog) {
+  Binlog_manager_param param;
+  param.binlog = binlog;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, after_binlog_recovery, (&param));
+  return ret;
+}
+
+int Binlog_manager_delegate::gtid_recovery(MYSQL_BIN_LOG *binlog) {
+  Binlog_manager_param param;
+  param.binlog = binlog;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, gtid_recovery, (&param));
+  return ret;
+}
+
+int Binlog_manager_delegate::new_file(
+    MYSQL_BIN_LOG *binlog, const char *log_file_name, bool null_created_arg,
+    bool need_sid_lock, Format_description_log_event *extra_description_event,
+    bool &write_file_name_to_index_file) {
+  Binlog_manager_param param;
+  param.binlog = binlog;
+  param.thd = nullptr;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, new_file,
+                   (&param, log_file_name, null_created_arg, need_sid_lock,
+                    extra_description_event, write_file_name_to_index_file));
+  return ret;
+}
+
+int Binlog_manager_delegate::after_purge_file(MYSQL_BIN_LOG *binlog,
+                                              const char *log_file_name) {
+  Binlog_manager_param param;
+  param.binlog = binlog;
+  param.thd = nullptr;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, after_purge_file, (&param, log_file_name));
+  return ret;
+}
+
+int Binlog_manager_delegate::before_binlog_flush(THD *thd) {
+  Binlog_manager_param param;
+  param.binlog = nullptr;
+  param.thd = thd;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, before_binlog_flush, (&param));
+  return ret;
+}
+
+int Binlog_manager_delegate::write_transaction(THD *thd, MYSQL_BIN_LOG *binlog,
+                                               Gtid_log_event *gtid_event,
+                                               binlog_cache_data *cache_data,
+                                               bool have_checksum) {
+  Binlog_manager_param param;
+  param.binlog = binlog;
+  param.thd = thd;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, write_transaction,
+                   (&param, gtid_event, cache_data, have_checksum));
+  return ret;
+}
+
+int Binlog_manager_delegate::after_queue_write(THD *thd) {
+  Binlog_manager_param param;
+  param.thd = thd;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, after_queue_write, (&param));
+  return ret;
+}
+
+int Binlog_manager_delegate::after_queue_flush(THD *thd,
+                                               bool &delay_update_binlog_pos) {
+  Binlog_manager_param param;
+  param.thd = thd;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, after_queue_flush, (&param, delay_update_binlog_pos));
+  return ret;
+}
+
+int Binlog_manager_delegate::after_queue_sync(THD *thd,
+                                              bool &delay_update_binlog_pos) {
+  Binlog_manager_param param;
+  param.thd = thd;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, after_queue_sync, (&param, delay_update_binlog_pos));
+  return ret;
+}
+
+int Binlog_manager_delegate::after_enrolling_stage(THD *thd,
+                                                   MYSQL_BIN_LOG *binlog,
+                                                   int stage) {
+  Binlog_manager_param param;
+  param.thd = thd;
+  param.binlog = binlog;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, after_enrolling_stage, (&param, stage));
+  return ret;
+}
+
+int Binlog_manager_delegate::before_finish_in_engines(THD *thd,
+                                                      bool finish_commit) {
+  Binlog_manager_param param;
+  param.thd = thd;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, before_finish_in_engines, (&param, finish_commit));
+  return ret;
+}
+
+int Binlog_manager_delegate::after_finish_commit(THD *thd) {
+  Binlog_manager_param param;
+  param.thd = thd;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, after_finish_commit, (&param));
+  return ret;
+}
+
+int Binlog_manager_delegate::before_rotate_and_purge(THD *thd,
+                                                     MYSQL_BIN_LOG *binlog,
+                                                     bool &do_rotate) {
+  Binlog_manager_param param;
+  param.thd = thd;
+  param.binlog = binlog;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, before_rotate_and_purge, (&param, do_rotate));
+  return ret;
+}
+
+int Binlog_manager_delegate::after_rotate_and_purge(THD *thd,
+                                                    MYSQL_BIN_LOG *binlog) {
+  Binlog_manager_param param;
+  param.thd = thd;
+  param.binlog = binlog;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, after_rotate_and_purge, (&param));
+  return ret;
+}
+
+int Binlog_manager_delegate::rotate_and_purge(THD *thd, bool force_rotate) {
+  Binlog_manager_param param;
+  param.thd = thd;
+  param.binlog = nullptr;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, rotate_and_purge, (&param, force_rotate));
+  return ret;
+}
+
+int Binlog_manager_delegate::reencrypt_logs() {
+  Binlog_manager_param param;
+  param.thd = nullptr;
+  param.binlog = nullptr;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, reencrypt_logs, (&param));
+  return ret;
+}
+
+int Binlog_manager_delegate::purge_logs(ulong purge_time, ulong purge_size,
+                                        const char *to_log, bool auto_purge) {
+  Binlog_manager_param param;
+  param.thd = nullptr;
+  param.binlog = nullptr;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, purge_logs,
+                   (&param, purge_time, purge_size, to_log, auto_purge));
+  return ret;
+}
+
+int Binlog_manager_delegate::get_unique_index_from_pos(
+    const char *log_file_name, my_off_t log_pos, uint64 &unique_index) {
+  Binlog_manager_param param;
+  param.thd = nullptr;
+  param.binlog = nullptr;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, get_unique_index_from_pos,
+                   (&param, log_file_name, log_pos, unique_index));
+  return ret;
+}
+
+int Binlog_manager_delegate::get_pos_from_unique_index(uint64 unique_index,
+                                                       char *log_file_name,
+                                                       my_off_t &log_pos) {
+  Binlog_manager_param param;
+  param.thd = nullptr;
+  param.binlog = nullptr;
+  int ret = 0;
+  FOREACH_OBSERVER(ret, get_pos_from_unique_index,
+                   (&param, unique_index, log_file_name, log_pos));
+  return ret;
+}
+#endif
+
 int register_trans_observer(Trans_observer *observer, void *p) {
   return transaction_delegate->add_observer(observer, (st_plugin_int *)p);
 }
@@ -1347,6 +1714,28 @@ int unregister_binlog_relay_io_observer(Binlog_relay_IO_observer *observer,
   return binlog_relay_io_delegate->remove_observer(observer);
 }
 
+#ifdef WESQL_CLUSTER
+int register_binlog_applier_observer(Binlog_applier_observer *observer,
+                                      void *p) {
+  return binlog_applier_delegate->add_observer(observer, (st_plugin_int *)p);
+}
+
+int unregister_binlog_applier_observer(Binlog_applier_observer *observer,
+                                        void *) {
+  return binlog_applier_delegate->remove_observer(observer);
+}
+
+int register_binlog_manager_observer(Binlog_manager_observer *observer,
+                                     void *p) {
+  return binlog_manager_delegate->add_observer(observer, (st_plugin_int *)p);
+}
+
+int unregister_binlog_manager_observer(Binlog_manager_observer *observer,
+                                       void *) {
+  return binlog_manager_delegate->remove_observer(observer);
+}
+#endif
+
 static bool is_show_status(enum_sql_command sql_command) {
   switch (sql_command) {
     case SQLCOM_SHOW_VARIABLES:
diff --git a/sql/rpl_handler.h b/sql/rpl_handler.h
index d06f4c8071b..7022145df85 100644
--- a/sql/rpl_handler.h
+++ b/sql/rpl_handler.h
@@ -424,6 +424,107 @@ class Binlog_relay_IO_delegate : public Delegate {
   void init_param(Binlog_relay_IO_param *param, Master_info *mi);
 };
 
+#ifdef WESQL_CLUSTER
+struct Binlog_applier_observer;
+struct Binlog_manager_observer;
+
+class Relay_log_info;
+class Rpl_applier_reader;
+class MYSQL_BIN_LOG;
+class Log_event;
+class Slave_job_group;
+class Gtid_log_event;
+class binlog_cache_data;
+class Format_description_log_event;
+
+#ifdef HAVE_PSI_RWLOCK_INTERFACE
+extern PSI_rwlock_key key_rwlock_Binlog_applier_delegate_lock;
+#endif
+
+class Binlog_applier_delegate : public Delegate {
+ public:
+  Binlog_applier_delegate()
+      : Delegate(
+#ifdef HAVE_PSI_RWLOCK_INTERFACE
+            key_rwlock_Binlog_applier_delegate_lock
+#endif
+        ) {
+  }
+
+  typedef Binlog_applier_observer Observer;
+
+  int rli_init_info(Relay_log_info *rli, bool force_retriever_gtid, bool &exit_init);
+  int rli_end_info(Relay_log_info *rli, bool &exit_end);
+  int before_start(Relay_log_info *rli, ulong u_workers);
+  int on_mts_recovery_groups(Relay_log_info *rli, bool &exit);
+  int on_mts_finalize_recovery(Relay_log_info *rli);
+  int after_stop(Relay_log_info *rli);
+  int before_read_next_event(Relay_log_info *rli, bool &applier_stop);
+  int before_apply_event(Relay_log_info *rli, Log_event *ev);
+  int on_mts_groups_assigned(Relay_log_info *rli, Slave_job_group *ptr_g);
+  int on_stmt_done(Relay_log_info *rli);
+  int on_commit_positions(Relay_log_info *rli, Slave_job_group *ptr_g,
+                          bool check_xa);
+  int on_rollback_positions(Relay_log_info *rli);
+  int on_checkpoint_routine(Relay_log_info *rli);
+  int reader_before_open(Relay_log_info *rli,
+                         Rpl_applier_reader *applier_reader);
+  int reader_before_read_event(Relay_log_info *rli,
+                               Rpl_applier_reader *applier_reader);
+  int reader_before_close(Relay_log_info *rli,
+                          Rpl_applier_reader *applier_reader);
+};
+
+
+#ifdef HAVE_PSI_RWLOCK_INTERFACE
+extern PSI_rwlock_key key_rwlock_Binlog_manager_delegate_lock;
+#endif
+
+class Binlog_manager_delegate : public Delegate {
+ public:
+  Binlog_manager_delegate()
+      : Delegate(
+#ifdef HAVE_PSI_RWLOCK_INTERFACE
+            key_rwlock_Binlog_manager_delegate_lock
+#endif
+        ) {
+  }
+
+  typedef Binlog_manager_observer Observer;
+
+  int binlog_recovery(MYSQL_BIN_LOG *binlog);
+  int after_binlog_recovery(MYSQL_BIN_LOG *binlog);
+  int gtid_recovery(MYSQL_BIN_LOG *binlog);
+  int new_file(MYSQL_BIN_LOG *binlog, const char *log_file_name,
+               bool null_created_arg, bool need_sid_lock,
+               Format_description_log_event *extra_description_event,
+               bool &write_file_name_to_index_file);
+  int after_purge_file(MYSQL_BIN_LOG *binlog, const char *log_file_name);
+  int before_binlog_flush(THD *thd);
+  int write_transaction(THD *thd, MYSQL_BIN_LOG *binlog,
+                        Gtid_log_event *gtid_event, binlog_cache_data *cache_data,
+                        bool have_checksum);
+  int after_queue_write(THD *thd);
+  int after_queue_flush(THD *thd, bool &delay_update_binlog_pos);
+  int after_queue_sync(THD *thd, bool &delay_update_binlog_pos);
+  int after_enrolling_stage(THD *thd, MYSQL_BIN_LOG *binlog, int stage);
+  int before_finish_in_engines(THD *thd, bool finish_commit);
+  int after_finish_commit(THD *thd);
+  int before_rotate_and_purge(THD *thd, MYSQL_BIN_LOG *binlog, bool &do_rotate);
+  int after_rotate_and_purge(THD *thd, MYSQL_BIN_LOG *binlog);
+
+  int rotate_and_purge(THD *thd, bool force_rotate);
+  int reencrypt_logs();
+  int purge_logs(ulong purge_time, ulong purge_size, const char *to_log,
+                 bool auto_purge);
+
+  int get_unique_index_from_pos(const char *log_file_name, my_off_t log_pos,
+                                uint64 &unique_index);
+  int get_pos_from_unique_index(uint64 unique_index, char *log_file_name,
+                                my_off_t &log_pos);
+};
+#endif
+
 int delegates_init();
 /**
   Verify that the replication plugins are ready and OK to be unloaded.
@@ -450,6 +551,11 @@ extern Server_state_delegate *server_state_delegate;
 extern Binlog_transmit_delegate *binlog_transmit_delegate;
 extern Binlog_relay_IO_delegate *binlog_relay_io_delegate;
 
+#ifdef WESQL_CLUSTER
+extern Binlog_applier_delegate *binlog_applier_delegate;
+extern Binlog_manager_delegate *binlog_manager_delegate;
+#endif
+
 /*
   if there is no observers in the delegate, we can return 0
   immediately.
diff --git a/sql/rpl_info_factory.cc b/sql/rpl_info_factory.cc
index 4d18919b2a4..a7ac745988b 100644
--- a/sql/rpl_info_factory.cc
+++ b/sql/rpl_info_factory.cc
@@ -984,6 +984,12 @@ bool Rpl_info_factory::configure_channel_replication_filters(
   */
   if (channel_map.is_group_replication_channel_name(channel_name)) return false;
 
+
+#ifdef WESQL_CLUSTER
+  /* Consensus replication channels should not be configurable */
+  if (channel_map.is_consensus_replication_channel_name(channel_name)) return false;
+#endif
+
   if (Master_info::is_configured(rli->mi)) {
     /*
       A slave replication channel would copy global replication filters
diff --git a/sql/rpl_info_factory.h b/sql/rpl_info_factory.h
index 3f220002e50..f6d0016e20c 100644
--- a/sql/rpl_info_factory.h
+++ b/sql/rpl_info_factory.h
@@ -31,6 +31,10 @@
 #include "my_io.h"
 #include "sql/rpl_info_handler.h"  // enum_return_check
 
+#ifdef WESQL_CLUSTER
+class Consensus_info_factory;
+#endif
+
 class Master_info;
 class Multisource_info;
 class Relay_log_info;
@@ -177,6 +181,9 @@ class Rpl_info_factory {
   static bool load_channel_names_from_table(
       std::vector<std::string> &channel_list, const char *default_channel,
       bool *default_channel_created_previously);
+#ifdef WESQL_CLUSTER
+  friend class Consensus_info_factory;
+#endif
 };
 
 #endif
diff --git a/sql/rpl_info_table.cc b/sql/rpl_info_table.cc
index 85765e16a0a..96475a68d91 100644
--- a/sql/rpl_info_table.cc
+++ b/sql/rpl_info_table.cc
@@ -421,6 +421,87 @@ end:
   return error;
 }
 
+#ifdef WESQL_CLUSTER
+/**
+   Removes all records
+
+   @param nparam             number of fields in the table
+   @param param_schema       schema name
+   @param param_table        table name
+   @param nullable_bitmap    fields allowed to be null.
+
+   @return 0   on success
+           1   when a failure happens
+*/
+int Rpl_info_table::do_reset_all_info(uint nparam, const char *param_schema,
+                                      const char *param_table,
+                                      MY_BITMAP const *nullable_bitmap) {
+  int error = 0;
+  TABLE *table = nullptr;
+  sql_mode_t saved_mode;
+  Open_tables_backup backup;
+  Rpl_info_table *info = nullptr;
+  THD *thd = nullptr;
+  int handler_error = 0;
+
+  DBUG_TRACE;
+
+  if (!(info = new Rpl_info_table(nparam, param_schema, param_table, 0, nullptr,
+                                  nullable_bitmap)))
+    return 1;
+
+  thd = info->access->create_thd();
+  saved_mode = thd->variables.sql_mode;
+  ulonglong saved_options = thd->variables.option_bits;
+  thd->variables.option_bits &= ~OPTION_BIN_LOG;
+
+  /*
+    Opens and locks the rpl_info table before accessing it.
+  */
+  if (info->access->open_table(thd, to_lex_cstring(info->str_schema),
+                               to_lex_cstring(info->str_table),
+                               info->get_number_info(), TL_WRITE, &table,
+                               &backup)) {
+    error = 1;
+    goto end;
+  }
+
+  if (!(handler_error = table->file->ha_index_init(0, true))) {
+    if (info->verify_table_primary_key_fields(table)) {
+      error = 1;
+      table->file->ha_index_end();
+      goto end;
+    }
+
+    if (!(handler_error = table->file->ha_index_first(table->record[0]))) {
+      do {
+        if ((handler_error = table->file->ha_delete_row(table->record[0])))
+          break;
+      } while (!(handler_error = table->file->ha_index_next(table->record[0])));
+      if (handler_error != HA_ERR_END_OF_FILE) error = 1;
+    } else {
+      /*
+        Being reset table can be even empty, and that's benign.
+      */
+      if (handler_error != HA_ERR_END_OF_FILE) error = 1;
+    }
+
+    if (error) table->file->print_error(handler_error, MYF(0));
+    table->file->ha_index_end();
+  }
+end:
+  /*
+    Unlocks and closes the rpl_info table.
+  */
+  error = info->access->close_table(thd, table, &backup, error) || error;
+  thd->variables.sql_mode = saved_mode;
+  thd->variables.option_bits = saved_options;
+  info->access->drop_thd(thd);
+  delete info;
+  return error;
+}
+#endif
+
 enum_return_check Rpl_info_table::do_check_info() {
   TABLE *table = nullptr;
   sql_mode_t saved_mode;
diff --git a/sql/rpl_info_table.h b/sql/rpl_info_table.h
index 8bb4bcbff04..1bc6c045ff1 100644
--- a/sql/rpl_info_table.h
+++ b/sql/rpl_info_table.h
@@ -46,6 +46,9 @@ enum enum_find_method { FIND_SCAN, FIND_KEY };
 
 class Rpl_info_table : public Rpl_info_handler {
   friend class Rpl_info_factory;
+#ifdef WESQL_CLUSTER
+  friend class Consensus_info_factory;
+#endif
 
  public:
   ~Rpl_info_table() override;
@@ -158,6 +161,11 @@ class Rpl_info_table : public Rpl_info_handler {
   static int do_reset_info(uint nparam, const char *param_schema,
                            const char *param_table, const char *channel_name,
                            MY_BITMAP const *nullable_bitmap);
+#ifdef WESQL_CLUSTER
+  static int do_reset_all_info(uint nparam, const char *param_schema,
+                               const char *param_table,
+                               MY_BITMAP const *nullable_bitmap);
+#endif
   int do_prepare_info_for_read() override;
   int do_prepare_info_for_write() override;
 
diff --git a/sql/rpl_log_encryption.cc b/sql/rpl_log_encryption.cc
index 00a56080dd9..a446c1d2772 100644
--- a/sql/rpl_log_encryption.cc
+++ b/sql/rpl_log_encryption.cc
@@ -43,6 +43,10 @@
 #include "sql/rpl_replica.h"
 #include "sql/server_component/mysql_server_keyring_lockable_imp.h"
 
+#ifdef WESQL_CLUSTER
+#include "sql/rpl_handler.h"
+#endif
+
 Rpl_encryption rpl_encryption;
 
 void Rpl_encryption::report_keyring_error(Keyring_status error) {
@@ -645,6 +649,15 @@ bool Rpl_encryption::rotate_master_key(Key_rotation_step step,
           Rotate binary logs and re-encrypt previous existent
           binary logs.
         */
+#ifdef WESQL_CLUSTER
+        if (!NO_HOOK(binlog_manager)) {
+          if (DBUG_EVALUATE_IF("fail_to_rotate_binary_log", true, false) ||
+              RUN_HOOK(binlog_manager, rotate_and_purge, (current_thd, true))) {
+            goto err2;
+          }
+          if (RUN_HOOK(binlog_manager, reencrypt_logs, ())) return true;
+        } else
+#endif
         if (mysql_bin_log.is_open()) {
           if (DBUG_EVALUATE_IF("fail_to_rotate_binary_log", true, false) ||
               mysql_bin_log.rotate_and_purge(current_thd, true)) {
@@ -730,6 +743,14 @@ err2:
 
 void Rpl_encryption::rotate_logs(THD *thd) {
   DBUG_TRACE;
+
+#ifdef WESQL_CLUSTER
+  if (!NO_HOOK(binlog_manager)) {
+    if (RUN_HOOK(binlog_manager, rotate_and_purge, (thd, true)))
+      push_warning(thd, ER_RPL_ENCRYPTION_FAILED_TO_ROTATE_LOGS);
+    return;
+  }
+#endif
   if ((mysql_bin_log.is_open() && mysql_bin_log.rotate_and_purge(thd, true)) ||
       flush_relay_logs_cmd(thd)) {
     push_warning(thd, ER_RPL_ENCRYPTION_FAILED_TO_ROTATE_LOGS);
diff --git a/sql/rpl_msr.cc b/sql/rpl_msr.cc
index 167843a9f6f..67366adabc9 100644
--- a/sql/rpl_msr.cc
+++ b/sql/rpl_msr.cc
@@ -37,6 +37,11 @@ const char *Multisource_info::default_channel = "";
 const char *Multisource_info::group_replication_channel_names[] = {
     "group_replication_applier", "group_replication_recovery"};
 
+#ifdef WESQL_CLUSTER
+const char *Multisource_info::consensus_replication_applier =
+    "raft_replication_applier";
+#endif
+
 bool Multisource_info::add_mi(const char *channel_name, Master_info *mi) {
   DBUG_TRACE;
 
@@ -52,6 +57,10 @@ bool Multisource_info::add_mi(const char *channel_name, Master_info *mi) {
   replication_channel_map::iterator map_it;
   enum_channel_type type = is_group_replication_channel_name(channel_name)
                                ? GROUP_REPLICATION_CHANNEL
+#ifdef WESQL_CLUSTER
+                           : is_consensus_replication_channel_name(channel_name)
+                               ? CONSENSUS_REPLICATION_CHANNEL
+#endif
                                : SLAVE_REPLICATION_CHANNEL;
 
   map_it = rep_channel_map.find(type);
@@ -100,6 +109,13 @@ Master_info *Multisource_info::get_mi(const char *channel_name) {
   if (map_it ==
           rep_channel_map.end() ||  // If not a slave channel, maybe a group one
       it == map_it->second.end()) {
+#ifdef WESQL_CLUSTER
+   map_it = rep_channel_map.find(CONSENSUS_REPLICATION_CHANNEL);
+    if (map_it != rep_channel_map.end()) {
+      it = map_it->second.find(channel_name);
+      if (it != map_it->second.end()) return it->second;
+    }
+#endif
     map_it = rep_channel_map.find(GROUP_REPLICATION_CHANNEL);
     if (map_it == rep_channel_map.end()) {
       return nullptr;
@@ -188,6 +204,15 @@ bool Multisource_info::is_group_replication_channel_name(const char *channel,
            !strcmp(channel, group_replication_channel_names[1]);
 }
 
+#ifdef WESQL_CLUSTER
+bool Multisource_info::is_consensus_replication_channel_name(
+    const char *channel) {
+  /* for capability */
+  if (!channel) return true;
+  return !strcmp(channel, consensus_replication_applier);
+}
+#endif
+
 #ifdef WITH_PERFSCHEMA_STORAGE_ENGINE
 
 bool Multisource_info::add_mi_to_rpl_pfs_mi(Master_info *mi) {
diff --git a/sql/rpl_msr.h b/sql/rpl_msr.h
index b11348b5b48..346978f5c55 100644
--- a/sql/rpl_msr.h
+++ b/sql/rpl_msr.h
@@ -127,6 +127,9 @@ class Multisource_info {
   static const char *default_channel;
   Master_info *default_channel_mi;
   static const char *group_replication_channel_names[];
+#ifdef WESQL_CLUSTER
+  static const char *consensus_replication_applier;
+#endif
 
   /**
     This lock was designed to protect the channel_map from adding or removing
@@ -232,6 +235,15 @@ class Multisource_info {
   */
   inline const char *get_default_channel() { return default_channel; }
 
+#ifdef WESQL_CLUSTER
+  /**
+    Get the default channel for this multisourced_slave;
+  */
+  inline const char *get_consensus_replication_applier_channel() {
+    return consensus_replication_applier;
+  }
+#endif
+
   /**
     Get the number of instances of Master_info in the map.
 
@@ -331,6 +343,19 @@ class Multisource_info {
   bool is_group_replication_channel_name(const char *channel,
                                          bool is_applier = false);
 
+#ifdef WESQL_CLUSTER
+  /**
+    Returns if a channel name is one consensus replication names
+
+    @param channel    the channel name to test
+
+    @return
+      @retval      true   the name is a reserved name
+      @retval      false  non reserved name
+  */
+  bool is_consensus_replication_channel_name(const char *channel);
+#endif
+
   /**
      Forward iterators to initiate traversing of a map.
 
diff --git a/sql/rpl_replica.cc b/sql/rpl_replica.cc
index 57dfb700ea5..c2817e34ad5 100644
--- a/sql/rpl_replica.cc
+++ b/sql/rpl_replica.cc
@@ -650,6 +650,21 @@ bool start_slave(THD *thd) {
       }
     }
   }
+
+#ifdef WESQL_CLUSTER
+  if (is_consensus_replication_enabled() &&
+      is_consensus_replication_applier_running() &&
+      (thd->lex->slave_thd_opt &&
+       (thd->lex->slave_thd_opt & SLAVE_IO) != SLAVE_IO)) {
+    mi = channel_map.get_mi(
+        channel_map.get_consensus_replication_applier_channel());
+    assert(mi && Master_info::is_configured(mi));
+    if (start_slave(thd, &thd->lex->slave_connection, &thd->lex->mi,
+                    thd->lex->slave_thd_opt, mi, true))
+      return true;
+  }
+#endif
+
   if (!error) {
     /* no error */
     my_ok(thd);
@@ -697,6 +712,24 @@ int stop_slave(THD *thd) {
     }
   }
 
+#ifdef WESQL_CLUSTER
+  // stop consensus channel STOP SLAVE SQL_THREAD
+  if (is_consensus_replication_enabled() &&
+      is_consensus_replication_applier_running() &&
+      (thd->lex->slave_thd_opt &&
+       (thd->lex->slave_thd_opt & SLAVE_IO) != SLAVE_IO)) {
+    mi = channel_map.get_mi(
+        channel_map.get_consensus_replication_applier_channel());
+    assert(mi && Master_info::is_configured(mi));
+    if (stop_slave(thd, mi, true, false /*for_one_channel*/,
+                   &push_temp_table_warning)) {
+      LogErr(ERROR_LEVEL, ER_RPL_REPLICA_CANT_STOP_REPLICA_FOR_CHANNEL,
+             mi->get_channel());
+      error = 1;
+    }
+  }
+#endif
+
   if (!error) {
     /* no error */
     my_ok(thd);
@@ -790,6 +823,26 @@ bool start_slave_cmd(THD *thd) {
       goto err;
     }
 
+#ifdef WESQL_CLUSTER
+    /*
+      For channel consensus_replication_applier we disable START SLAVE [IO_THREAD]
+      command.
+    */
+    if (mi && is_consensus_replication_enabled() &&
+        channel_map.is_consensus_replication_channel_name(mi->get_channel()) &&
+        (!is_consensus_replication_applier_running() ||
+         !thd->lex->slave_thd_opt || (thd->lex->slave_thd_opt & SLAVE_IO))) {
+      const char *command = "START SLAVE FOR CHANNEL";
+      if (thd->lex->slave_thd_opt & SLAVE_IO)
+        command = "START SLAVE IO_THREAD FOR CHANNEL";
+
+      my_error(ER_REPLICA_CHANNEL_OPERATION_NOT_ALLOWED, MYF(0), command,
+               mi->get_channel(), command);
+
+      goto err;
+    }
+#endif
+
     if (mi)
       res = start_slave(thd, &thd->lex->slave_connection, &thd->lex->mi,
                         thd->lex->slave_thd_opt, mi, true);
@@ -890,6 +943,27 @@ bool stop_slave_cmd(THD *thd) {
       return true;
     }
 
+#ifdef WESQL_CLUSTER
+    /*
+      For channel consensus_replication_applier we disable START SLAVE [IO_THREAD]
+      command.
+    */
+    if (mi && is_consensus_replication_enabled() &&
+        channel_map.is_consensus_replication_channel_name(mi->get_channel()) &&
+        (!is_consensus_replication_applier_running() ||
+         !thd->lex->slave_thd_opt || (thd->lex->slave_thd_opt & SLAVE_IO))) {
+      const char *command = "STOP SLAVE FOR CHANNEL";
+      if (thd->lex->slave_thd_opt & SLAVE_IO)
+        command = "STOP SLAVE SQL_THREAD FOR CHANNEL";
+
+      my_error(ER_REPLICA_CHANNEL_OPERATION_NOT_ALLOWED, MYF(0), command,
+               mi->get_channel(), command);
+
+      channel_map.unlock();
+      return true;
+    }
+#endif
+
     if (mi)
       res = stop_slave(thd, mi, true /*net report */, true /*for_one_channel*/,
                        &push_temp_table_warning);
@@ -2206,6 +2280,24 @@ void delete_slave_info_objects() {
     }
   }
 
+#ifdef WESQL_CLUSTER
+  // Clean other types of channel
+  if (is_consensus_replication_enabled()) {
+    for (mi_map::iterator it = channel_map.begin(CONSENSUS_REPLICATION_CHANNEL);
+         it != channel_map.end(CONSENSUS_REPLICATION_CHANNEL); it++) {
+      mi = it->second;
+
+      if (mi) {
+        mi->channel_wrlock();
+        end_info(mi);
+        if (mi->rli) delete mi->rli;
+        delete mi;
+        it->second = 0;
+      }
+    }
+  }
+#endif
+
   channel_map.unlock();
 }
 
@@ -3992,7 +4084,11 @@ void set_slave_thread_options(THD *thd) {
      only for client threads.
   */
   ulonglong options = thd->variables.option_bits | OPTION_BIG_SELECTS;
-  if (opt_log_replica_updates)
+  if (opt_log_replica_updates
+#ifdef WESQL_CLUSTER
+      && !thd->consensus_context.consensus_replication_applier
+#endif
+  )
     options |= OPTION_BIN_LOG;
   else
     options &= ~OPTION_BIN_LOG;
@@ -4360,6 +4456,11 @@ static int sql_delay_event(Log_event *ev, THD *thd, Relay_log_info *rli) {
       */
       if (type != binary_log::ROTATE_EVENT &&
           type != binary_log::FORMAT_DESCRIPTION_EVENT &&
+#ifdef WESQL_CLUSTER
+          !ev->is_consensus_event() &&
+          (!rli->relay_log.is_consensus_write ||
+           ev->get_type_code() != binary_log::ROTATE_EVENT) &&
+#endif
           type != binary_log::PREVIOUS_GTIDS_LOG_EVENT) {
         // Calculate when we should execute the event.
         sql_delay_end = ev->common_header->when.tv_sec +
@@ -4722,6 +4823,12 @@ apply_event_and_update_pos(Log_event **ptr_ev, THD *thd, Relay_log_info *rli) {
     if (!error && rli->is_mts_recovery() &&
         ev->get_type_code() != binary_log::ROTATE_EVENT &&
         ev->get_type_code() != binary_log::FORMAT_DESCRIPTION_EVENT &&
+#ifdef WESQL_CLUSTER
+        ev->get_type_code() != binary_log::PREVIOUS_CONSENSUS_INDEX_LOG_EVENT &&
+        ev->get_type_code() != binary_log::CONSENSUS_LOG_EVENT &&
+        ev->get_type_code() != binary_log::CONSENSUS_CLUSTER_INFO_EVENT &&
+        ev->get_type_code() != binary_log::CONSENSUS_EMPTY_EVENT &&
+#endif
         ev->get_type_code() != binary_log::PREVIOUS_GTIDS_LOG_EVENT) {
       if (ev->starts_group()) {
         rli->mts_recovery_group_seen_begin = true;
@@ -4961,6 +5068,11 @@ static int exec_relay_log_event(THD *thd, Relay_log_info *rli,
     */
     if ((!rli->is_parallel_exec() || rli->last_master_timestamp == 0) &&
         !(ev->is_artificial_event() || ev->is_relay_log_event() ||
+#ifdef WESQL_CLUSTER
+          ev->is_consensus_event() ||
+          (!rli->relay_log.is_consensus_write &&
+           ev->get_type_code() == binary_log::ROTATE_EVENT) ||
+#endif
           ev->get_type_code() == binary_log::FORMAT_DESCRIPTION_EVENT ||
           ev->server_id == 0)) {
       rli->last_master_timestamp =
@@ -5020,6 +5132,15 @@ static int exec_relay_log_event(THD *thd, Relay_log_info *rli,
         return 1;
     }
 
+#ifdef WESQL_CLUSTER
+    if (RUN_HOOK(binlog_applier, before_apply_event, (rli, ev))) {
+      rli->abort_slave = true;
+      mysql_mutex_unlock(&rli->data_lock);
+      delete ev;
+      return SLAVE_APPLY_EVENT_AND_UPDATE_POS_UPDATE_POS_ERROR;
+    }
+#endif
+
     /* ptr_ev can change to NULL indicating MTS coorinator passed to a Worker */
     exec_res = apply_event_and_update_pos(ptr_ev, thd, rli);
     /*
@@ -6023,6 +6144,10 @@ static void *handle_slave_worker(void *arg) {
 
   thd->variables.require_row_format = rli->is_row_format_required();
 
+#ifdef WESQL_CLUSTER
+  if (RUN_HOOK(binlog_applier, before_start, (w, 0))) goto err;
+#endif
+
   if (Relay_log_info::PK_CHECK_STREAM !=
       rli->get_require_table_primary_key_check())
     thd->variables.sql_require_primary_key =
@@ -6104,6 +6229,10 @@ static void *handle_slave_worker(void *arg) {
 
   mysql_mutex_unlock(&rli->pending_jobs_lock);
 
+#ifdef WESQL_CLUSTER
+  if (RUN_HOOK(binlog_applier, after_stop, (w))) goto err;
+#endif
+
   /*
      In MTS case cleanup_after_session() has be called explicitly.
      TODO: to make worker thd be deleted before Slave_worker instance.
@@ -6186,6 +6315,16 @@ bool mts_recovery_groups(Relay_log_info *rli) {
   uint recovery_group_cnt = 0;
   bool not_reached_commit = true;
 
+#ifdef WESQL_CLUSTER
+  if (!NO_HOOK(binlog_applier)) {
+    bool exit = false;
+    if (RUN_HOOK(binlog_applier, on_mts_recovery_groups, (rli, exit))) {
+      is_error = true;
+    }
+    if (is_error || exit) return is_error;
+  }
+#endif
+
   // Value-initialization, to avoid compiler warnings on push_back.
   Slave_job_group job_worker = Slave_job_group();
 
@@ -6510,6 +6649,10 @@ bool mta_checkpoint_routine(Relay_log_info *rli, bool force) {
   if (rli->gaq->lwm.group_relay_log_name[0] != 0)
     rli->set_group_relay_log_name(rli->gaq->lwm.group_relay_log_name);
 
+#ifdef WESQL_CLUSTER
+  (void)RUN_HOOK(binlog_applier, on_checkpoint_routine, (rli));
+#endif
+
   /*
      todo: uncomment notifies when UNTIL will be supported
 
@@ -7090,6 +7233,18 @@ extern "C" void *handle_slave_sql(void *arg) {
       goto err;
     }
 
+#ifdef WESQL_CLUSTER
+    if (RUN_HOOK(binlog_applier, before_start,
+                 (rli, rli->opt_replica_parallel_workers))) {
+      mysql_cond_broadcast(&rli->start_cond);
+      mysql_mutex_unlock(&rli->run_lock);
+      rli->report(ERROR_LEVEL, ER_REPLICA_FATAL_ERROR,
+                  ER_THD(thd, ER_REPLICA_FATAL_ERROR),
+                  "Failed to run 'start' hook");
+      goto err;
+    }
+#endif
+
     /* MTS: starting the worker pool */
     if (slave_start_workers(rli, rli->opt_replica_parallel_workers,
                             &mts_inited) != 0) {
@@ -7159,6 +7314,15 @@ extern "C" void *handle_slave_sql(void *arg) {
     rli->trans_retries = 0;  // start from "no error"
     DBUG_PRINT("info", ("rli->trans_retries: %lu", rli->trans_retries));
 
+#ifdef WESQL_CLUSTER
+    if (RUN_HOOK(binlog_applier, reader_before_open, (rli, &applier_reader))) {
+      rli->report(ERROR_LEVEL, ER_REPLICA_FATAL_ERROR,
+                  ER_THD(thd, ER_REPLICA_FATAL_ERROR),
+                  "Failed to run 'open_applier_reader' hook");
+      goto err;
+    }
+#endif
+
     if (applier_reader.open(&errmsg)) {
       rli->report(ERROR_LEVEL, ER_REPLICA_FATAL_ERROR, "%s", errmsg);
       goto err;
@@ -7261,8 +7425,23 @@ extern "C" void *handle_slave_sql(void *arg) {
         saved_skip = 0;
       }
 
+#ifdef WESQL_CLUSTER
+      bool applier_stop = false;
+      (void)RUN_HOOK(binlog_applier, before_read_next_event,
+                     (rli, applier_stop));
+      if (applier_stop) break;
+#endif
+
       // read next event
       mysql_mutex_lock(&rli->data_lock);
+#ifdef WESQL_CLUSTER
+      if (RUN_HOOK(binlog_applier, reader_before_read_event,
+                   (rli, &applier_reader))) {
+        mysql_mutex_unlock(&rli->data_lock);
+        main_loop_error = true;
+        break;
+      }
+#endif
       ev = applier_reader.read_next_event();
       mysql_mutex_unlock(&rli->data_lock);
 
@@ -7346,6 +7525,22 @@ extern "C" void *handle_slave_sql(void *arg) {
     thd->reset_query();
     thd->reset_db(NULL_CSTR);
 
+#ifdef WESQL_CLUSTER
+    if (RUN_HOOK(binlog_applier, reader_before_close, (rli, &applier_reader))) {
+      rli->report(ERROR_LEVEL, ER_REPLICA_FATAL_ERROR,
+                  ER_THD(thd, ER_REPLICA_FATAL_ERROR),
+                  "Failed to run 'before_close_reader' hook");
+    }
+#endif
+
+#ifdef WESQL_CLUSTER
+    if (RUN_HOOK(binlog_applier, after_stop, (rli))) {
+      rli->report(ERROR_LEVEL, ER_REPLICA_FATAL_ERROR,
+                  ER_THD(thd, ER_REPLICA_FATAL_ERROR),
+                  "Failed to run 'after_stop' hook");
+    }
+#endif
+
     /*
       Pause the SQL thread and wait for 'continue_to_stop_sql_thread'
       signal to continue to shutdown the SQL thread.
@@ -8638,6 +8833,14 @@ int flush_relay_logs(Master_info *mi, THD *thd) {
   if (mi) {
     Relay_log_info *rli = mi->rli;
     if (rli->inited) {
+#ifdef WESQL_CLUSTER
+      if (is_consensus_replication_enabled() &&
+          channel_map.is_consensus_replication_channel_name(
+              mi->get_channel())) {
+        return 0;
+      }
+#endif
+
       // Rotate immediately if one is true:
       if ((!is_group_replication_plugin_loaded() ||  // GR is disabled
            !mi->transaction_parser
@@ -9331,6 +9534,16 @@ bool reset_slave_cmd(THD *thd) {
       return true;
     }
 
+#ifdef WESQL_CLUSTER
+    if (mi && is_consensus_replication_enabled() &&
+        channel_map.is_consensus_replication_channel_name(mi->get_channel())) {
+      my_error(ER_REPLICA_CHANNEL_OPERATION_NOT_ALLOWED, MYF(0),
+               "RESET SLAVE [ALL] FOR CHANNEL", mi->get_channel());
+      channel_map.unlock();
+      return true;
+    }
+#endif
+
     if (mi)
       res = reset_slave(thd, mi, thd->lex->reset_slave_info.all);
     else if (strcmp(channel_map.get_default_channel(), lex->mi.channel))
@@ -10997,6 +11210,14 @@ bool change_master_cmd(THD *thd) {
     goto err;
   }
 
+#ifdef WESQL_CLUSTER
+  if (channel_map.is_consensus_replication_channel_name(lex->mi.channel)) {
+    my_error(ER_REPLICA_CHANNEL_NAME_INVALID_OR_TOO_LONG, MYF(0));
+    res = true;
+    goto err;
+  }
+#endif
+
   if (channel_map.is_group_replication_channel_name(lex->mi.channel, true)) {
     /*
       If the chosen name is for group_replication_applier channel we allow the
diff --git a/sql/rpl_rli.cc b/sql/rpl_rli.cc
index 438c58fa82b..ed1e814d81a 100644
--- a/sql/rpl_rli.cc
+++ b/sql/rpl_rli.cc
@@ -77,6 +77,10 @@
 #include "sql_string.h"
 #include "thr_mutex.h"
 
+#ifdef WESQL_CLUSTER
+#include "sql/rpl_handler.h"
+#endif
+
 class Item;
 
 using std::max;
@@ -436,6 +440,10 @@ bool Relay_log_info::mts_finalize_recovery() {
 
   DBUG_TRACE;
 
+#ifdef WESQL_CLUSTER
+  (void)RUN_HOOK(binlog_applier, on_mts_finalize_recovery, (this));
+#endif
+
   for (Slave_worker **it = workers.begin(); !ret && it != workers.end(); ++it) {
     Slave_worker *w = *it;
     ret = w->reset_recovery_info();
@@ -1494,6 +1502,19 @@ err:
   return res;
 }
 
+#ifdef WESQL_CLUSTER
+/* reset previous_gtid_set_of_relaylog through gtid_set */
+int Relay_log_info::reset_previous_gtid_set_of_consensus_log() {
+  if (relay_log.consensus_init_gtid_sets(gtid_set, NULL,
+                                         opt_source_verify_checksum, true)) {
+    LogErr(ERROR_LEVEL, ER_CONSENSUS_LOG_RESET_PREVIOUS_GITD_SET_ERROR);
+    return 1;
+  }
+
+  return 0;
+}
+#endif
+
 int Relay_log_info::rli_init_info(bool skip_received_gtid_set_recovery) {
   int error = 0;
   enum_return_check check_return = ERROR_CHECKING_REPOSITORY;
@@ -1513,6 +1534,15 @@ int Relay_log_info::rli_init_info(bool skip_received_gtid_set_recovery) {
   */
   if (error_on_rli_init_info) goto err;
 
+#ifdef WESQL_CLUSTER
+  if (!NO_HOOK(binlog_applier)) {
+    bool exit_init = false;
+    error = RUN_HOOK(binlog_applier, rli_init_info,
+                     (this, skip_received_gtid_set_recovery, exit_init));
+    if (error || exit_init) return error;
+  }
+#endif
+
   if (inited) {
     return recovery_parallel_workers ? mts_recovery_groups(this) : 0;
   }
@@ -1846,6 +1876,14 @@ void Relay_log_info::end_info() {
   error_on_rli_init_info = false;
   if (!inited) return;
 
+#ifdef WESQL_CLUSTER
+  if (!NO_HOOK(binlog_applier)) {
+    bool exit_end_info = false;
+    (void)RUN_HOOK(binlog_applier, rli_end_info, (this, exit_end_info));
+    if (exit_end_info) return;
+  }
+#endif
+
   handler->end_info();
 
   inited = false;
@@ -2364,6 +2402,7 @@ bool Relay_log_info::write_info(Rpl_info_handler *to) {
           m_assign_gtids_to_anonymous_transactions_info.get_value().c_str())) {
     return true; /* purecov: inspected */
   }
+
   return false;
 }
 
@@ -2655,8 +2694,13 @@ void Relay_log_info::relay_log_number_to_name(uint number,
                                               char name[FN_REFLEN + 1]) {
   char *str = nullptr;
   char relay_bin_channel[FN_REFLEN + 1];
-  const char *relay_log_basename_channel = add_channel_to_relay_log_name(
-      relay_bin_channel, FN_REFLEN + 1, relay_log_basename);
+  const char *relay_log_basename_channel =
+#ifdef WESQL_CLUSTER
+      info_thd->consensus_context.consensus_replication_applier
+          ? log_bin_basename :
+#endif
+          add_channel_to_relay_log_name(relay_bin_channel, FN_REFLEN + 1,
+                                        relay_log_basename);
 
   /* str points to closing null of relay log basename channel */
   str = strmake(name, relay_log_basename_channel, FN_REFLEN + 1);
@@ -2845,6 +2889,10 @@ bool Relay_log_info::commit_positions() {
 
   error = flush_info(RLI_FLUSH_IGNORE_SYNC_OPT);
 
+#ifdef WESQL_CLUSTER
+  (void)RUN_HOOK(binlog_applier, on_commit_positions, (this, nullptr, false));
+#endif
+
   /*
     Restore the saved ones so they remain actual until the replicated
     statement commits.
@@ -3547,3 +3595,223 @@ void Applier_security_context_guard::extract_columns_to_check(
     }
   }
 }
+
+#ifdef WESQL_CLUSTER
+int Relay_log_info::cli_init_info(bool force_retriever_gtid) {
+  int error = 0;
+  enum_return_check check_return = ERROR_CHECKING_REPOSITORY;
+  const char *msg = nullptr;
+  DBUG_TRACE;
+
+  mysql_mutex_assert_owner(&data_lock);
+
+  /*
+    If Relay_log_info is issued again after a failed init_info(), for
+    instance because of missing relay log files, it will generate new
+    files and ignore the previous failure, to avoid that we set
+    error_on_rli_init_info as true.
+    This a consequence of the behaviour change, in the past server was
+    stopped when there were replication initialization errors, now it is
+    not and so init_info() must be aware of previous failures.
+  */
+  if (error_on_rli_init_info) goto err;
+
+  if (inited) {
+    return recovery_parallel_workers ? mts_recovery_groups(this) : 0;
+  }
+
+  slave_skip_counter = 0;
+  abort_pos_wait = 0;
+  log_space_limit = relay_log_space_limit;
+  log_space_total = 0;
+  tables_to_lock = nullptr;
+  tables_to_lock_count = 0;
+
+  char pattern[FN_REFLEN];
+  (void)my_realpath(pattern, replica_load_tmpdir, 0);
+  /*
+   @TODO:
+    In MSR, sometimes slave fail with the following error:
+    Unable to use slave's temporary directory /tmp -
+    Can't create/write to file
+   '/tmp/SQL_LOAD-92d1eee0-9de4-11e3-8874-68730ad50fcb'    (Errcode: 17 - File
+   exists), Error_code: 1
+
+   */
+  if (fn_format(pattern, PREFIX_SQL_LOAD, pattern, "",
+                MY_SAFE_PATH | MY_RETURN_REAL_PATH) == NullS) {
+    LogErr(ERROR_LEVEL, ER_REPLICA_CANT_USE_TEMPDIR, replica_load_tmpdir);
+    return 1;
+  }
+  unpack_filename(slave_patternload_file, pattern);
+  slave_patternload_file_size = strlen(slave_patternload_file);
+
+  /*
+    The relay log will now be opened, as a WRITE_CACHE IO_CACHE.
+    Note that the I/O thread flushes it to disk after writing every
+    event, in flush_info within the master info.
+  */
+  {
+    /* The base name of the relay log file considering multisource rep */
+    const char *ln;
+    /* name of the index file if opt_relaylog_index_name is set*/
+    const char *log_index_name;
+
+    /*  set relay log name as same as binlog name */
+    ln = opt_bin_logname;
+    log_index_name = log_bin_index;
+
+    if (relay_log.open_index_file(log_index_name, ln, true)) {
+      LogErr(ERROR_LEVEL, ER_RPL_OPEN_INDEX_FILE_FAILED);
+      return 1;
+    }
+
+    relay_log.is_relay_log = true;
+    relay_log.is_consensus_write = true;
+    relay_log.is_consensus_log = true;
+
+    if (!gtid_retrieved_initialized || force_retriever_gtid) {
+      /* Store the GTID of a transaction spanned in multiple relay log files */
+      Gtid_monitoring_info *partial_trx = mi->get_gtid_monitoring_info();
+      partial_trx->clear();
+#ifndef NDEBUG
+      get_sid_lock()->wrlock();
+      gtid_set->dbug_print("set of GTIDs in relay log before initialization");
+      get_sid_lock()->unlock();
+#endif
+      /*
+        In the init_gtid_set below we pass the mi->transaction_parser.
+        This will be useful to ensure that we only add a GTID to
+        the Retrieved_Gtid_Set for fully retrieved transactions. Also, it will
+        be useful to ensure the Retrieved_Gtid_Set behavior when auto
+        positioning is disabled (we could have transactions spanning multiple
+        relay log files in this case).
+        We will skip this initialization if relay_log_recovery is set in order
+        to save time, as neither the GTIDs nor the transaction_parser state
+        would be useful when the relay log will be cleaned up later when calling
+        init_recovery.
+      */
+      if (relay_log.consensus_init_gtid_sets(
+              gtid_set, nullptr, opt_source_verify_checksum, true)) {
+        LogErr(ERROR_LEVEL, ER_RPL_CANT_INITIALIZE_GTID_SETS_IN_AM_INIT_INFO);
+        return 1;
+      }
+      gtid_retrieved_initialized = true;
+#ifndef NDEBUG
+      get_sid_lock()->wrlock();
+      gtid_set->dbug_print("set of GTIDs in relay log after initialization");
+      get_sid_lock()->unlock();
+#endif
+    }
+    /*
+      Configures what object is used by the current log to store processed
+      gtid(s). This is necessary in the MYSQL_BIN_LOG::MYSQL_BIN_LOG to
+      correctly compute the set of previous gtids.
+    */
+    relay_log.set_previous_gtid_set_relaylog(gtid_set);
+
+    relay_log.is_relay_log = false;
+
+    /*
+      note, that if open() fails, we'll still have index file open
+      but a destructor will take care of that
+    */
+    mysql_mutex_t *log_lock = relay_log.get_log_lock();
+    mysql_mutex_lock(log_lock);
+
+    // If performed from a consistent snapshot, a new binlog shoule
+    // be created for writing after recovery. because the previous
+    // binlog from the object store cannot be updated.
+    if ((consistent_recovery_consensus_recovery &&
+         relay_log.open_binlog(ln, nullptr, max_binlog_size, true, true, true,
+                               nullptr)) ||
+        (!consistent_recovery_consensus_recovery &&
+         relay_log.open_exist_consensus_binlog(ln, max_binlog_size, true,
+                                               true))) {
+      mysql_mutex_unlock(log_lock);
+      LogErr(ERROR_LEVEL, ER_RPL_CANT_OPEN_LOG_IN_AM_INIT_INFO);
+      return 1;
+    }
+
+    mysql_mutex_unlock(log_lock);
+  }
+
+  /*
+   This checks if the repository was created before and thus there
+   will be values to be read. Please, do not move this call after
+   the handler->init_info().
+ */
+  if ((check_return = check_info()) == ERROR_CHECKING_REPOSITORY) {
+    msg = "Error checking relay log repository";
+    error = 1;
+    goto err;
+  }
+
+  if (handler->init_info()) {
+    msg = "Error reading relay log configuration";
+    error = 1;
+    goto err;
+  }
+
+  check_return = check_if_info_was_cleared(check_return);
+
+  if (check_return & REPOSITORY_EXISTS) {
+    if (read_info(handler)) {
+      msg = "Error reading relay log configuration";
+      error = 1;
+      goto err;
+    }
+  } else if (check_return ==
+                 REPOSITORY_DOES_NOT_EXIST ||  // Hasn't been initialized
+             check_return ==
+                 REPOSITORY_CLEARED  // Was initialized but was RESET
+  ) {
+    group_relay_log_name[0] = 0;
+    group_relay_log_pos = 0;
+    event_relay_log_name[0] = 0;
+    event_relay_log_pos = 0;
+    group_master_log_name[0] = 0;
+    group_master_log_pos = 0;
+  }
+
+  inited = true;
+  error_on_rli_init_info = false;
+
+  if (count_relay_log_space()) {
+    msg = "Error counting relay log space";
+    error = 1;
+    goto err;
+  }
+
+  return error;
+
+err:
+  handler->end_info();
+  inited = false;
+  error_on_rli_init_info = true;
+  if (msg) LogErr(ERROR_LEVEL, ER_RPL_AM_INIT_INFO_MSG, msg);
+  relay_log.close(LOG_CLOSE_INDEX, true /*need_lock_log=true*/,
+                  true /*need_lock_index=true*/);
+  return error;
+}
+
+void Relay_log_info::cli_end_info() {
+  DBUG_TRACE;
+
+  error_on_rli_init_info = false;
+  if (!inited) return;
+
+  handler->end_info();
+
+  inited = false;
+  relay_log.close(LOG_CLOSE_INDEX, true /*need_lock_log=true*/,
+                  true /*need_lock_index=true*/);
+
+  /*
+    Delete the slave's temporary tables from memory.
+    In the future there will be other actions than this, to ensure persistence
+    of slave's temp tables after shutdown.
+  */
+  close_temporary_tables();
+}
+#endif
\ No newline at end of file
diff --git a/sql/rpl_rli.h b/sql/rpl_rli.h
index 100c64b1149..170a346b393 100644
--- a/sql/rpl_rli.h
+++ b/sql/rpl_rli.h
@@ -1533,6 +1533,12 @@ class Relay_log_info : public Rpl_info {
 
   int count_relay_log_space();
 
+#ifdef WESQL_CLUSTER
+  int cli_init_info(bool force_retriever_gtid = false);
+  void cli_end_info();
+  int reset_previous_gtid_set_of_consensus_log();
+#endif
+
   /**
     Initialize the relay log info. This function does a set of operations
     on the rli object like initializing variables, loading information from
diff --git a/sql/rpl_rli_pdb.cc b/sql/rpl_rli_pdb.cc
index a41347ea2e1..4f85fa63748 100644
--- a/sql/rpl_rli_pdb.cc
+++ b/sql/rpl_rli_pdb.cc
@@ -74,6 +74,10 @@
 #include "sql/transaction_info.h"
 #include "thr_mutex.h"
 
+#ifdef WESQL_CLUSTER
+#include "sql/rpl_handler.h"
+#endif
+
 #ifndef NDEBUG
 ulong w_rr = 0;
 uint mta_debug_concurrent_access = 0;
@@ -704,7 +708,14 @@ bool Slave_worker::commit_positions(Log_event *ev, Slave_job_group *ptr_g,
                   { mta_debug_concurrent_access++; };);
 
   m_flag_positions_committed = true;
+
+#ifdef WESQL_CLUSTER
+  bool ret = flush_info(force);
+  (void)RUN_HOOK(binlog_applier, on_commit_positions, (this, ptr_g, false));
+  return ret;
+#else
   return flush_info(force);
+#endif
 }
 
 void Slave_worker::rollback_positions(Slave_job_group *ptr_g) {
diff --git a/sql/rpl_rli_pdb.h b/sql/rpl_rli_pdb.h
index 0129f4fdd4c..6926f11f05b 100644
--- a/sql/rpl_rli_pdb.h
+++ b/sql/rpl_rli_pdb.h
@@ -135,6 +135,9 @@ struct Slave_job_group {
 #endif
         last_committed(other.last_committed),
         sequence_number(other.sequence_number),
+#ifdef WESQL_CLUSTER
+        consensus_index(other.consensus_index),
+#endif
         new_fd_event(other.new_fd_event) {
   }
 
@@ -160,6 +163,9 @@ struct Slave_job_group {
 #endif
     last_committed = other.last_committed;
     sequence_number = other.sequence_number;
+#ifdef WESQL_CLUSTER
+    consensus_index = other.consensus_index;
+#endif
     new_fd_event = other.new_fd_event;
     return *this;
   }
@@ -202,6 +208,9 @@ struct Slave_job_group {
   /* Clock-based scheduler requirement: */
   longlong last_committed;   // commit parent timestamp
   longlong sequence_number;  // transaction's logical timestamp
+#ifdef WESQL_CLUSTER
+  uint64_t consensus_index;  // group's consensus index
+#endif
   /*
     After Coordinator has seen a new FD event, it sets this member to
     point to the new event, once per worker. Coordinator does so
@@ -253,6 +262,11 @@ struct Slave_job_group {
     sequence_number = SEQ_UNINIT;
     new_fd_event = nullptr;
   }
+#ifdef WESQL_CLUSTER
+  void reset_consensus_index(uint64 new_consensus_index) {
+    consensus_index = new_consensus_index;
+  }
+#endif
 };
 
 /**
diff --git a/sql/rpl_source.cc b/sql/rpl_source.cc
index 5b42983ff9f..14a76310dc5 100644
--- a/sql/rpl_source.cc
+++ b/sql/rpl_source.cc
@@ -1215,6 +1215,19 @@ bool reset_master(THD *thd, bool unlock_global_read_lock) {
     goto end;
   }
 
+#ifdef WESQL_CLUSTER
+#ifndef WESQL_TEST
+  /*
+    No RESET MASTER commands are allowed while Consensus Replication is enalbed
+  */
+  if (is_consensus_replication_enabled()) {
+    my_error(ER_CANT_RESET_SOURCE, MYF(0), "Consensus Replication is enabled");
+    ret = true;
+    goto end;
+  }
+#endif
+#endif
+
   if (mysql_bin_log.is_open()) {
     /*
       mysql_bin_log.reset_logs will delete the binary logs *and* clear
diff --git a/sql/sp.cc b/sql/sp.cc
index c00749e163a..e57cab4b9fd 100644
--- a/sql/sp.cc
+++ b/sql/sp.cc
@@ -98,6 +98,9 @@
 #include "sql/transaction_info.h"
 #include "sql_string.h"
 #include "template_utils.h"
+#ifdef WESQL
+#include "sql/package/package_interface.h"
+#endif
 
 class sp_rcontext;
 
@@ -617,7 +620,15 @@ static bool check_routine_already_exists(THD *thd, sp_head *sp,
     // Error is reported by DD API framework.
     return true;
   }
+#ifdef WESQL
+  bool exists = false;
+  if (sp->m_type != enum_sp_type::FUNCTION) {
+    exists = im::exist_native_proc(sp->m_db.str, sp->m_name.str);
+  }
+  if (sr == nullptr && !exists) {
+#else
   if (sr == nullptr) {
+#endif
     // Routine with same name does not exist.
     return false;
   }
diff --git a/sql/sql_class.cc b/sql/sql_class.cc
index c623145df75..459601833c5 100644
--- a/sql/sql_class.cc
+++ b/sql/sql_class.cc
@@ -820,6 +820,10 @@ THD::THD(bool enable_plugins)
   */
   thr_lock_info_init(&lock_info, m_thread_id, &COND_thr_lock);
 
+#ifdef WESQL_CLUSTER
+  init_consensus_context(this);
+#endif
+
   m_internal_handler = nullptr;
   m_binlog_invoker = false;
   memset(&m_invoker_user, 0, sizeof(m_invoker_user));
@@ -2975,7 +2979,10 @@ bool THD::is_current_stmt_binlog_disabled() const {
 }
 
 bool THD::is_current_stmt_binlog_log_replica_updates_disabled() const {
-  return ((!opt_bin_log || (slave_thread && !opt_log_replica_updates)) ||
+  return (!opt_bin_log || (slave_thread && !opt_log_replica_updates) ||
+#ifdef WESQL_CLUSTER
+           (slave_thread && consensus_context.consensus_replication_applier) ||
+#endif
           !mysql_bin_log.is_open());
 }
 
diff --git a/sql/sql_class.h b/sql/sql_class.h
index 2b72c9300b3..294b28d14a7 100644
--- a/sql/sql_class.h
+++ b/sql/sql_class.h
@@ -110,6 +110,11 @@
 #include "template_utils.h"
 #include "thr_lock.h"
 #include "violite.h"
+#ifdef WESQL
+#ifdef WESQL_CLUSTER
+#include "sql/rpl_consensus_replication.h"
+#endif
+#endif
 
 enum enum_check_fields : int;
 enum enum_tx_isolation : int;
@@ -1804,6 +1809,11 @@ class THD : public MDL_context_owner,
   */
   struct THD_timer_info *timer_cache;
 
+#ifdef WESQL_CLUSTER
+public:
+  Consensus_binlog_context_info consensus_context;
+#endif
+
  private:
   /*
     Indicates that the command which is under execution should ignore the
diff --git a/sql/sql_db.cc b/sql/sql_db.cc
index b673264290e..2484b01367b 100644
--- a/sql/sql_db.cc
+++ b/sql/sql_db.cc
@@ -294,13 +294,48 @@ static bool write_db_cmd_to_binlog(THD *thd, const char *db, bool trx_cache) {
 
 static void set_db_default_charset(const THD *thd,
                                    HA_CREATE_INFO *create_info) {
+#ifdef WITH_SMARTENGINE
+  bool is_smartengine = false;
+
+  if (default_storage_engine) {
+    size_t default_engine_len = strlen(default_storage_engine);
+    is_smartengine = (default_engine_len == strlen(SMARTENGINE_NAME)) &&
+      (!strncasecmp(default_storage_engine, SMARTENGINE_NAME, default_engine_len));
+  }
+
+  bool is_system_thd = (thd->is_dd_system_thread() ||
+                        thd->is_initialize_system_thread() ||
+                        thd->is_server_upgrade_thread());
+  /**smartengine support my_charset_utf8mb4_0900_ai_ci incomplete, include index scan.
+  So, smartengine change collation from my_charset_utf8mb4_0900_ai_ci to
+  my_charset_utf8mb4_general_ci, if ddl query has not an explicit collation clause.*/
+#endif
   if (create_info->default_table_charset == nullptr) {
     create_info->default_table_charset = thd->variables.collation_server;
+#ifdef WITH_SMARTENGINE
+    if (!is_system_thd && is_smartengine &&
+        create_info->default_table_charset == &my_charset_utf8mb4_0900_ai_ci) {
+      create_info->default_table_charset = &my_charset_utf8mb4_general_ci;
+    }
+#endif
   } else {
+#ifdef WITH_SMARTENGINE
     if (!(create_info->used_fields & HA_CREATE_USED_DEFAULT_COLLATE) &&
-        create_info->default_table_charset == &my_charset_utf8mb4_0900_ai_ci)
+        create_info->default_table_charset == &my_charset_utf8mb4_0900_ai_ci) {
       create_info->default_table_charset =
           thd->variables.default_collation_for_utf8mb4;
+
+      if (!is_system_thd && is_smartengine &&
+          create_info->default_table_charset == &my_charset_utf8mb4_0900_ai_ci) {
+        create_info->default_table_charset = &my_charset_utf8mb4_general_ci;
+      }
+    }
+#else
+    if (!(create_info->used_fields & HA_CREATE_USED_DEFAULT_COLLATE) &&
+        create_info->default_table_charset == &my_charset_utf8mb4_0900_ai_ci) {
+      create_info->default_table_charset =
+          thd->variables.default_collation_for_utf8mb4;
+#endif
   }
 }
 
diff --git a/sql/sql_lex.h b/sql/sql_lex.h
index d225f25d868..caf8d884ffa 100644
--- a/sql/sql_lex.h
+++ b/sql/sql_lex.h
@@ -2455,6 +2455,12 @@ typedef struct struct_slave_connection {
   void reset();
 } LEX_SLAVE_CONNECTION;
 
+#ifdef WESQL_CLUSTER
+typedef struct struct_consensus_info {
+  uint64 log_index;
+} LEX_CONSENSUS_INFO;
+#endif
+
 struct st_sp_chistics {
   LEX_CSTRING comment;
   enum enum_sp_suid_behaviour suid;
@@ -3869,6 +3875,9 @@ struct LEX : public Query_tables_list {
   KEY_CREATE_INFO key_create_info;
   LEX_MASTER_INFO mi;  // used by CHANGE MASTER
   LEX_SLAVE_CONNECTION slave_connection;
+#ifdef WESQL_CLUSTER
+  LEX_CONSENSUS_INFO consensus;
+#endif
   Server_options server_options;
   USER_RESOURCES mqh;
   LEX_RESET_SLAVE reset_slave_info;
diff --git a/sql/sql_parse.cc b/sql/sql_parse.cc
index 64f26eb21a9..078f5e81f66 100644
--- a/sql/sql_parse.cc
+++ b/sql/sql_parse.cc
@@ -182,6 +182,14 @@
 #ifdef WITH_LOCK_ORDER
 #include "sql/debug_lock_order.h"
 #endif /* WITH_LOCK_ORDER */
+#ifdef WESQL_CLUSTER
+#include "sql/rpl_msr.h"  // channel_map
+#include "plugin/raft_replication/consensus_log_manager.h"
+#endif
+
+#ifdef WITH_SMARTENGINE
+#include "storage/smartengine/core/monitoring/query_perf_context.h"
+#endif
 
 namespace resourcegroups {
 class Resource_group;
@@ -635,8 +643,14 @@ void init_sql_command_flags() {
   sql_command_flags[SQLCOM_SHOW_COLLATIONS] =
       CF_STATUS_COMMAND | CF_HAS_RESULT_SET | CF_REEXECUTION_FRAGILE;
   sql_command_flags[SQLCOM_SHOW_BINLOGS] = CF_STATUS_COMMAND;
+#ifdef WESQL_CLUSTER
+  sql_command_flags[SQLCOM_SHOW_CONSENSUSLOGS] = CF_STATUS_COMMAND;
+#endif
   sql_command_flags[SQLCOM_SHOW_SLAVE_HOSTS] = CF_STATUS_COMMAND;
   sql_command_flags[SQLCOM_SHOW_BINLOG_EVENTS] = CF_STATUS_COMMAND;
+#ifdef WESQL_CLUSTER
+  sql_command_flags[SQLCOM_SHOW_CONSENSUSLOG_EVENTS] = CF_STATUS_COMMAND;
+#endif
   sql_command_flags[SQLCOM_SHOW_STORAGE_ENGINES] = CF_STATUS_COMMAND;
   sql_command_flags[SQLCOM_SHOW_PRIVILEGES] = CF_STATUS_COMMAND;
   sql_command_flags[SQLCOM_SHOW_WARNS] = CF_STATUS_COMMAND | CF_DIAGNOSTIC_STMT;
@@ -971,6 +985,10 @@ void init_sql_command_flags() {
   sql_command_flags[SQLCOM_SLAVE_STOP] |= CF_ALLOW_PROTOCOL_PLUGIN;
   sql_command_flags[SQLCOM_START_GROUP_REPLICATION] |= CF_ALLOW_PROTOCOL_PLUGIN;
   sql_command_flags[SQLCOM_STOP_GROUP_REPLICATION] |= CF_ALLOW_PROTOCOL_PLUGIN;
+#ifdef WESQL_CLUSTER
+  sql_command_flags[SQLCOM_START_RAFT_REPLICATION] |= CF_ALLOW_PROTOCOL_PLUGIN;
+  sql_command_flags[SQLCOM_STOP_RAFT_REPLICATION] |= CF_ALLOW_PROTOCOL_PLUGIN;
+#endif
   sql_command_flags[SQLCOM_BEGIN] |= CF_ALLOW_PROTOCOL_PLUGIN;
   sql_command_flags[SQLCOM_CHANGE_MASTER] |= CF_ALLOW_PROTOCOL_PLUGIN;
   sql_command_flags[SQLCOM_CHANGE_REPLICATION_FILTER] |=
@@ -980,6 +998,9 @@ void init_sql_command_flags() {
   sql_command_flags[SQLCOM_PURGE] |= CF_ALLOW_PROTOCOL_PLUGIN;
   sql_command_flags[SQLCOM_PURGE_BEFORE] |= CF_ALLOW_PROTOCOL_PLUGIN;
   sql_command_flags[SQLCOM_SHOW_BINLOGS] |= CF_ALLOW_PROTOCOL_PLUGIN;
+#ifdef WESQL_CLUSTER
+  sql_command_flags[SQLCOM_SHOW_CONSENSUSLOGS] |= CF_ALLOW_PROTOCOL_PLUGIN;
+#endif
   sql_command_flags[SQLCOM_SHOW_OPEN_TABLES] |= CF_ALLOW_PROTOCOL_PLUGIN;
   sql_command_flags[SQLCOM_HA_OPEN] |= CF_ALLOW_PROTOCOL_PLUGIN;
   sql_command_flags[SQLCOM_HA_CLOSE] |= CF_ALLOW_PROTOCOL_PLUGIN;
@@ -988,6 +1009,9 @@ void init_sql_command_flags() {
   sql_command_flags[SQLCOM_DELETE_MULTI] |= CF_ALLOW_PROTOCOL_PLUGIN;
   sql_command_flags[SQLCOM_UPDATE_MULTI] |= CF_ALLOW_PROTOCOL_PLUGIN;
   sql_command_flags[SQLCOM_SHOW_BINLOG_EVENTS] |= CF_ALLOW_PROTOCOL_PLUGIN;
+#ifdef WESQL_CLUSTER
+  sql_command_flags[SQLCOM_SHOW_CONSENSUSLOG_EVENTS] |= CF_ALLOW_PROTOCOL_PLUGIN;
+#endif
   sql_command_flags[SQLCOM_DO] |= CF_ALLOW_PROTOCOL_PLUGIN;
   sql_command_flags[SQLCOM_SHOW_WARNS] |= CF_ALLOW_PROTOCOL_PLUGIN;
   sql_command_flags[SQLCOM_EMPTY_QUERY] |= CF_ALLOW_PROTOCOL_PLUGIN;
@@ -1158,6 +1182,10 @@ void init_sql_command_flags() {
   sql_command_flags[SQLCOM_RENAME_USER] |= CF_REQUIRE_ACL_CACHE;
   sql_command_flags[SQLCOM_SHOW_GRANTS] |= CF_REQUIRE_ACL_CACHE;
   sql_command_flags[SQLCOM_SET_PASSWORD] |= CF_REQUIRE_ACL_CACHE;
+#ifdef WESQL
+  /* Native package proc flags */
+  sql_command_flags[SQLCOM_ADMIN_PROC] = CF_AUTO_COMMIT_TRANS;
+#endif
 }
 
 bool sqlcom_can_generate_row_events(enum enum_sql_command command) {
@@ -1699,6 +1727,11 @@ bool dispatch_command(THD *thd, const COM_DATA *com_data,
   DBUG_TRACE;
   DBUG_PRINT("info", ("command: %d", command));
 
+#ifdef WITH_SMARTENGINE
+  QUERY_TRACE_RESET();
+  QUERY_TRACE_BEGIN(smartengine::monitor::TracePoint::SERVER_OPERATION);
+#endif
+
   Sql_cmd_clone *clone_cmd = nullptr;
 
   /* SHOW PROFILE instrumentation, begin */
@@ -2088,6 +2121,13 @@ bool dispatch_command(THD *thd, const COM_DATA *com_data,
         size_t length =
             static_cast<size_t>(packet_end - beginning_of_next_stmt);
 
+#ifdef WITH_SMARTENGINE
+        QUERY_TRACE_END(); // end SERVER_OPERATION trace
+        if (thd) {
+          QUERY_TRACE_FINISH(thd->query().str, thd->query().length);
+        }
+#endif
+
         log_slow_statement(thd);
 
         thd->reset_copy_status_var();
@@ -2115,6 +2155,11 @@ bool dispatch_command(THD *thd, const COM_DATA *com_data,
         thd->profiling->set_query_source(beginning_of_next_stmt, length);
 #endif
 
+#ifdef WITH_SMARTENGINE
+        QUERY_TRACE_RESET();
+        QUERY_TRACE_BEGIN(smartengine::monitor::TracePoint::SERVER_OPERATION);
+#endif
+
         mysql_thread_set_secondary_engine(false);
 
         /* PSI begin */
@@ -2268,6 +2313,16 @@ bool dispatch_command(THD *thd, const COM_DATA *com_data,
       break;
     case COM_BINLOG_DUMP_GTID:
       MYSQL_NOTIFY_STATEMENT_QUERY_ATTRIBUTES(thd->m_statement_psi, false);
+#ifdef WESQL_CLUSTER
+      if (is_consensus_replication_enabled() &&
+          is_consensus_replication_log_mode()) {
+        my_message(ER_NOT_SUPPORTED_YET,
+                   "Consensus replication logger do not support "
+                   "COM_BINLOG_DUMP_GTID command",
+                   MYF(0));
+        break;
+      }
+#endif
       // TODO: access of protocol_classic should be removed
       error = com_binlog_dump_gtid(
           thd, (char *)thd->get_protocol_classic()->get_raw_packet(),
@@ -2445,6 +2500,13 @@ bool dispatch_command(THD *thd, const COM_DATA *com_data,
   }
 
 done:
+#ifdef WITH_SMARTENGINE
+  QUERY_TRACE_END(); // end SERVER_OPERATION trace
+  if (thd) {
+    QUERY_TRACE_FINISH(thd->query().str, thd->query().length);
+  }
+#endif
+
   assert(thd->open_tables == nullptr ||
          (thd->locked_tables_mode == LTM_LOCK_TABLES));
 
@@ -3428,6 +3490,18 @@ int mysql_execute_command(THD *thd, bool first_level) {
       res = purge_source_logs_before_date(thd, purge_time);
       break;
     }
+#ifdef WESQL_CLUSTER
+    case SQLCOM_SHOW_CONSENSUSLOG_EVENTS: {
+      if (is_consensus_replication_enabled()) {
+        res = consensus_replication_show_log_events(thd);
+      } else {
+        my_error(ER_NOT_SUPPORTED_YET, MYF(0),
+                 ",please set consensus_enabled=on");
+        goto error;
+      }
+      break;
+    }
+#endif
     case SQLCOM_CHANGE_MASTER: {
       Security_context *sctx = thd->security_context();
       if (!sctx->check_access(SUPER_ACL) &&
@@ -3603,6 +3677,63 @@ int mysql_execute_command(THD *thd, bool first_level) {
       res = start_slave_cmd(thd);
       break;
     }
+#ifdef WESQL_CLUSTER
+    case SQLCOM_START_RAFT_REPLICATION:
+      if (is_consensus_replication_enabled()) {
+        if (lex->slave_connection.password || lex->slave_connection.user) {
+          my_error(ER_GROUP_REPLICATION_USER_MANDATORY_MSG, MYF(0));
+          goto error;
+        }
+
+        thd->lex->mi.for_channel = true;
+        thd->lex->mi.channel =
+            channel_map.get_consensus_replication_applier_channel();
+        thd->lex->slave_thd_opt = SLAVE_SQL;
+        res = start_slave_cmd(thd);
+      } else {
+        my_error(ER_NOT_SUPPORTED_YET, MYF(0),
+                 ",please set consensus_enabled=on");
+        goto error;
+      }
+      break;
+    case SQLCOM_STOP_RAFT_REPLICATION:
+      if (is_consensus_replication_enabled()) {
+        /*
+          If the client thread has locked tables, a deadlock is possible.
+          Assume that
+          - the client thread does LOCK TABLE t READ.
+          - then the master updates t.
+          - then the SQL slave thread wants to update t,
+            so it waits for the client thread because t is locked by it.
+          - then the client thread does SLAVE STOP.
+            SLAVE STOP waits for the SQL slave thread to terminate its
+            update t, which waits for the client thread because t is locked by
+          it. To prevent that, refuse SLAVE STOP if the client thread has locked
+          tables
+        */
+        if (thd->locked_tables_mode ||
+            thd->in_active_multi_stmt_transaction() ||
+            thd->global_read_lock.is_acquired()) {
+          my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));
+          goto error;
+        }
+
+        thd->lex->mi.for_channel = true;
+        thd->lex->mi.channel =
+            channel_map.get_consensus_replication_applier_channel();
+        thd->lex->slave_thd_opt = SLAVE_SQL;
+        res = stop_slave_cmd(thd);
+        LogErr(INFORMATION_LEVEL, ER_CONSENSUS_CMD_LOG,
+               thd->m_main_security_ctx.user().str,
+               thd->m_main_security_ctx.host_or_ip().str, thd->query().str,
+               res);
+      } else {
+        my_error(ER_NOT_SUPPORTED_YET, MYF(0),
+                 ",please set consensus_enabled=on");
+        goto error;
+      }
+      break;
+#endif
     case SQLCOM_SLAVE_STOP: {
       /*
         If the client thread has locked tables, a deadlock is possible.
@@ -3660,6 +3791,18 @@ int mysql_execute_command(THD *thd, bool first_level) {
       if (mysql_rename_tables(thd, first_table)) goto error;
       break;
     }
+#ifdef WESQL_CLUSTER
+    case SQLCOM_SHOW_CONSENSUSLOGS: {
+      if (is_consensus_replication_enabled()) {
+        res = consensus_replication_show_logs(thd);
+      } else {
+        my_error(ER_NOT_SUPPORTED_YET, MYF(0),
+                 ",please set consensus_enabled=on");
+        goto error;
+      }
+      break;
+    }
+#endif
     case SQLCOM_CHECKSUM: {
       assert(first_table == all_tables && first_table != nullptr);
       if (check_table_access(thd, SELECT_ACL, all_tables, false, UINT_MAX,
@@ -4712,6 +4855,10 @@ int mysql_execute_command(THD *thd, bool first_level) {
     case SQLCOM_ALTER_TABLESPACE:
     case SQLCOM_EXPLAIN_OTHER:
     case SQLCOM_RESTART_SERVER:
+#ifdef WESQL
+    case SQLCOM_ADMIN_PROC:
+    case SQLCOM_TRANS_PROC:
+#endif
     case SQLCOM_CREATE_SRS:
     case SQLCOM_DROP_SRS: {
       assert(lex->m_sql_cmd != nullptr);
@@ -5184,6 +5331,10 @@ void THD::reset_for_next_command() {
   thd->binlog_unsafe_warning_flags = 0;
   thd->binlog_need_explicit_defaults_ts = false;
 
+#ifdef WESQL_CLUSTER
+  reset_consensus_context(thd);
+#endif
+
   thd->commit_error = THD::CE_NONE;
   thd->durability_property = HA_REGULAR_DURABILITY;
   thd->set_trans_pos(nullptr, 0);
diff --git a/sql/sql_prepare.cc b/sql/sql_prepare.cc
index d2b6353a038..a3eda99950e 100644
--- a/sql/sql_prepare.cc
+++ b/sql/sql_prepare.cc
@@ -1419,6 +1419,10 @@ bool Prepared_statement::prepare_query(THD *thd) {
     case SQLCOM_SHOW_TRIGGERS:
     case SQLCOM_SHOW_VARIABLES:
     case SQLCOM_SET_RESOURCE_GROUP:
+#ifdef WESQL
+    case SQLCOM_ADMIN_PROC:
+    case SQLCOM_TRANS_PROC:
+#endif
     case SQLCOM_SHOW_WARNS:
       res = m_lex->m_sql_cmd->prepare(thd);
       break;
diff --git a/sql/sql_reload.cc b/sql/sql_reload.cc
index 61828fe0164..0c4a3aaa94e 100644
--- a/sql/sql_reload.cc
+++ b/sql/sql_reload.cc
@@ -56,6 +56,10 @@
 #include "sql/system_variables.h"
 #include "sql/table.h"
 
+#ifdef WESQL_CLUSTER
+#include "sql/rpl_handler.h"
+#endif
+
 /**
   Check the privileges required to execute a FLUSH command
 
@@ -230,6 +234,14 @@ bool handle_reload_request(THD *thd, unsigned long options, Table_ref *tables,
         than it would help them)
        */
       tmp_write_to_binlog = 0;
+
+#ifdef WESQL_CLUSTER
+      if (!NO_HOOK(binlog_manager)) {
+        if (RUN_HOOK(binlog_manager, rotate_and_purge, (thd, true)))
+          *write_to_binlog = -1;
+      } else
+#endif
+
       if (mysql_bin_log.is_open()) {
         if (mysql_bin_log.rotate_and_purge(thd, true)) *write_to_binlog = -1;
       }
diff --git a/sql/sql_show.cc b/sql/sql_show.cc
index 64c61f060db..15a7c98909f 100644
--- a/sql/sql_show.cc
+++ b/sql/sql_show.cc
@@ -72,6 +72,8 @@
 #include "sql/auth/auth_acls.h"  // DB_ACLS
 #include "sql/auth/auth_common.h"
 #include "sql/auth/sql_security_ctx.h"
+#include "sql/binlog_archive.h"
+#include "sql/consistent_archive.h"
 #include "sql/dd/cache/dictionary_client.h"  // dd::cache::Dictionary_client
 #include "sql/dd/dd_schema.h"                // dd::Schema_MDL_locker
 #include "sql/dd/dd_table.h"                 // is_encrypted
@@ -2868,9 +2870,9 @@ class List_process_list : public Do_THD_Impl {
         thd_info->host = host;
       } else
         thd_info->host = m_client_thd->mem_strdup(
-            inspect_sctx_host_or_ip.str[0]
-                ? inspect_sctx_host_or_ip.str
-                : inspect_sctx_host.length ? inspect_sctx_host.str : "");
+            inspect_sctx_host_or_ip.str[0] ? inspect_sctx_host_or_ip.str
+            : inspect_sctx_host.length     ? inspect_sctx_host.str
+                                           : "");
     }  // We've copied the security context, so release the lock.
 
     DBUG_EXECUTE_IF("processlist_acquiring_dump_threads_LOCK_thd_data", {
@@ -4059,11 +4061,10 @@ static int get_schema_tmp_table_columns_record(THD *thd, Table_ref *tables,
 
     // COLUMN_KEY
     pos = pointer_cast<const uchar *>(
-        field->is_flag_set(PRI_KEY_FLAG)
-            ? "PRI"
-            : field->is_flag_set(UNIQUE_KEY_FLAG)
-                  ? "UNI"
-                  : field->is_flag_set(MULTIPLE_KEY_FLAG) ? "MUL" : "");
+        field->is_flag_set(PRI_KEY_FLAG)        ? "PRI"
+        : field->is_flag_set(UNIQUE_KEY_FLAG)   ? "UNI"
+        : field->is_flag_set(MULTIPLE_KEY_FLAG) ? "MUL"
+                                                : "");
     table->field[TMP_TABLE_COLUMNS_COLUMN_KEY]->store(
         (const char *)pos, strlen((const char *)pos), cs);
 
@@ -4957,6 +4958,513 @@ static int hton_fill_schema_table(THD *thd, Table_ref *tables, Item *cond) {
   return 0;
 }
 
+static int fill_binlog_persistent_task_info(THD *thd, Table_ref *tables, Item *) {
+  DBUG_TRACE;
+  TABLE *table = tables->table;
+  CHARSET_INFO *cs = system_charset_info;
+  Binlog_archive *binlog_archive = Binlog_archive::get_instance();
+  mysql_mutex_t *binlog_archive_lock = binlog_archive->get_binlog_archive_lock();
+  
+  mysql_mutex_lock(binlog_archive_lock);
+  if (!binlog_archive->is_thread_running()) {
+    mysql_mutex_unlock(binlog_archive_lock);
+    LogErr(INFORMATION_LEVEL, ER_BINLOG_ARCHIVE_LOG, "binlog archive is not running");
+    return 0;
+  }
+  mysql_mutex_unlock(binlog_archive_lock);
+
+  // New variables for additional information
+  uint64_t persisting_consensus_index;
+  uint64_t consensus_term;
+  std::string persisting_mysql_binlog;
+  my_off_t persisting_mysql_binlog_pos;
+  my_off_t persisting_mysql_binlog_write_pos; 
+  std::string persisting_binlog;
+  my_off_t persisting_binlog_pos;
+  my_off_t persisting_binlog_write_pos;
+  std::string persisted_binlog;
+  my_off_t persisted_binlog_pos;
+  uint64_t persisted_consensus_index;
+  std::string persisted_mysql_binlog;
+  my_off_t persisted_mysql_binlog_pos;
+
+  if (binlog_archive->show_binlog_archive_task_info(
+          persisting_consensus_index, consensus_term,
+          persisting_mysql_binlog, persisting_mysql_binlog_pos,
+          persisting_mysql_binlog_write_pos,
+          persisting_binlog, persisting_binlog_pos,
+          persisting_binlog_write_pos, 
+          persisted_binlog, persisted_binlog_pos,
+          persisted_consensus_index,
+          persisted_mysql_binlog, persisted_mysql_binlog_pos)) {
+    return 1;
+  }
+
+  restore_record(table, s->default_values);
+
+  // Store all values in the table fields
+  table->field[0]->store(consensus_term, true);
+  table->field[1]->store(persisted_consensus_index, true);
+  table->field[2]->store(persisted_binlog.c_str(), persisted_binlog.length(), cs);
+  table->field[3]->store(persisted_binlog_pos, true);
+  table->field[4]->store(persisted_mysql_binlog.c_str(), persisted_mysql_binlog.length(), cs);
+  table->field[5]->store(persisted_mysql_binlog_pos, true);
+  table->field[6]->store(persisting_consensus_index, true);
+  table->field[7]->store(persisting_mysql_binlog.c_str(), persisting_mysql_binlog.length(), cs);
+  table->field[8]->store(persisting_mysql_binlog_pos, true);
+  table->field[9]->store(persisting_mysql_binlog_write_pos, true);
+  table->field[10]->store(persisting_binlog.c_str(), persisting_binlog.length(), cs);
+  table->field[11]->store(persisting_binlog_pos, true);
+  table->field[12]->store(persisting_binlog_write_pos, true);
+
+  if (schema_table_store_record(thd, table)) return 1;
+
+  return 0;
+}
+
+static int fill_binlog_persistent_index_file(THD *thd, Table_ref *tables, Item *) {
+  DBUG_TRACE;
+  IO_CACHE *index_file;
+  TABLE *table = tables->table;
+  CHARSET_INFO *cs = system_charset_info;
+  char log_name_with_path[FN_REFLEN];
+  size_t log_name_len_with_path;
+  Binlog_archive *binlog_archive = Binlog_archive::get_instance();
+  mysql_mutex_t *binlog_archive_lock = binlog_archive->get_binlog_archive_lock();
+  mysql_mutex_lock(binlog_archive_lock);
+  if (!binlog_archive->is_thread_running()) {
+    mysql_mutex_unlock(binlog_archive_lock);
+    LogErr(INFORMATION_LEVEL, ER_BINLOG_ARCHIVE_LOG, "binlog archive is not running");
+    return 0;
+  }
+  mysql_mutex_unlock(binlog_archive_lock);
+  binlog_archive->lock_binlog_index();
+  index_file = binlog_archive->get_index_file();
+  if (!index_file || !my_b_inited(index_file)) {
+    LogErr(INFORMATION_LEVEL, ER_BINLOG_ARCHIVE_LOG, "binlog archive binlog index is not open");
+    binlog_archive->unlock_binlog_index();
+    return 0;
+  }
+
+  if (reinit_io_cache(index_file, READ_CACHE, (my_off_t)0, false, false)) {
+    my_error(ER_IO_ERR_LOG_INDEX_READ, MYF(0));
+    goto err;
+  }
+
+  while ((log_name_len_with_path = my_b_gets(index_file, log_name_with_path,
+                                             sizeof(log_name_with_path))) > 1) {
+    restore_record(table, s->default_values);
+    log_name_with_path[--log_name_len_with_path] = '\0';  // remove the newline
+    std::string in_str;
+    in_str.assign(log_name_with_path);
+    size_t idx = in_str.find("|");
+
+    std::string found_log_slice_name = in_str.substr(0, idx);
+    std::string left_string = in_str.substr(idx + 1);
+    idx = left_string.find("|");
+    std::string found_end_consensus_index = left_string.substr(0, idx);
+    uint64_t slice_end_consensus_index = std::stoull(found_end_consensus_index);
+    std::string found_previous_consensus_index = left_string.substr(idx + 1);
+    uint64_t log_previous_consensus_index = std::stoull(found_previous_consensus_index);
+
+    size_t first_dot = found_log_slice_name.find('.');
+    if (first_dot == std::string::npos) {
+      my_error(ER_IO_ERR_LOG_INDEX_READ, MYF(0));
+      goto err;
+    }
+    size_t second_dot = found_log_slice_name.find('.', first_dot + 1);
+    if (second_dot == std::string::npos) {
+      my_error(ER_IO_ERR_LOG_INDEX_READ, MYF(0));
+      goto err;
+    }
+    std::string log_name = found_log_slice_name.substr(0, second_dot);
+    left_string = found_log_slice_name.substr(second_dot + 1);
+    size_t third_dot = left_string.find('.');
+    if (third_dot == std::string::npos) {
+      my_error(ER_IO_ERR_LOG_INDEX_READ, MYF(0));
+      goto err;
+    }
+    std::string term = left_string.substr(0, third_dot);
+    std::string end_pos = left_string.substr(third_dot + 1);
+    uint64_t slice_consensus_term = std::stoull(term);
+    my_off_t slice_end_pos = std::stoull(end_pos);
+
+    table->field[0]->store(found_log_slice_name.c_str(), found_log_slice_name.length(), cs);
+    table->field[1]->store(log_name.c_str(), log_name.length(), cs);
+    table->field[2]->store(slice_consensus_term, true);
+    table->field[3]->store(slice_end_pos, true);
+    table->field[4]->store(slice_end_consensus_index, true);
+    table->field[5]->store(log_previous_consensus_index, true);
+    if (schema_table_store_record(thd, table)) goto err;
+  }
+  if (index_file->error == -1) {
+    my_error(ER_IO_ERR_LOG_INDEX_READ, MYF(0));
+    goto err;
+  }
+  binlog_archive->unlock_binlog_index();
+  return 0;
+err:
+  binlog_archive->unlock_binlog_index();
+  return 1;
+}
+
+static int fill_binlog_persistent_slices(THD *thd, Table_ref *tables,
+                                           Item *) {
+  DBUG_TRACE;
+  TABLE *table = tables->table;
+  CHARSET_INFO *cs = system_charset_info;
+  std::vector<objstore::ObjectMeta> binlog_objects;
+  Binlog_archive *binlog_archive = Binlog_archive::get_instance();
+  mysql_mutex_t *binlog_archive_lock = binlog_archive->get_binlog_archive_lock();
+
+  mysql_mutex_lock(binlog_archive_lock);
+  if (!binlog_archive->is_thread_running()) {
+    mysql_mutex_unlock(binlog_archive_lock);
+    return 0;
+  }
+  mysql_mutex_unlock(binlog_archive_lock);
+  if (!binlog_archive->show_binlog_persistent_files(binlog_objects)) {
+    for (const auto &object : binlog_objects) {
+      restore_record(table, s->default_values);
+      table->field[0]->store(object.key.c_str(), object.key.size(), cs);
+      MYSQL_TIME timestamp;
+      // timestamp with thread time_zone
+      thd->variables.time_zone->gmt_sec_to_TIME(&timestamp,
+                                                object.last_modified / 1000);
+      table->field[1]->store_time(&timestamp);
+      // Byte
+      table->field[2]->store(object.size, true);
+      if (schema_table_store_record(thd, table)) return 1;
+    }
+  }
+  return 0;
+}
+
+static int fill_mysql_innodb_persistent_index_file(THD *thd, Table_ref *tables,
+                                                   Item *) {
+  DBUG_TRACE;
+  IO_CACHE *index_file = nullptr;
+  TABLE *table = tables->table;
+  CHARSET_INFO *cs = system_charset_info;
+  char file_name[FN_REFLEN];
+  size_t file_name_len;
+  Consistent_archive *consistent_snapshot_archive =
+      Consistent_archive::get_instance();
+  mysql_mutex_t *Consistent_archive_lock =
+      consistent_snapshot_archive->get_consistent_archive_lock();
+
+  mysql_mutex_lock(Consistent_archive_lock);
+  if (!consistent_snapshot_archive->is_thread_running()) {
+    mysql_mutex_unlock(Consistent_archive_lock);
+    return 0;
+  }
+  mysql_mutex_unlock(Consistent_archive_lock);
+
+  consistent_snapshot_archive->lock_mysql_clone_index();
+  index_file = consistent_snapshot_archive->get_mysql_clone_index_file();
+  if (!index_file || !my_b_inited(index_file)) {
+    consistent_snapshot_archive->unlock_mysql_clone_index();
+    return 0;
+  }
+
+  if (reinit_io_cache(index_file, READ_CACHE, (my_off_t)0, false, false)) {
+    my_error(ER_IO_ERR_LOG_INDEX_READ, MYF(0));
+    goto err;
+  }
+
+  while ((file_name_len = my_b_gets(index_file, file_name, sizeof(file_name))) >
+         1) {
+    restore_record(table, s->default_values);
+    file_name[--file_name_len] = '\0';  // remove the newline
+    table->field[0]->store(file_name, strlen(file_name), cs);
+    if (schema_table_store_record(thd, table)) goto err;
+  }
+  if (index_file->error == -1) {
+    my_error(ER_IO_ERR_LOG_INDEX_READ, MYF(0));
+    goto err;
+  }
+  consistent_snapshot_archive->unlock_mysql_clone_index();
+  return 0;
+err:
+  consistent_snapshot_archive->unlock_mysql_clone_index();
+  return 1;
+}
+
+static int fill_mysql_innodb_persistent_files(THD *thd, Table_ref *tables,
+                                           Item *) {
+  DBUG_TRACE;
+  TABLE *table = tables->table;
+  CHARSET_INFO *cs = system_charset_info;
+  std::vector<objstore::ObjectMeta> innodb_objects;
+  Consistent_archive *consistent_snapshot_archive =
+      Consistent_archive::get_instance();
+  mysql_mutex_t *Consistent_archive_lock =
+      consistent_snapshot_archive->get_consistent_archive_lock();
+
+  mysql_mutex_lock(Consistent_archive_lock);
+  if (!consistent_snapshot_archive->is_thread_running()) {
+    mysql_mutex_unlock(Consistent_archive_lock);
+    return 0;
+  }
+  mysql_mutex_unlock(Consistent_archive_lock); 
+  if (!consistent_snapshot_archive->show_innodb_persistent_files(innodb_objects)) {
+    for (const auto &object : innodb_objects) {
+      restore_record(table, s->default_values);
+      table->field[0]->store(object.key.c_str(), object.key.size(), cs);
+      MYSQL_TIME timestamp;
+      // timestamp with thread time_zone
+      thd->variables.time_zone->gmt_sec_to_TIME(&timestamp,
+                                                object.last_modified / 1000);
+      table->field[1]->store_time(&timestamp);
+      // Byte
+      table->field[2]->store(object.size, true);
+      if (schema_table_store_record(thd, table)) return 1;
+    }
+  }
+  return 0;
+}
+
+static int fill_se_backup_persistent_index_file(THD *thd, Table_ref *tables,
+                                           Item *) {
+  DBUG_TRACE;
+  IO_CACHE *index_file = nullptr;
+  TABLE *table = tables->table;
+  CHARSET_INFO *cs = system_charset_info;
+  char file_name[FN_REFLEN];
+  size_t file_name_len;
+  Consistent_archive *consistent_snapshot_archive =
+      Consistent_archive::get_instance();
+  mysql_mutex_t *Consistent_archive_lock =
+      consistent_snapshot_archive->get_consistent_archive_lock();
+
+  mysql_mutex_lock(Consistent_archive_lock);
+  if (!consistent_snapshot_archive->is_thread_running()) {
+    mysql_mutex_unlock(Consistent_archive_lock);
+    return 0;
+  }
+  mysql_mutex_unlock(Consistent_archive_lock);
+
+  consistent_snapshot_archive->lock_se_backup_index();
+  index_file = consistent_snapshot_archive->get_se_backup_index_file();
+  if (!index_file || !my_b_inited(index_file)) {
+    consistent_snapshot_archive->unlock_se_backup_index();
+    return 0;
+  }
+
+  if (reinit_io_cache(index_file, READ_CACHE, (my_off_t)0, false, false)) {
+    my_error(ER_IO_ERR_LOG_INDEX_READ, MYF(0));
+    goto err;
+  }
+
+  while ((file_name_len = my_b_gets(index_file, file_name, sizeof(file_name))) >
+         1) {
+    restore_record(table, s->default_values);
+    file_name[--file_name_len] = '\0';  // remove the newline
+    table->field[0]->store(file_name, strlen(file_name), cs);
+    if (schema_table_store_record(thd, table)) goto err;
+  }
+  if (index_file->error == -1) {
+    my_error(ER_IO_ERR_LOG_INDEX_READ, MYF(0));
+    goto err;
+  }
+  consistent_snapshot_archive->unlock_se_backup_index();
+  return 0;
+err:
+  consistent_snapshot_archive->unlock_se_backup_index();
+  return 1;
+}
+
+static int fill_se_backup_persistent_files(THD *thd, Table_ref *tables,
+                                           Item *) {
+  DBUG_TRACE;
+  TABLE *table = tables->table;
+  CHARSET_INFO *cs = system_charset_info;
+  std::vector<objstore::ObjectMeta> se_objects;
+  Consistent_archive *consistent_snapshot_archive =
+      Consistent_archive::get_instance();
+  mysql_mutex_t *Consistent_archive_lock =
+      consistent_snapshot_archive->get_consistent_archive_lock();
+
+  mysql_mutex_lock(Consistent_archive_lock);
+  if (!consistent_snapshot_archive->is_thread_running()) {
+    mysql_mutex_unlock(Consistent_archive_lock);
+    return 0;
+  }
+  mysql_mutex_unlock(Consistent_archive_lock);
+  if (!consistent_snapshot_archive->show_se_persistent_files(se_objects)) {
+    for (const auto &object : se_objects) {
+      restore_record(table, s->default_values);
+      table->field[0]->store(object.key.c_str(), object.key.size(), cs);
+      MYSQL_TIME timestamp;
+      // timestamp with thread time_zone
+      thd->variables.time_zone->gmt_sec_to_TIME(&timestamp,
+                                                object.last_modified / 1000);
+      table->field[1]->store_time(&timestamp);
+      // Byte
+      table->field[2]->store(object.size, true);
+      if (schema_table_store_record(thd, table)) return 1;
+    }
+  }
+  return 0;
+}
+
+static int fill_se_extent_snapshot(THD *thd, Table_ref *tables,
+                                           Item *) {
+  DBUG_TRACE;
+  TABLE *table = tables->table;
+  std::vector<uint64_t> se_snapshot;
+  Consistent_archive *consistent_snapshot_archive =
+      Consistent_archive::get_instance();
+  mysql_mutex_t *Consistent_archive_lock =
+      consistent_snapshot_archive->get_consistent_archive_lock();
+
+  mysql_mutex_lock(Consistent_archive_lock);
+  if (!consistent_snapshot_archive->is_thread_running()) {
+    mysql_mutex_unlock(Consistent_archive_lock);
+    return 0;
+  }
+  mysql_mutex_unlock(Consistent_archive_lock);
+  if (!consistent_snapshot_archive->show_se_backup_snapshot(thd, se_snapshot)) {
+    for (const auto &snapshot_id : se_snapshot) {
+      restore_record(table, s->default_values);
+      table->field[0]->store(snapshot_id, true);
+      if (schema_table_store_record(thd, table)) return 1;
+    }
+  }
+  return 0;
+}
+
+static int fill_consistent_snapshot_persistent_index_file(THD *thd, Table_ref *tables,
+                                           Item *) {
+  DBUG_TRACE;
+  IO_CACHE *index_file = nullptr;
+  TABLE *table = tables->table;
+  CHARSET_INFO *cs = system_charset_info;
+  char snapshot_info[4 * FN_REFLEN];
+  size_t snapshot_info_len;
+  Consistent_archive *consistent_snapshot_archive =
+      Consistent_archive::get_instance();
+  mysql_mutex_t *Consistent_archive_lock =
+      consistent_snapshot_archive->get_consistent_archive_lock();
+
+  mysql_mutex_lock(Consistent_archive_lock);
+  if (!consistent_snapshot_archive->is_thread_running()) {
+    mysql_mutex_unlock(Consistent_archive_lock);
+    return 0;
+  }
+  mysql_mutex_unlock(Consistent_archive_lock);
+  consistent_snapshot_archive->lock_consistent_snapshot_index();
+  index_file = consistent_snapshot_archive->get_consistent_snapshot_index_file();
+  if (!index_file || !my_b_inited(index_file)) {
+    consistent_snapshot_archive->unlock_consistent_snapshot_index();
+    return 0;
+  }
+
+  if (reinit_io_cache(index_file, READ_CACHE, (my_off_t)0, false, false)) {
+    my_error(ER_IO_ERR_LOG_INDEX_READ, MYF(0));
+    goto err;
+  }
+
+  while ((snapshot_info_len = my_b_gets(index_file, snapshot_info, sizeof(snapshot_info))) >
+         1) {
+    snapshot_info[--snapshot_info_len] = '\0';  // remove the newline
+    std::string in_str;
+    in_str.assign(snapshot_info);
+    size_t idx = in_str.find("|");
+    std::string ts = in_str.substr(0, idx);
+    std::string left_string = in_str.substr(idx+1);
+
+    idx = left_string.find("|");
+    std::string innodb_name = left_string.substr(0, idx);
+    left_string = left_string.substr(idx+1);
+
+    idx = left_string.find("|");
+    std::string se_name = left_string.substr(0, idx);
+    left_string = left_string.substr(idx+1);
+
+    idx = left_string.find("|");
+    std::string binlog_name = left_string.substr(0, idx);
+    left_string = left_string.substr(idx+1);
+
+    idx = left_string.find("|");
+    std::string binlog_pos = left_string.substr(0, idx);
+    left_string = left_string.substr(idx+1);
+
+    idx = left_string.find("|");
+    std::string consensus_index = left_string.substr(0, idx);
+    std::string se_snapshot = left_string.substr(idx+1);
+
+    restore_record(table, s->default_values);
+    table->field[0]->store(ts.c_str(), ts.length(), cs);
+    table->field[1]->store(innodb_name.c_str(), innodb_name.length(), cs);
+    table->field[2]->store(se_name.c_str(), se_name.length(), cs);
+    table->field[3]->store(binlog_name.c_str(), binlog_name.length(), cs);
+    table->field[4]->store((longlong)std::stoll(binlog_pos), true);
+    table->field[5]->store((longlong)std::stoll(consensus_index), true);
+    table->field[6]->store((longlong)std::stoll(se_snapshot), true);
+    if (schema_table_store_record(thd, table)) goto err;
+  }
+  if (index_file->error == -1) {
+    my_error(ER_IO_ERR_LOG_INDEX_READ, MYF(0));
+    goto err;
+  }
+  consistent_snapshot_archive->unlock_consistent_snapshot_index();
+  return 0;
+err:
+  consistent_snapshot_archive->unlock_consistent_snapshot_index();
+  return 1;
+}
+
+static int fill_consistent_snapshot_persistent_task_info(THD *thd,
+                                                         Table_ref *tables,
+                                                         Item *) {
+  DBUG_TRACE;
+  TABLE *table = tables->table;
+  CHARSET_INFO *cs = system_charset_info;
+  Consistent_archive *consistent_snapshot_archive =
+      Consistent_archive::get_instance();
+  mysql_mutex_t *Consistent_archive_lock =
+      consistent_snapshot_archive->get_consistent_archive_lock();
+
+  mysql_mutex_lock(Consistent_archive_lock);
+  if (!consistent_snapshot_archive->is_thread_running()) {
+    mysql_mutex_unlock(Consistent_archive_lock);
+    return 0;
+  }
+  mysql_mutex_unlock(Consistent_archive_lock);
+  Consistent_snapshot_task_info task_info{};
+  consistent_snapshot_archive->show_consistent_snapshot_task_info(task_info);
+  restore_record(table, s->default_values);
+  table->field[0]->store(task_info.archive_progress,
+                         strlen(task_info.archive_progress), cs);
+  table->field[1]->store(task_info.consensus_term, true);
+  table->field[2]->store(task_info.consistent_snapshot_archive_start_ts,
+                         strlen(task_info.consistent_snapshot_archive_start_ts),
+                         cs);
+  table->field[3]->store(task_info.consistent_snapshot_archive_end_ts,
+                         strlen(task_info.consistent_snapshot_archive_end_ts),
+                         cs);
+  table->field[4]->store(task_info.mysql_clone_name,
+                         strlen(task_info.mysql_clone_name), cs);
+  table->field[5]->store(task_info.innodb_clone_duration, true);
+  table->field[6]->store(task_info.innodb_archive_duration, true);
+  table->field[7]->store(task_info.se_backup_name,
+                         strlen(task_info.se_backup_name), cs);
+  table->field[8]->store(task_info.se_snapshot_id, true);
+  table->field[9]->store(task_info.se_backup_duration, true);
+  table->field[10]->store(task_info.se_archive_duration, true);
+  table->field[11]->store(task_info.mysql_binlog_file,
+                          strlen(task_info.mysql_binlog_file), cs);
+  table->field[12]->store(task_info.mysql_binlog_pos, true);
+  table->field[13]->store(task_info.binlog_file, strlen(task_info.binlog_file),
+                          cs);
+  table->field[14]->store(task_info.consensus_index, true);
+  table->field[15]->store(task_info.wait_binlog_archive_duration, true);
+  if (schema_table_store_record(thd, table)) return 1;
+
+  return 0;
+}
+
 ST_FIELD_INFO engines_fields_info[] = {
     {"ENGINE", 64, MYSQL_TYPE_STRING, 0, 0, "Engine", 0},
     {"SUPPORT", 8, MYSQL_TYPE_STRING, 0, 0, "Support", 0},
@@ -5097,6 +5605,90 @@ ST_FIELD_INFO tmp_table_columns_fields_info[] = {
      MYSQL_TYPE_STRING, 0, 0, "Generation expression", 0},
     {nullptr, 0, MYSQL_TYPE_STRING, 0, 0, nullptr, 0}};
 
+ST_FIELD_INFO binlog_persistent_task_info_fields_info[] = {
+    {"LAST_RAFT_TERM", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {"LAST_PERSISTED_RAFT_INDEX", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {"LAST_PERSISTED_BINLOG", FN_REFLEN, MYSQL_TYPE_STRING, 0, 0, "Null", 0},
+    {"LAST_PERSISTED_BINLOG_POS", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {"LAST_PERSISTED_MYSQL_BINLOG", FN_REFLEN, MYSQL_TYPE_STRING, 0, 0, "Null", 0},
+    {"LAST_PERSISTED_MYSQL_BINLOG_POS", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {"LAST_PERSISTING_RAFT_INDEX", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {"LAST_PERSISTING_MYSQL_BINLOG", FN_REFLEN, MYSQL_TYPE_STRING, 0, 0, "Null", 0},
+    {"LAST_PERSISTING_MYSQL_BINLOG_PERSISTENT_POS", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {"LAST_PERSISTING_MYSQL_BINLOG_READ_POS", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {"LAST_PERSISTING_BINLOG", FN_REFLEN, MYSQL_TYPE_STRING, 0, 0, "Null", 0},
+    {"LAST_PERSISTING_BINLOG_POS", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {"LAST_PERSISTING_BINLOG_WRITE_POS", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {nullptr, 0, MYSQL_TYPE_STRING, 0, 0, nullptr, 0}};
+
+ST_FIELD_INFO binlog_persistent_index_slice_fields_info[] = {
+    {"LOG_SLICE_NAME", FN_REFLEN, MYSQL_TYPE_STRING, 0, 0, "Null", 0},
+    {"LOG_NAME", FN_REFLEN, MYSQL_TYPE_STRING, 0, 0, "Null", 0},
+    {"RAFT_TERM", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {"SLICE_END_POS", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {"SLICE_END_RAFT_INDEX", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {"LOG_PREVIOUS_RAFT_INDEX", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {nullptr, 0, MYSQL_TYPE_STRING, 0, 0, nullptr, 0}};
+
+ST_FIELD_INFO binlog_persistent_slice_fields_info[] = {
+    {"LOG_SLICE_KEY", FN_REFLEN, MYSQL_TYPE_STRING, 0, 0, "Null", 0},
+    {"LAST_MODIFIED", FN_REFLEN, MYSQL_TYPE_TIMESTAMP, 0, 0, "Null", 0},
+    {"SIZE", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {nullptr, 0, MYSQL_TYPE_STRING, 0, 0, nullptr, 0}};
+
+ST_FIELD_INFO innodb_persistent_snapshot_index_fields_info[] = {
+    {"INNODB_SNAPSHOT_NAME", FN_REFLEN, MYSQL_TYPE_STRING, 0, 0, "Null", 0},
+    {nullptr, 0, MYSQL_TYPE_STRING, 0, 0, nullptr, 0}};
+
+ST_FIELD_INFO innodb_persistent_snapshot_fields_info[] = {
+    {"INNODB_SNAPSHOT_KEY", FN_REFLEN, MYSQL_TYPE_STRING, 0, 0, "Null", 0},
+    {"LAST_MODIFIED", FN_REFLEN, MYSQL_TYPE_TIMESTAMP, 0, 0, "Null", 0},
+    {"SIZE", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {nullptr, 0, MYSQL_TYPE_STRING, 0, 0, nullptr, 0}};
+
+ST_FIELD_INFO se_persistent_snapshot_index_fields_info[] = {
+    {"SMARTENGINE_SNAPSHOT_NAME", FN_REFLEN, MYSQL_TYPE_STRING, 0, 0, "Null", 0},
+    {nullptr, 0, MYSQL_TYPE_STRING, 0, 0, nullptr, 0}};
+
+ST_FIELD_INFO se_persistent_snapshot_fields_info[] = {
+    {"SMARTENGINE_SNAPSHOT_KEY", FN_REFLEN, MYSQL_TYPE_STRING, 0, 0, "Null", 0},
+    {"LAST_MODIFIED", FN_REFLEN, MYSQL_TYPE_TIMESTAMP, 0, 0, "Null", 0},
+    {"SIZE", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {nullptr, 0, MYSQL_TYPE_STRING, 0, 0, nullptr, 0}};
+
+ST_FIELD_INFO consisent_persistent_snapshot_index_fields_info[] = {
+    {"CREATED_TS", FN_REFLEN, MYSQL_TYPE_STRING, 0, 0, "Null", 0},
+    {"MYSQL_INNODB_SNAPSHOT_NAME", FN_REFLEN, MYSQL_TYPE_STRING, 0, 0, "Null", 0},
+    {"SMARTENGINE_SNAPSHOT_NAME", FN_REFLEN, MYSQL_TYPE_STRING, 0, 0, "Null", 0},
+    {"BINLOG_NAME", FN_REFLEN, MYSQL_TYPE_STRING, 0, 0, "Null", 0},
+    {"BINLOG_POS", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {"RAFT_INDEX", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {"SMARTENGINE_SNAPSHOT", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {nullptr, 0, MYSQL_TYPE_STRING, 0, 0, nullptr, 0}};
+
+ST_FIELD_INFO consisent_persistent_snapshot_task_info[] = {
+    {"PERSISTENT_PROGRESS", FN_REFLEN, MYSQL_TYPE_STRING, 0, 0, "Null", 0},
+    {"RAFT_TERM", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {"START_TIMESTAMP", FN_REFLEN, MYSQL_TYPE_STRING, 0, 0, "Null", 0},
+    {"END_TIMESTAMP", FN_REFLEN, MYSQL_TYPE_STRING, 0, 0, "Null", 0},
+    {"INNODB_SNAPSHOT_NAME", FN_REFLEN, MYSQL_TYPE_STRING, 0, 0, "Null", 0},
+    {"INNODB_SNAPSHOT_DURATION", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {"INNODB_SNAPSHOT_PERSISTENT_DURATION", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {"SMARTENGINE_SNAPSHOT_NAME", FN_REFLEN, MYSQL_TYPE_STRING, 0, 0, "Null", 0},
+    {"SMARTENGINE_SNAPSHOT_ID", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {"SMARTENGINE_SNAPSHOT_DURATION", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {"SMARTENGINE_SNAPSHOT_PERSISTENT_DURATION", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {"MYSQL_BINLOG_FILE", FN_REFLEN, MYSQL_TYPE_STRING, 0, 0, "Null", 0},
+    {"MYSQL_BINLOG_OFFSET", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {"PERSISTENT_BINLOG_FILE", FN_REFLEN, MYSQL_TYPE_STRING, 0, 0, "Null", 0},
+    {"RAFT_INDEX", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {"WAIT_BINLOG_PERSISTENT_DURATION", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {nullptr, 0, MYSQL_TYPE_STRING, 0, 0, nullptr, 0}};
+
+ST_FIELD_INFO se_extent_snapshot_fields_info[] = {
+    {"SMARTENGINE_SNAPSHOT", 21, MYSQL_TYPE_LONGLONG, 0, 0, "Null", 0},
+    {nullptr, 0, MYSQL_TYPE_STRING, 0, 0, nullptr, 0}};
+
 /** For creating fields of information_schema.OPTIMIZER_TRACE */
 extern ST_FIELD_INFO optimizer_trace_info[];
 
@@ -5135,6 +5727,29 @@ ST_SCHEMA_TABLE schema_tables[] = {
      make_tmp_table_columns_format, get_schema_tmp_table_columns_record, true},
     {"TMP_TABLE_KEYS", tmp_table_keys_fields_info, show_temporary_tables,
      make_old_format, get_schema_tmp_table_keys_record, true},
+    {"BINLOG_PERSISTENT_TASK_INFO", binlog_persistent_task_info_fields_info,
+     fill_binlog_persistent_task_info, nullptr, nullptr, false},
+    {"BINLOG_PERSISTENT_SLICE_INDEX", binlog_persistent_index_slice_fields_info,
+     fill_binlog_persistent_index_file, nullptr, nullptr, false},
+    {"BINLOG_PERSISTENT_SLICES", binlog_persistent_slice_fields_info,
+     fill_binlog_persistent_slices, nullptr, nullptr, false},
+    {"SNAPSHOT_INNODB_PERSISTENT_SNAPSHOT_INDEX", innodb_persistent_snapshot_index_fields_info,
+     fill_mysql_innodb_persistent_index_file, nullptr, nullptr, false},
+    {"SNAPSHOT_INNODB_PERSISTENT_SNAPSHOTS", innodb_persistent_snapshot_fields_info,
+     fill_mysql_innodb_persistent_files, nullptr, nullptr, false},
+    {"SNAPSHOT_SMARTENGINE_PERSISTENT_SNAPSHOT_INDEX", se_persistent_snapshot_index_fields_info,
+     fill_se_backup_persistent_index_file, nullptr, nullptr, false},
+    {"SNAPSHOT_SMARTENGINE_PERSISTENT_SNAPSHOTS", se_persistent_snapshot_fields_info,
+     fill_se_backup_persistent_files, nullptr, nullptr, false},
+    {"SNAPSHOT_PERSISTENT_SNAPSHOT_INDEX",
+     consisent_persistent_snapshot_index_fields_info,
+     fill_consistent_snapshot_persistent_index_file, nullptr, nullptr, false},
+    {"SNAPSHOT_PERSISTENT_TASK_INFO",
+     consisent_persistent_snapshot_task_info,
+     fill_consistent_snapshot_persistent_task_info, nullptr, nullptr, false},
+    {"SNAPSHOT_SMARTENGINE_EXTENT_SNAPSHOTS",
+     se_extent_snapshot_fields_info,
+     fill_se_extent_snapshot, nullptr, nullptr, false},
     {nullptr, nullptr, nullptr, nullptr, nullptr, false}};
 
 int initialize_schema_table(st_plugin_int *plugin) {
diff --git a/sql/sql_table.cc b/sql/sql_table.cc
index 1244c4873c1..f7377e6e4c3 100644
--- a/sql/sql_table.cc
+++ b/sql/sql_table.cc
@@ -8402,6 +8402,9 @@ bool validate_comment_length(THD *thd, const char *comment_str,
 
 static bool set_table_default_charset(THD *thd, HA_CREATE_INFO *create_info,
                                       const dd::Schema &schema) {
+#ifdef WITH_SMARTENGINE
+  bool is_smartengine = (create_info->db_type->db_type == DB_TYPE_SMARTENGINE);
+#endif
   /*
     If the table character set was not given explicitly,
     let's fetch the database default character set and
@@ -8410,6 +8413,12 @@ static bool set_table_default_charset(THD *thd, HA_CREATE_INFO *create_info,
   if (create_info->default_table_charset == nullptr) {
     if (get_default_db_collation(schema, &create_info->default_table_charset))
       return true;
+#ifdef WITH_SMARTENGINE
+    /** for smartengine, if collation is 0900_ai_ci, we replace it by general_ci */
+    if (is_smartengine && create_info->default_table_charset == &my_charset_utf8mb4_0900_ai_ci) {
+      create_info->default_table_charset = &my_charset_utf8mb4_general_ci;
+    }
+#endif
   } else {
     assert((create_info->used_fields & HA_CREATE_USED_CHARSET) == 0 ||
            (create_info->used_fields & HA_CREATE_USED_DEFAULT_CHARSET) ||
@@ -8420,6 +8429,11 @@ static bool set_table_default_charset(THD *thd, HA_CREATE_INFO *create_info,
         create_info->default_table_charset == &my_charset_utf8mb4_0900_ai_ci) {
       create_info->default_table_charset =
           thd->variables.default_collation_for_utf8mb4;
+#ifdef WITH_SMARTENGINE
+      if (is_smartengine) {
+        create_info->default_table_charset = &my_charset_utf8mb4_general_ci;
+      } 
+#endif
 
       // ALTER TABLE ... CONVERT TO CHARACTER SET ...
       if (create_info->used_fields & HA_CREATE_USED_CHARSET) {
@@ -8428,8 +8442,17 @@ static bool set_table_default_charset(THD *thd, HA_CREATE_INFO *create_info,
     }
   }
 
+#ifdef WITH_SMARTENGINE
+  if (create_info->default_table_charset == nullptr) {
+    create_info->default_table_charset = thd->collation();
+    if (is_smartengine && create_info->default_table_charset == &my_charset_utf8mb4_0900_ai_ci) {
+      create_info->default_table_charset = &my_charset_utf8mb4_general_ci;
+    }
+  }
+#else
   if (create_info->default_table_charset == nullptr)
     create_info->default_table_charset = thd->collation();
+#endif
 
   return false;
 }
diff --git a/sql/sql_yacc.yy b/sql/sql_yacc.yy
index 6c3dd85db23..8c43a67cd52 100644
--- a/sql/sql_yacc.yy
+++ b/sql/sql_yacc.yy
@@ -168,6 +168,9 @@ Note: YYTHD is passed as an argument to yyparse(), and subsequently to yylex().
 #include "sql_string.h"
 #include "thr_lock.h"
 #include "violite.h"
+#ifdef WESQL
+#include "sql/package/package_interface.h"  // find_native_proc_and_evoke
+#endif
 
 /* this is to get the bison compilation windows warnings out */
 #ifdef _MSC_VER
@@ -1419,6 +1422,11 @@ void warn_on_deprecated_user_defined_collation(
 %left KEYWORD_USED_AS_KEYWORD
 
 
+/* Tolens for consensus replication */
+%token<lexer.keyword> CONSENSUS_SYM 1220
+%token<lexer.keyword> CONSENSUSLOG_SYM 1221
+%token<lexer.keyword> RAFT_REPLICATION 1222
+
 /*
   Resolve column attribute ambiguity -- force precedence of "UNIQUE KEY" against
   simple "UNIQUE" and "KEY" attributes:
@@ -2377,6 +2385,7 @@ simple_statement:
         | flush                         { $$= nullptr; }
         | get_diagnostics               { $$= nullptr; }
         | group_replication             { $$= nullptr; }
+        | raft_replication              { $$= nullptr; }
         | grant                         { $$= nullptr; }
         | handler_stmt
         | help                          { $$= nullptr; }
@@ -3980,7 +3989,14 @@ sp_suid:
 call_stmt:
           CALL_SYM sp_name opt_paren_expr_list
           {
+#ifdef WESQL
+            if (($$ = im::find_native_proc_and_evoke(YYTHD, $2, $3))) {
+            } else {
+              $$ = NEW_PTN PT_call($2, $3);
+            }
+#else
             $$= NEW_PTN PT_call($2, $3);
+#endif
           }
         ;
 
@@ -9275,6 +9291,37 @@ replica:
       | REPLICA_SYM
       ;
 
+raft_replication:
+                 START_SYM RAFT_REPLICATION
+                 {
+#ifdef WESQL_CLUSTER
+                   LEX *lex=Lex;
+                   lex->sql_command = SQLCOM_START_RAFT_REPLICATION;
+                   lex->type= 0;
+                   lex->slave_thd_opt= 0;
+                   lex->mi.channel= "";
+                   lex->mi.for_channel= false;
+                   lex->slave_connection.reset();
+#else
+                   MYSQL_YYABORT;
+#endif
+                 }
+               | STOP_SYM RAFT_REPLICATION
+                 {
+#ifdef WESQL_CLUSTER
+                   LEX *lex=Lex;
+                   lex->sql_command = SQLCOM_STOP_RAFT_REPLICATION;
+                   lex->type= 0;
+                   lex->slave_thd_opt= 0;
+                   lex->mi.channel= "";
+                   lex->mi.for_channel= false;
+                   lex->slave_connection.reset();
+#else
+                   MYSQL_YYABORT;
+#endif
+                 }
+               ;
+
 stop_replica_stmt:
           STOP_SYM replica opt_replica_thread_option_list opt_channel
           {
@@ -13658,6 +13705,14 @@ show_binary_logs_stmt:
           {
             $$ = NEW_PTN PT_show_binlogs(@$);
           }
+        | SHOW CONSENSUS_SYM LOGS_SYM
+          {
+#ifdef WESQL_CLUSTER
+            Lex->sql_command = SQLCOM_SHOW_CONSENSUSLOGS;
+#else
+            MYSQL_YYABORT;
+#endif
+          }
         ;
 
 show_replicas_stmt:
@@ -13679,6 +13734,17 @@ show_binlog_events_stmt:
           {
             $$ = NEW_PTN PT_show_binlog_events(@$, $4, $6);
           }
+        | SHOW CONSENSUSLOG_SYM EVENTS_SYM consensus_log_index_from opt_limit_clause
+          {
+#ifdef WESQL_CLUSTER
+            LEX *lex= Lex;
+            lex->sql_command= SQLCOM_SHOW_CONSENSUSLOG_EVENTS;
+            if ($5 != NULL)
+              CONTEXTUALIZE($5);
+#else
+            MYSQL_YYABORT;
+#endif
+          }
         ;
 
 show_relaylog_events_stmt:
@@ -13968,6 +14034,21 @@ binlog_from:
         | FROM ulonglong_num { Lex->mi.pos = $2; }
         ;
 
+consensus_log_index_from:
+          %empty
+          {
+#ifdef WESQL_CLUSTER
+            Lex->consensus.log_index = 0;
+#endif
+          }
+        | FROM INDEX_SYM ulonglong_num
+          {
+#ifdef WESQL_CLUSTER
+            Lex->consensus.log_index = $3;
+#endif
+          }
+        ;
+
 opt_wild_or_where:
           %empty                        { $$ = {}; }
         | LIKE TEXT_STRING_literal      { $$ = { $2, {} }; }
@@ -15375,6 +15456,7 @@ ident_keywords_unambiguous:
         | GET_SOURCE_PUBLIC_KEY_SYM
         | GRANTS
         | GROUP_REPLICATION
+        | RAFT_REPLICATION
         | GTID_ONLY_SYM
         | HASH_SYM
         | HISTOGRAM_SYM
diff --git a/sql/sys_vars.cc b/sql/sys_vars.cc
index b16cb1830e4..fbfb0faf93d 100644
--- a/sql/sys_vars.cc
+++ b/sql/sys_vars.cc
@@ -93,11 +93,13 @@
 #include "sql/auth/auth_acls.h"
 #include "sql/auth/auth_common.h"  // validate_user_plugins
 #include "sql/binlog.h"            // mysql_bin_log
+#include "sql/binlog_archive.h"    // Binlog_archive
 #include "sql/changestreams/apply/replication_thread_status.h"
 #include "sql/clone_handler.h"
 #include "sql/conn_handler/connection_handler_impl.h"  // Per_thread_connection_handler
 #include "sql/conn_handler/connection_handler_manager.h"  // Connection_handler_manager
 #include "sql/conn_handler/socket_connection.h"  // MY_BIND_ALL_ADDRESSES
+#include "sql/consistent_archive.h" // Consistent_archive
 #include "sql/derror.h"                          // read_texts
 #include "sql/discrete_interval.h"
 #include "sql/events.h"          // Events
@@ -152,6 +154,10 @@
 #include "storage/perfschema/terminology_use_previous.h"
 #endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */
 
+#ifdef WITH_SMARTENGINE
+#include "storage/smartengine/util/se_logger.h"
+#endif
+
 static constexpr const unsigned long DEFAULT_ERROR_COUNT{1024};
 static constexpr const unsigned long DEFAULT_SORT_MEMORY{256UL * 1024UL};
 static constexpr const unsigned HOST_CACHE_SIZE{128};
@@ -2784,6 +2790,9 @@ static Sys_var_ulong Sys_log_throttle_queries_not_using_indexes(
     ON_UPDATE(update_log_throttle_queries_not_using_indexes));
 
 static bool update_log_error_verbosity(sys_var *, THD *, enum_var_type) {
+#ifdef WITH_SMARTENGINE
+  mysql_set_se_info_log_level(log_error_verbosity);
+#endif
   return (log_builtins_filter_update_verbosity(log_error_verbosity) < 0);
 }
 
@@ -2952,6 +2961,19 @@ static bool fix_max_binlog_size(sys_var *, THD *, enum_var_type) {
     }
     channel_map.unlock();
   }
+
+#ifdef WESQL_CLUSTER
+  if (is_consensus_replication_enabled()) {
+    channel_map.wrlock();
+    for (mi_map::iterator it = channel_map.begin(CONSENSUS_REPLICATION_CHANNEL);
+         it != channel_map.end(CONSENSUS_REPLICATION_CHANNEL); it++) {
+      Master_info *mi = it->second;
+      if (mi != nullptr) mi->rli->relay_log.set_max_size(max_binlog_size);
+    }
+    channel_map.unlock();
+  }
+#endif
+
   return false;
 }
 static Sys_var_ulong Sys_max_binlog_size(
@@ -4176,6 +4198,22 @@ static bool check_slave_stopped(sys_var *self, THD *thd, set_var *var) {
       mysql_mutex_unlock(&mi->rli->run_lock);
     }
   }
+
+#ifdef WESQL_CLUSTER
+  if (is_consensus_replication_enabled()) {
+    for (mi_map::iterator it = channel_map.begin(CONSENSUS_REPLICATION_CHANNEL);
+         it != channel_map.end(CONSENSUS_REPLICATION_CHANNEL); it++) {
+      mi = it->second;
+      mysql_mutex_lock(&mi->rli->run_lock);
+      if (mi->rli->slave_running) {
+        my_error(ER_REPLICA_SQL_THREAD_MUST_STOP, MYF(0));
+        result = true;
+      }
+      mysql_mutex_unlock(&mi->rli->run_lock);
+    }
+  }
+#endif
+
   channel_map.unlock();
   return result;
 }
@@ -7532,6 +7570,14 @@ static Sys_var_charptr Sys_protocol_compression_algorithms(
     DEFAULT(const_cast<char *>(PROTOCOL_COMPRESSION_DEFAULT_VALUE)),
     NO_MUTEX_GUARD, NOT_IN_BINLOG,
     ON_CHECK(check_set_protocol_compression_algorithms), ON_UPDATE(nullptr));
+#ifdef WESQL
+static char *wesql_version_ptr = NULL;
+
+static Sys_var_charptr Sys_wesql_version(
+    "wesql_version", "Version of the WeSQL",
+    READ_ONLY GLOBAL_VAR(wesql_version_ptr), NO_CMD_LINE, IN_SYSTEM_CHARSET,
+    DEFAULT(WESQL_VERSION));
+#endif
 
 static bool check_set_require_row_format(sys_var *, THD *thd, set_var *var) {
   /*
@@ -7718,3 +7764,296 @@ static Sys_var_enum Sys_explain_format(
     SESSION_VAR(explain_format), CMD_LINE(OPT_ARG), explain_format_names,
     DEFAULT(static_cast<ulong>(Explain_format_type::TRADITIONAL)),
     NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(nullptr));
+
+static Sys_var_bool Sys_binlog_archive(
+    "binlog_archive", "Indicate if binlog archive enable.",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_binlog_archive), CMD_LINE(OPT_ARG),
+    DEFAULT(true));
+
+static Sys_var_charptr Sys_binlog_archive_dir(
+    "binlog_archive_dir",
+    "The location path for binlog archive",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_binlog_archive_dir),
+    CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT(nullptr));
+
+static Sys_var_bool Sys_binlog_archive_using_consensus_index(
+    "binlog_archive_using_consensus_index",
+    "Indicates whether to use the consensus index as the starting position"
+    " for resuming archive.",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_binlog_archive_using_consensus_index),
+    CMD_LINE(OPT_ARG), DEFAULT(true));
+
+static Sys_var_bool Sys_binlog_archive_expire_auto_purge(
+    "binlog_archive_expire_auto_purge",
+    "Controls whether the server shall automatically purge persistent binary "
+    "log files or not. If this variable is set to FALSE then the server will "
+    "not purge persistent binary log files automatically.",
+    GLOBAL_VAR(opt_binlog_archive_expire_auto_purge), CMD_LINE(OPT_ARG),
+    DEFAULT(true));
+
+static Sys_var_ulong Sys_binlog_archive_expire_seconds(
+    "binlog_archive_expire_seconds",
+    "If non-zero, persistent binlog will be purged after "
+    "binlog_archive_expire_seconds"
+    " seconds. If zero, all binlog will be retained.",
+    GLOBAL_VAR(opt_binlog_archive_expire_seconds), CMD_LINE(REQUIRED_ARG),
+    VALID_RANGE(0, 0xFFFFFFFF), DEFAULT(2592000), BLOCK_SIZE(1));
+
+static Sys_var_ulong Sys_binlog_archive_slice_max_size(
+    "binlog_archive_slice_max_size",
+    "Binary log events will be persistent archived automatically "
+    "when the size exceeds this value.",
+    GLOBAL_VAR(opt_binlog_archive_slice_max_size), CMD_LINE(REQUIRED_ARG),
+    VALID_RANGE(IO_SIZE, 1024 * 1024L * 1024L), DEFAULT(4 * 1024L * 1024L),
+    BLOCK_SIZE(IO_SIZE));
+
+static Sys_var_ulong Sys_binlog_archive_period(
+    "binlog_archive_period",
+    "binlog persist to object store at the given period milliseconds",
+    GLOBAL_VAR(opt_binlog_archive_period), CMD_LINE(REQUIRED_ARG),
+    VALID_RANGE(10, ULONG_MAX), DEFAULT(1000), BLOCK_SIZE(1));
+
+static Sys_var_ulong Sys_binlog_archive_parallel_workers(
+    "binlog_archive_parallel_workers",
+    "Number of worker threads for uploading binlog slice to "
+    "object store in parallel",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_binlog_archive_parallel_workers),
+    CMD_LINE(REQUIRED_ARG), VALID_RANGE(1, MTS_MAX_WORKERS), DEFAULT(4),
+    BLOCK_SIZE(1));
+
+static Sys_var_bool Sys_snapshot_archive(
+    "snapshot_archive",
+    "Indicate if snapshot archive enable.",
+    NON_PERSIST GLOBAL_VAR(opt_consistent_snapshot_archive),
+    CMD_LINE(OPT_ARG), DEFAULT(true));
+
+static Sys_var_charptr Sys_snapshot_archive_dir(
+    "snapshot_archive_dir",
+    "The location path for snapshot archive",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_consistent_snapshot_archive_dir),
+    CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT(nullptr));
+
+static Sys_var_bool Sys_snapshot_archive_on_objectstore(
+    "snapshot_archive_on_objectstore",
+    "Use object store to persist snapshot.",
+    READ_ONLY NON_PERSIST
+        GLOBAL_VAR(opt_consistent_snapshot_persistent_on_objstore),
+    CMD_LINE(OPT_ARG), DEFAULT(true));
+
+static Sys_var_ulong Sys_snapshot_archive_period(
+    "snapshot_archive_period",
+    "A snapshot is created to archive at the given period",
+    GLOBAL_VAR(opt_consistent_snapshot_archive_period), CMD_LINE(REQUIRED_ARG),
+    VALID_RANGE(2, LONG_TIMEOUT), DEFAULT(300), BLOCK_SIZE(1));
+
+static Sys_var_bool Sys_snapshot_archive_expire_auto_purge(
+    "snapshot_archive_expire_auto_purge",
+    "Controls whether the server shall automatically purge snapshot "
+    "or not. If this variable is set to FALSE then the server will "
+    "not purge persistent snapshot automatically.",
+    GLOBAL_VAR(opt_consistent_snapshot_expire_auto_purge), CMD_LINE(OPT_ARG),
+    DEFAULT(true));
+
+static Sys_var_ulong Sys_snapshot_archive_expire_seconds(
+    "snapshot_archive_expire_seconds",
+    "If non-zero, snapshot will be purged after "
+    "snapshot_archive_expire_seconds"
+    " seconds. If zero, only the latest snapshot will be retained.",
+    GLOBAL_VAR(opt_consistent_snapshot_expire_seconds), CMD_LINE(REQUIRED_ARG),
+    VALID_RANGE(0, 0xFFFFFFFF), DEFAULT(0), BLOCK_SIZE(1));
+
+static const char *consistent_snapshot_tar_names[] = {"OFF", "TAR",
+                                                  "TAR_AND_COMPRESS", NullS};
+static Sys_var_enum Sys_snapshot_archive_innodb_tar_mode(
+    "snapshot_archive_innodb_tar_mode",
+    "Indicates if innodb clone data of snapshots is in tar or "
+    "compressed mode.",
+    GLOBAL_VAR(opt_consistent_snapshot_innodb_tar_mode), CMD_LINE(REQUIRED_ARG),
+    consistent_snapshot_tar_names, DEFAULT(CONSISTENT_SNAPSHOT_NO_TAR));
+
+static Sys_var_enum Sys_snapshot_archive_smartengine_tar_mode(
+    "snapshot_archive_smartengine_tar_mode",
+    "Indicates if smartengine backup data of snapshots is in tar or "
+    "compressed mode.",
+    GLOBAL_VAR(opt_consistent_snapshot_se_tar_mode), CMD_LINE(OPT_ARG),
+    consistent_snapshot_tar_names, DEFAULT(CONSISTENT_SNAPSHOT_NO_TAR));
+
+static Sys_var_bool Sys_snapshot_archive_smartengine_backup_checkpoint(
+    "snapshot_archive_smartengine_backup_checkpoint",
+    "Indicate if to do a checkpoint before executing a "
+    "smartengine backup.",
+    GLOBAL_VAR(opt_consistent_snapshot_smartengine_backup_checkpoint),
+    CMD_LINE(OPT_ARG), DEFAULT(false));
+
+static Sys_var_bool Sys_recovery_snapshot_from_objstore(
+    "recovery_snapshot_from_objectstore",
+    "Recovery binlog and snapshot from object store.",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_recovery_from_objstore),
+    CMD_LINE(OPT_ARG), DEFAULT(true));
+
+static Sys_var_charptr Sys_recovery_snapshot_tmpdir(
+    "recovery_snapshot_tmpdir",
+    "The location temp path for snapshot recovery from object store.",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_recovery_consistent_snapshot_tmpdir),
+    CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT("recovery_tmp"));
+
+static Sys_var_bool Sys_recovery_snapshot_only(
+    "recovery_snapshot_only",
+    "Indicate whether to recover only snapshot without binlog archive recovery.",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_recovery_consistent_snapshot_only),
+    CMD_LINE(OPT_ARG), DEFAULT(false));
+
+static Sys_var_charptr Sys_recovery_snapshot_timestamp(
+    "recovery_snapshot_timestamp",
+    "Snapshot timestamp from object store used as the source of "
+    "recovery during instance.",
+    READ_ONLY NON_PERSIST
+        GLOBAL_VAR(opt_recovery_consistent_snapshot_timestamp),
+    CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT(nullptr));
+
+static Sys_var_bool Sys_initialize_from_objstore(
+    "initialize_from_objectstore",
+    "Initialzie instance using binlog and snapshot from object "
+    "store.",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_initialize_from_objstore),
+    CMD_LINE(OPT_ARG), DEFAULT(false));
+
+static Sys_var_charptr Sys_initialize_objstore_provider(
+    "initialize_objectstore_provider",
+    "The provider of object store as the source of data during instance."
+    "If initialize_from_objectstore is true, it must not be "
+    "empty.",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_initialize_objstore_provider),
+    CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT("local"));
+
+static Sys_var_charptr Sys_initialize_objstore_region(
+    "initialize_objectstore_region",
+    "The region of object store as the source of data during instance "
+    "initialization."
+    "If initialize_from_objectstore is true, it must not be "
+    "empty.",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_initialize_objstore_region),
+    CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT(".local_objectstore_region_1"));
+
+static Sys_var_charptr Sys_initialize_objstore_endpoint(
+    "initialize_objectstore_endpoint",
+    "The endpoint of object store as the source of data during instance "
+    "initialization. "
+    "If initialize_from_objectstore is true, user can specify the endpoint of "
+    "object store. "
+    "Ususally it's need to provide on non-AWS environment.",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_initialize_objstore_endpoint),
+    CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT(nullptr));
+
+static Sys_var_bool Sys_initialize_objstore_use_https(
+    "initialize_objectstore_use_https",
+    "If initialize_from_objectstore is true, whether using https to connect to "
+    "objstore or not "
+    "as the source of data during instance initialization",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_initialize_objstore_use_https),
+    CMD_LINE(OPT_ARG), DEFAULT(false));
+
+static Sys_var_charptr Sys_initialize_objstore_bucket(
+    "initialize_objectstore_bucket",
+    "The object store bucket to store record as the source of data during "
+    "instance initialization. If initialize_from_objectstore is true, it must "
+    "not be empty.",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_initialize_objstore_bucket),
+    CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT("objectstore_bucket_1"));
+
+static Sys_var_charptr Sys_initialize_repo_objstore_id(
+    "initialize_repo_objectstore_id",
+    "The repo identifier for data directory of source cluster in object store. "
+    "If initialize_from_objectstore is true, it must not be empty.",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_initialize_repo_objstore_id),
+    CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT("wesql_serverless_repo"));
+
+static Sys_var_charptr Sys_initialize_branch_objstore_id(
+    "initialize_branch_objectstore_id",
+    "The branch identifier for data directory of source cluster in object store.",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_initialize_branch_objstore_id),
+    CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT("main"));
+
+static Sys_var_bool Sys_initialize_smartengine_objectstore_data(
+    "initialize_smartengine_objectstore_data",
+    "If initialize_from_objectstore is true, whether initialize smartengine "
+    "object store data from source cluster object store.",
+    READ_ONLY NON_PERSIST
+        GLOBAL_VAR(opt_initialize_smartengine_objectstore_data),
+    CMD_LINE(OPT_ARG), DEFAULT(false));
+
+static Sys_var_bool Sys_enable_serverless(
+    "serverless", "Enable the serverless",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_serverless),
+    CMD_LINE(OPT_ARG), DEFAULT(true));
+
+static Sys_var_bool Sys_table_on_objstore(
+    "table_on_objectstore", "Use object store to store data in SmartEngine",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_table_on_objstore), CMD_LINE(OPT_ARG),
+    DEFAULT(true));
+
+static Sys_var_charptr Sys_objstore_provider(
+    "objectstore_provider",
+    "The provider of object store. "
+    "If serverless is enabled, objectstore_provider must not be empty.",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_objstore_provider), CMD_LINE(REQUIRED_ARG),
+    IN_FS_CHARSET, DEFAULT("local"));
+
+static Sys_var_charptr Sys_objstore_region(
+    "objectstore_region",
+    "The region of object store. "
+    "If serverless is enabled, objectstore_region must not be empty.",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_objstore_region),
+    CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET,
+    DEFAULT(".local_objectstore_region"));
+
+static Sys_var_charptr Sys_objstore_endpoint(
+    "objectstore_endpoint",
+    "The endpoint of object store. "
+    "If need, user can specify the endpoint of object store. "
+    "Ususally it's need to provide on non-AWS environment.",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_objstore_endpoint), CMD_LINE(REQUIRED_ARG),
+    IN_FS_CHARSET, DEFAULT(nullptr));
+
+static Sys_var_bool Sys_objstore_use_https(
+    "objectstore_use_https",
+    "Whether using https to connect to object store or not.",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_objstore_use_https), CMD_LINE(OPT_ARG),
+    DEFAULT(false));
+
+static Sys_var_charptr Sys_objstore_bucket(
+    "objectstore_bucket",
+    "The object store bucket to store record. "
+    "If serverless is enabled, objectstore_bucket must not be empty.",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_objstore_bucket), CMD_LINE(REQUIRED_ARG),
+    IN_FS_CHARSET, DEFAULT("objectstore_bucket"));
+
+static Sys_var_charptr Sys_objstore_mtr_test_bucket_dir(
+    "objectstore_mtr_test_bucket_dir",
+    "The object store bucket sub dir to store record. for mtr test only",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_objstore_mtr_test_bucket_dir),
+    CMD_LINE(OPT_ARG), IN_FS_CHARSET, DEFAULT(""));
+
+static Sys_var_charptr Sys_repo_objstore_id(
+    "repo_objectstore_id",
+    "The repository identifier for cluster data directory in object store. To "
+    "ensure data consistency by accessing the object using the key with the "
+    "prefix that includes this id. If serverless is enabled, it must not be "
+    "empty.",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_repo_objstore_id),
+    CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT("wesql_serverless_repo"));
+
+static Sys_var_charptr Sys_cluster_branch_objstore_id(
+    "branch_objectstore_id",
+    "The branch identifier for cluster data directory in object store. To "
+    "ensure data consistency by accessing the object using the key with the "
+    "prefix that includes this id.",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_branch_objstore_id),
+    CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT("main"));
+
+static Sys_var_charptr Sys_server_id_on_objstore(
+    "server_id_on_objectstore",
+    "The identifier for the meta directory of the current server on object "
+    "store.",
+    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_server_id_on_objstore),
+    CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT(""));
diff --git a/sql/sys_vars.h b/sql/sys_vars.h
index bacd2bef4ae..88961665298 100644
--- a/sql/sys_vars.h
+++ b/sql/sys_vars.h
@@ -1750,9 +1750,26 @@ class Sys_var_plugin : public sys_var {
     plugin_ref plugin;
 
     // special code for storage engines (e.g. to handle historical aliases)
-    if (plugin_type == MYSQL_STORAGE_ENGINE_PLUGIN)
+    if (plugin_type == MYSQL_STORAGE_ENGINE_PLUGIN) {
+#ifdef WITH_SMARTENGINE
+      // In serverless mode, it's not allowed to set default_storage_engine to
+      // other storage engine except smartengine.First, check if the variable
+      // being set is 'default_storage_engine', then verify that the value being
+      // set is not 'smartengine'.
+      if (!opt_initialize && opt_serverless &&
+          (strlen("default_storage_engine") == name.length &&
+           0 == strncasecmp(name.str, "default_storage_engine", name.length))) {
+        if ((strlen(SMARTENGINE_NAME) != pname_cstr.length) ||
+            (0 != strncasecmp(SMARTENGINE_NAME, pname_cstr.str, pname_cstr.length))) {
+          pname_cstr.str = SMARTENGINE_NAME;
+          pname_cstr.length = strlen(SMARTENGINE_NAME);
+          push_warning_printf(thd, Sql_condition::SL_WARNING, ER_FORCE_STORAGE_ENGINE_TO_SMARTENGINE,
+                              "Force change default storage engine from %s to smartengine in serveless mode", res->lex_cstring().str);
+        }
+      }
+#endif // WITH_SMARTENGINE
       plugin = ha_resolve_by_name(thd, &pname_cstr, false);
-    else {
+    } else {
       plugin = my_plugin_lock_by_name(thd, pname_cstr, plugin_type);
     }
 
diff --git a/sql/table.cc b/sql/table.cc
index 42537776946..4e5a4102520 100644
--- a/sql/table.cc
+++ b/sql/table.cc
@@ -151,6 +151,14 @@ LEX_CSTRING MI_INFO_NAME = {STRING_WITH_LEN("slave_master_info")};
 /* WORKER_INFO name */
 LEX_CSTRING WORKER_INFO_NAME = {STRING_WITH_LEN("slave_worker_info")};
 
+#ifdef WESQL_CLUSTER
+/* CONSENSUS name */
+LEX_CSTRING CONSENSUS_INFO_NAME = { STRING_WITH_LEN("consensus_info") };
+LEX_CSTRING CONSENSUS_APLLIER_INFO_NAME = { STRING_WITH_LEN("consensus_applier_info") };
+LEX_CSTRING CONSENSUS_APLLIER_WORKER_NAME = {
+    STRING_WITH_LEN("consensus_applier_worker")};
+#endif
+
 /* GTID_EXECUTED name */
 LEX_CSTRING GTID_EXECUTED_NAME = {STRING_WITH_LEN("gtid_executed")};
 
diff --git a/sql/table.h b/sql/table.h
index 8465765eabb..9a1fcb95269 100644
--- a/sql/table.h
+++ b/sql/table.h
@@ -4235,6 +4235,11 @@ static const uint MYSQL_TABLESPACE_DD_ID = 1;
 extern LEX_CSTRING RLI_INFO_NAME;
 extern LEX_CSTRING MI_INFO_NAME;
 extern LEX_CSTRING WORKER_INFO_NAME;
+#ifdef WESQL_CLUSTER
+extern LEX_CSTRING CONSENSUS_INFO_NAME;
+extern LEX_CSTRING CONSENSUS_APLLIER_INFO_NAME;
+extern LEX_CSTRING CONSENSUS_APLLIER_WORKER_NAME;
+#endif
 
 inline bool is_infoschema_db(const char *name, size_t len) {
   return (
diff --git a/sql/transaction.cc b/sql/transaction.cc
index 001a761b312..6abe997ae7b 100644
--- a/sql/transaction.cc
+++ b/sql/transaction.cc
@@ -463,6 +463,7 @@ bool trans_rollback_implicit(THD *thd) {
       ~(SERVER_STATUS_IN_TRANS | SERVER_STATUS_IN_TRANS_READONLY);
   DBUG_PRINT("info", ("clearing SERVER_STATUS_IN_TRANS"));
   res = ha_rollback_trans(thd, true);
+
   thd->variables.option_bits &= ~OPTION_BEGIN;
   thd->get_transaction()->reset_unsafe_rollback_flags(Transaction_ctx::SESSION);
 
diff --git a/sql/transaction_info.h b/sql/transaction_info.h
index 468cbc22ae1..6ba93df99f2 100644
--- a/sql/transaction_info.h
+++ b/sql/transaction_info.h
@@ -415,8 +415,21 @@ class Ha_trx_info {
     m_flags = (int)TRX_READ_ONLY; /* Assume read-only at start. */
 
     if (trans->m_ha_list != this) {
+#ifdef WESQL_CLUSTER
+      if (trans->m_ha_list != nullptr && m_add_tail) {
+        /* Add to the tail of the list */
+        auto end = trans->m_ha_list;
+        while (end->m_next != nullptr) end = end->m_next;
+        end->m_next = this;
+        m_next = nullptr;
+      } else {
+        m_next = trans->m_ha_list;
+        trans->m_ha_list = this;
+      }
+#else
       m_next = trans->m_ha_list;
       trans->m_ha_list = this;
+#endif
     }
 
     return;
@@ -431,6 +444,9 @@ class Ha_trx_info {
     m_next = nullptr;
     m_ht = nullptr;
     m_flags = 0;
+#ifdef WESQL_CLUSTER
+    m_add_tail = false;
+#endif
     return;
   }
 
@@ -471,6 +487,10 @@ class Ha_trx_info {
     return m_ht;
   }
 
+#ifdef WESQL_CLUSTER
+  void set_add_tail(bool add_tail) { m_add_tail = add_tail; }
+#endif
+
  private:
   enum { TRX_READ_ONLY = 0, TRX_READ_WRITE = 1 };
   /**
@@ -491,6 +511,10 @@ class Ha_trx_info {
     May assume a combination of enum values above.
   */
   uchar m_flags;
+
+#ifdef WESQL_CLUSTER
+  bool m_add_tail;
+#endif
 };
 
 /**
diff --git a/sql/udf_service_impl.cc b/sql/udf_service_impl.cc
index cba183935a0..253c445065b 100644
--- a/sql/udf_service_impl.cc
+++ b/sql/udf_service_impl.cc
@@ -29,6 +29,9 @@
 #include "sql/sql_class.h"
 #include "sql/udf_service_impl.h"
 
+#include "sql/binlog_archive_command.h"
+#include "sql/consistent_snapshot_force_command.h"
+#include "sql/consistent_snapshot_purge_command.h"
 #include "sql/rpl_async_conn_failover_add_managed_udf.h"
 #include "sql/rpl_async_conn_failover_add_source_udf.h"
 #include "sql/rpl_async_conn_failover_delete_managed_udf.h"
@@ -126,6 +129,9 @@ void Udf_load_service::register_udf() {
   add<Rpl_async_conn_failover_add_managed>();
   add<Rpl_async_conn_failover_delete_managed>();
   add<Rpl_async_conn_failover_reset>();
+  add<Binlog_archive_command>();
+  add<Consistent_archive_force_command>();
+  add<Consistent_archive_purge_command>();
 }
 
 void Udf_load_service::unregister_udf() {
diff --git a/sql/xa/recovery.cc b/sql/xa/recovery.cc
index 274e1d612f4..8856b4572cd 100644
--- a/sql/xa/recovery.cc
+++ b/sql/xa/recovery.cc
@@ -96,6 +96,22 @@ void recover_one_internal_trx(xarecover_st const &info, handlerton &ht,
 void recover_one_external_trx(xarecover_st const &info, handlerton &ht,
                               XA_recover_txn const &xa_trx,
                               ::recovery_statistics &stats);
+#ifdef WESQL_CLUSTER
+/**
+  Processes an coordinated transaction against the transaction
+  coordinator internal state.
+
+  @param info TC internal state w.r.t to transaction state
+  @param ht The plugin interface for the storage engine to recover the
+            transaction for
+  @param xa_trx The information about the transaction to be recovered
+  @param stats Repository of statistical information about transaction
+               recovery success and failures
+ */
+void inverse_recover_one_trx(xarecover_st const &info, handlerton &ht,
+                             XA_recover_txn const &xa_trx,
+                             ::recovery_statistics &stats);
+#endif
 /**
   Changes the given stats object by adding 1 to the given counter `counter`
   in the tuple `state`.
@@ -237,6 +253,44 @@ bool xa::recovery::recover_one_ht(THD *, plugin_ref plugin, void *arg) {
   return false;
 }
 
+#ifdef WESQL_CLUSTER
+bool xa::recovery::inverse_recover_one_ht(THD *, plugin_ref plugin, void *arg) {
+  handlerton *ht = plugin_data<handlerton *>(plugin);
+  xarecover_st *info = static_cast<struct xarecover_st *>(arg);
+  int got;
+
+  if (ht->state == SHOW_OPTION_YES && ht->recover) {
+    ::recovery_statistics external_stats{{0, 0, 0}, {0, 0, 0}};
+    ::recovery_statistics internal_stats{{0, 0, 0}, {0, 0, 0}};
+    while (
+        (got = ht->recover(
+             ht, info->list, info->len,
+             Recovered_xa_transactions::instance().get_allocated_memroot())) >
+        0) {
+      assert(got <= info->len);
+      LogErr(INFORMATION_LEVEL, ER_XA_RECOVER_FOUND_TRX_IN_SE, got,
+             ha_resolve_storage_engine_name(ht));
+
+      for (int i = 0; i < got; ++i) {
+        auto &xa_trx = info->list[i];
+        my_xid xid = xa_trx.id.get_my_xid();
+        ::inverse_recover_one_trx(*info, *ht, xa_trx,
+                                  !xid ? external_stats : internal_stats);
+      }
+      if (got < info->len) break;
+    }
+    bool has_failures =
+        ::has_failures(internal_stats) || ::has_failures(external_stats);
+    LogErr(has_failures ? ERROR_LEVEL : INFORMATION_LEVEL,
+           ER_BINLOG_CRASH_RECOVERY_ENGINE_RESULTS,
+           ha_resolve_storage_engine_name(ht),
+           ::print_stats(internal_stats, external_stats).data());
+    DBUG_EXECUTE_IF("xa_recovery_error_reporting", return has_failures;);
+  }
+  return false;
+}
+#endif
+
 namespace {
 void recover_one_internal_trx(xarecover_st const &info, handlerton &ht,
                               XA_recover_txn const &xa_trx, my_xid xid,
@@ -350,6 +404,85 @@ void recover_one_external_trx(xarecover_st const &info, handlerton &ht,
   }
 }
 
+#ifdef WESQL_CLUSTER
+void inverse_recover_one_trx(xarecover_st const &info, handlerton &ht,
+                             XA_recover_txn const &xa_trx,
+                             ::recovery_statistics &stats) {
+  auto state{enum_ha_recover_xa_state::NOT_FOUND};
+
+  if (info.xa_list != nullptr) {
+    state = info.xa_list->find(xa_trx.id);
+  }
+
+  switch (state) {
+    case enum_ha_recover_xa_state::NOT_FOUND: {
+      if (ht.commit_by_xid != nullptr) {
+        enum xa_status_code exec_status;
+        if (DBUG_EVALUATE_IF("xa_recovery_error_reporting", true, false))
+          exec_status = ::generate_xa_recovery_error();
+        else
+          exec_status = ht.commit_by_xid(&ht, const_cast<XID *>(&xa_trx.id));
+
+        if (exec_status == XA_OK) {
+          ::add_to_stats<STATS_SUCCESS, STATS_COMMITTED>(stats);
+          break;
+        } else
+          ::report_trx_recovery_error(ER_BINLOG_CRASH_RECOVERY_COMMIT_FAILED,
+                                      xa_trx.id, ht, exec_status,
+                                      /*is_xa*/ true);
+      }
+      ::add_to_stats<STATS_FAILURE, STATS_COMMITTED>(stats);
+      break;
+    }
+    case enum_ha_recover_xa_state::PREPARED_IN_SE: {
+      if (ht.rollback_by_xid != nullptr) {
+        enum xa_status_code exec_status;
+        if (DBUG_EVALUATE_IF("xa_recovery_error_reporting", true, false))
+          exec_status = ::generate_xa_recovery_error();
+        else
+          exec_status = ht.rollback_by_xid(&ht, const_cast<XID *>(&xa_trx.id));
+
+        if (exec_status == XA_OK) {
+          ::add_to_stats<STATS_SUCCESS, STATS_ROLLEDBACK>(stats);
+          break;
+        } else
+          ::report_trx_recovery_error(ER_BINLOG_CRASH_RECOVERY_ROLLBACK_FAILED,
+                                      xa_trx.id, ht, exec_status,
+                                      /*is_xa*/ true);
+      }
+      ::add_to_stats<STATS_FAILURE, STATS_ROLLEDBACK>(stats);
+      break;
+    }
+    case enum_ha_recover_xa_state::PREPARED_IN_TC: {
+      if (!Recovered_xa_transactions::instance().add_prepared_xa_transaction(
+              &xa_trx)) {
+        if (ht.set_prepared_in_tc_by_xid != nullptr) {
+          enum xa_status_code exec_status;
+          if (DBUG_EVALUATE_IF("xa_recovery_error_reporting", true, false))
+            exec_status = ::generate_xa_recovery_error();
+          else
+            exec_status = ht.set_prepared_in_tc_by_xid(
+                &ht, const_cast<XID *>(&xa_trx.id));
+
+          if (exec_status == XA_OK) {
+            ::add_to_stats<STATS_SUCCESS, STATS_PREPARED>(stats);
+            break;
+          } else
+            ::report_trx_recovery_error(ER_BINLOG_CRASH_RECOVERY_PREPARE_FAILED,
+                                        xa_trx.id, ht, exec_status,
+                                        /*is_xa*/ true);
+        }
+      }
+      ::add_to_stats<STATS_FAILURE, STATS_PREPARED>(stats);
+      break;
+    }
+    default: {
+      break;
+    }
+  }
+}
+#endif
+
 template <size_t state, size_t counter>
 void add_to_stats(::recovery_statistics &stats) {
   ++std::get<counter>(std::get<state>(stats));
diff --git a/sql/xa/recovery.h b/sql/xa/recovery.h
index 6ba40e12714..f498f197bce 100644
--- a/sql/xa/recovery.h
+++ b/sql/xa/recovery.h
@@ -79,6 +79,9 @@ bool recover_prepared_in_tc_one_ht(THD *thd, plugin_ref plugin, void *arg);
   @return false if the recovery ended successfully, false otherwise.
  */
 bool recover_one_ht(THD *thd, plugin_ref plugin, void *arg);
+#ifdef WESQL_CLUSTER
+bool inverse_recover_one_ht(THD *thd, plugin_ref plugin, void *arg);
+#endif
 }  // namespace recovery
 }  // namespace xa
 #endif  // XA_RECOVERY_H_INCLUDED
diff --git a/strings/ctype-simple.cc b/strings/ctype-simple.cc
index fba9581c07c..3ea5342c2a2 100644
--- a/strings/ctype-simple.cc
+++ b/strings/ctype-simple.cc
@@ -1510,7 +1510,11 @@ uint my_strxfrm_flag_normalize(uint flags) {
 
 size_t my_strxfrm_pad(const CHARSET_INFO *cs, uchar *str, uchar *frmend,
                       uchar *strend, uint nweights, uint flags) {
+#ifdef WITH_SMARTENGINE
+  if (nweights && frmend < strend && !(flags & MY_STRXFRM_NOPAD_WITH_SPACE)) {
+#else
   if (nweights && frmend < strend) {
+#endif
     // PAD SPACE behavior.
     uint fill_length = std::min<uint>(strend - frmend, nweights * cs->mbminlen);
     cs->cset->fill(cs, (char *)frmend, fill_length, cs->pad_char);
diff --git a/strings/ctype-uca.cc b/strings/ctype-uca.cc
index 554f9693f4f..db0f027195f 100644
--- a/strings/ctype-uca.cc
+++ b/strings/ctype-uca.cc
@@ -2073,7 +2073,11 @@ static size_t my_strnxfrm_uca(const CHARSET_INFO *cs, Mb_wc mb_wc, uchar *dst,
     if (dst < de) *dst++ = s_res & 0xFF;
   }
 
+#ifdef WITH_SMARTENGINE
+  if (dst < de && !(flags & MY_STRXFRM_NOPAD_WITH_SPACE)) {
+#else
   if (dst < de) {
+#endif
     /*
       PAD SPACE behavior.
 
diff --git a/strings/ctype-utf8.cc b/strings/ctype-utf8.cc
index f8800881884..279a1a1541b 100644
--- a/strings/ctype-utf8.cc
+++ b/strings/ctype-utf8.cc
@@ -5084,7 +5084,11 @@ static inline size_t my_strnxfrm_unicode_tmpl(const CHARSET_INFO *cs,
   }
 
 pad:
+#ifdef WITH_SMARTENGINE
+  if (dst < de && nweights && !(flags & MY_STRXFRM_NOPAD_WITH_SPACE))
+#else
   if (dst < de && nweights)  // PAD SPACE behavior.
+#endif
     dst += my_strxfrm_pad_nweights_unicode(dst, de, nweights);
 
   if ((flags & MY_STRXFRM_PAD_TO_MAXLEN) && dst < de)
@@ -5154,7 +5158,11 @@ size_t my_strnxfrm_unicode_full_bin(const CHARSET_INFO *cs, uchar *dst,
         if (dst < de) *dst++ = 0x20;
       }
     }
+#ifdef WITH_SMARTENGINE
+  } else if (!(flags & MY_STRXFRM_NOPAD_WITH_SPACE)) {
+#else
   } else {
+#endif
     // Regular PAD SPACE behavior.
     for (; dst < de && nweights; nweights--) {
       *dst++ = 0x00;
diff --git a/strings/int2str.cc b/strings/int2str.cc
index b308a684d17..52afe2de7f4 100644
--- a/strings/int2str.cc
+++ b/strings/int2str.cc
@@ -39,6 +39,78 @@
 const char _dig_vec_upper[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
 const char _dig_vec_lower[] = "0123456789abcdefghijklmnopqrstuvwxyz";
 
+#ifdef WESQL
+/*
+  Convert integer to its string representation in given scale of notation.
+
+  SYNOPSIS
+    int2str()
+      val     - value to convert
+      dst     - points to buffer where string representation should be stored
+      radix   - radix of scale of notation
+      upcase  - set to 1 if we should use upper-case digits
+
+  DESCRIPTION
+    Converts the (long) integer value to its character form and moves it to
+    the destination buffer followed by a terminating NUL.
+    If radix is -2..-36, val is taken to be SIGNED, if radix is  2..36, val is
+    taken to be UNSIGNED. That is, val is signed if and only if radix is.
+    All other radixes treated as bad and nothing will be changed in this case.
+
+    For conversion to decimal representation (radix is -10 or 10) one can use
+    optimized int10_to_str() function.
+
+  RETURN VALUE
+    Pointer to ending NUL character or NullS if radix is bad.
+*/
+
+char *int2str(long int val, char *dst, int radix, int upcase) {
+  char buffer[65];
+  char *p;
+  long int new_val;
+  const char *dig_vec = upcase ? _dig_vec_upper : _dig_vec_lower;
+  ulong uval = (ulong)val;
+
+  if (radix < 0) {
+    if (radix < -36 || radix > -2) return NullS;
+    if (val < 0) {
+      *dst++ = '-';
+      /* Avoid integer overflow in (-val) for LLONG_MIN (BUG#31799). */
+      uval = (ulong)0 - uval;
+    }
+    radix = -radix;
+  } else if (radix > 36 || radix < 2)
+    return NullS;
+
+  /*
+    The slightly contorted code which follows is due to the fact that
+    few machines directly support unsigned long / and %.  Certainly
+    the VAX C compiler generates a subroutine call.  In the interests
+    of efficiency (hollow laugh) I let this happen for the first digit
+    only; after that "val" will be in range so that signed integer
+    division will do.  Sorry 'bout that.  CHECK THE CODE PRODUCED BY
+    YOUR C COMPILER.  The first % and / should be unsigned, the second
+    % and / signed, but C compilers tend to be extraordinarily
+    sensitive to minor details of style.  This works on a VAX, that's
+    all I claim for it.
+  */
+  p = &buffer[sizeof(buffer) - 1];
+  *p = '\0';
+  new_val = uval / (ulong)radix;
+  *--p = dig_vec[(uchar)(uval - (ulong)new_val * (ulong)radix)];
+  val = new_val;
+  while (val != 0) {
+    ldiv_t res;
+    res = ldiv(val, radix);
+    *--p = dig_vec[res.rem];
+    val = res.quot;
+  }
+  while ((*dst++ = *p++) != 0)
+    ;
+  return dst - 1;
+}
+#endif
+
 /**
   Converts a 64-bit integer value to its character form and moves it to the
   destination buffer followed by a terminating NUL. If radix is -2..-36, val is
